\PassOptionsToPackage{unicode=true}{hyperref} % options for packages loaded elsewhere
\PassOptionsToPackage{hyphens}{url}
\PassOptionsToPackage{dvipsnames,svgnames*,x11names*}{xcolor}
%
\documentclass[]{krantz}
\usepackage{lmodern}
\usepackage{amssymb,amsmath}
\usepackage{ifxetex,ifluatex}
\usepackage{fixltx2e} % provides \textsubscript
\ifnum 0\ifxetex 1\fi\ifluatex 1\fi=0 % if pdftex
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
  \usepackage{textcomp} % provides euro and other symbols
\else % if luatex or xelatex
  \usepackage{unicode-math}
  \defaultfontfeatures{Ligatures=TeX,Scale=MatchLowercase}
\fi
% use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
% use microtype if available
\IfFileExists{microtype.sty}{%
\usepackage[]{microtype}
\UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
\IfFileExists{parskip.sty}{%
\usepackage{parskip}
}{% else
\setlength{\parindent}{0pt}
\setlength{\parskip}{6pt plus 2pt minus 1pt}
}
\usepackage{xcolor}
\usepackage{hyperref}
\hypersetup{
            pdftitle={R Programming for Data Sciences},
            pdfauthor={Andrew O. Finley, Vince Melfi, Jeffrey W. Doser},
            colorlinks=true,
            linkcolor=Maroon,
            filecolor=Maroon,
            citecolor=Blue,
            urlcolor=Blue,
            breaklinks=true}
\urlstyle{same}  % don't use monospace font for urls
\usepackage{color}
\usepackage{fancyvrb}
\newcommand{\VerbBar}{|}
\newcommand{\VERB}{\Verb[commandchars=\\\{\}]}
\DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
% Add ',fontsize=\small' for more characters per line
\usepackage{framed}
\definecolor{shadecolor}{RGB}{248,248,248}
\newenvironment{Shaded}{\begin{snugshade}}{\end{snugshade}}
\newcommand{\AlertTok}[1]{\textcolor[rgb]{0.33,0.33,0.33}{#1}}
\newcommand{\AnnotationTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{\textbf{\textit{#1}}}}
\newcommand{\AttributeTok}[1]{\textcolor[rgb]{0.61,0.61,0.61}{#1}}
\newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.06,0.06,0.06}{#1}}
\newcommand{\BuiltInTok}[1]{#1}
\newcommand{\CharTok}[1]{\textcolor[rgb]{0.5,0.5,0.5}{#1}}
\newcommand{\CommentTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{\textit{#1}}}
\newcommand{\CommentVarTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{\textbf{\textit{#1}}}}
\newcommand{\ConstantTok}[1]{\textcolor[rgb]{0,0,0}{#1}}
\newcommand{\ControlFlowTok}[1]{\textcolor[rgb]{0.27,0.27,0.27}{\textbf{#1}}}
\newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.27,0.27,0.27}{#1}}
\newcommand{\DecValTok}[1]{\textcolor[rgb]{0.06,0.06,0.06}{#1}}
\newcommand{\DocumentationTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{\textbf{\textit{#1}}}}
\newcommand{\ErrorTok}[1]{\textcolor[rgb]{0.14,0.14,0.14}{\textbf{#1}}}
\newcommand{\ExtensionTok}[1]{#1}
\newcommand{\FloatTok}[1]{\textcolor[rgb]{0.06,0.06,0.06}{#1}}
\newcommand{\FunctionTok}[1]{\textcolor[rgb]{0,0,0}{#1}}
\newcommand{\ImportTok}[1]{#1}
\newcommand{\InformationTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{\textbf{\textit{#1}}}}
\newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.27,0.27,0.27}{\textbf{#1}}}
\newcommand{\NormalTok}[1]{#1}
\newcommand{\OperatorTok}[1]{\textcolor[rgb]{0.43,0.43,0.43}{\textbf{#1}}}
\newcommand{\OtherTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{#1}}
\newcommand{\PreprocessorTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{\textit{#1}}}
\newcommand{\RegionMarkerTok}[1]{#1}
\newcommand{\SpecialCharTok}[1]{\textcolor[rgb]{0,0,0}{#1}}
\newcommand{\SpecialStringTok}[1]{\textcolor[rgb]{0.5,0.5,0.5}{#1}}
\newcommand{\StringTok}[1]{\textcolor[rgb]{0.5,0.5,0.5}{#1}}
\newcommand{\VariableTok}[1]{\textcolor[rgb]{0,0,0}{#1}}
\newcommand{\VerbatimStringTok}[1]{\textcolor[rgb]{0.5,0.5,0.5}{#1}}
\newcommand{\WarningTok}[1]{\textcolor[rgb]{0.37,0.37,0.37}{\textbf{\textit{#1}}}}
\usepackage{longtable,booktabs}
% Fix footnotes in tables (requires footnote package)
\IfFileExists{footnote.sty}{\usepackage{footnote}\makesavenoteenv{longtable}}{}
\usepackage{graphicx,grffile}
\makeatletter
\def\maxwidth{\ifdim\Gin@nat@width>\linewidth\linewidth\else\Gin@nat@width\fi}
\def\maxheight{\ifdim\Gin@nat@height>\textheight\textheight\else\Gin@nat@height\fi}
\makeatother
% Scale images if necessary, so that they will not overflow the page
% margins by default, and it is still possible to overwrite the defaults
% using explicit options in \includegraphics[width, height, ...]{}
\setkeys{Gin}{width=\maxwidth,height=\maxheight,keepaspectratio}
\setlength{\emergencystretch}{3em}  % prevent overfull lines
\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
\setcounter{secnumdepth}{5}
% Redefines (sub)paragraphs to behave more like sections
\ifx\paragraph\undefined\else
\let\oldparagraph\paragraph
\renewcommand{\paragraph}[1]{\oldparagraph{#1}\mbox{}}
\fi
\ifx\subparagraph\undefined\else
\let\oldsubparagraph\subparagraph
\renewcommand{\subparagraph}[1]{\oldsubparagraph{#1}\mbox{}}
\fi

% set default figure placement to htbp
\makeatletter
\def\fps@figure{htbp}
\makeatother

\usepackage{booktabs}
\usepackage{longtable}
\usepackage[bf,singlelinecheck=off]{caption}

\usepackage{framed,color}
\definecolor{shadecolor}{RGB}{248,248,248}

\renewcommand{\textfraction}{0.05}
\renewcommand{\topfraction}{0.8}
\renewcommand{\bottomfraction}{0.8}
\renewcommand{\floatpagefraction}{0.75}

\renewenvironment{quote}{\begin{VF}}{\end{VF}}
\let\oldhref\href
\renewcommand{\href}[2]{#2\footnote{\url{#1}}}

\makeatletter
\newenvironment{kframe}{%
\medskip{}
\setlength{\fboxsep}{.8em}
 \def\at@end@of@kframe{}%
 \ifinner\ifhmode%
  \def\at@end@of@kframe{\end{minipage}}%
  \begin{minipage}{\columnwidth}%
 \fi\fi%
 \def\FrameCommand##1{\hskip\@totalleftmargin \hskip-\fboxsep
 \colorbox{shadecolor}{##1}\hskip-\fboxsep
     % There is no \\@totalrightmargin, so:
     \hskip-\linewidth \hskip-\@totalleftmargin \hskip\columnwidth}%
 \MakeFramed {\advance\hsize-\width
   \@totalleftmargin\z@ \linewidth\hsize
   \@setminipage}}%
 {\par\unskip\endMakeFramed%
 \at@end@of@kframe}
\makeatother

\renewenvironment{Shaded}{\begin{kframe}}{\end{kframe}}

\usepackage{makeidx}
\makeindex

\urlstyle{tt}

\usepackage{amsthm}
\makeatletter
\def\thm@space@setup{%
  \thm@preskip=8pt plus 2pt minus 4pt
  \thm@postskip=\thm@preskip
}
\makeatother

\frontmatter
\usepackage[]{natbib}
\bibliographystyle{apalike}

\title{R Programming for Data Sciences}
\author{Andrew O. Finley, Vince Melfi, Jeffrey W. Doser}
\date{2019-05-18}

\begin{document}
\maketitle

% you may need to leave a few empty pages before the dedication page

%\cleardoublepage\newpage\thispagestyle{empty}\null
%\cleardoublepage\newpage\thispagestyle{empty}\null
%\cleardoublepage\newpage
\thispagestyle{empty}

\begin{center}
To my son,

without whom I should have finished this book two years earlier
%\includegraphics{images/dedication.pdf}
\end{center}

\setlength{\abovedisplayskip}{-5pt}
\setlength{\abovedisplayshortskip}{-5pt}

{
\hypersetup{linkcolor=}
\setcounter{tocdepth}{2}
\tableofcontents
}
\listoftables
\listoffigures
\hypertarget{course-description}{%
\chapter*{Course Description}\label{course-description}}


This book serves as an introduction to programming in R and the use of associated open source tools. We address practical issues in documenting workflow, data management, and scientific computing.

\mainmatter

\hypertarget{introduction}{%
\chapter{Introduction}\label{introduction}}

Now unplug your Internet cable, and start doing some serious work.

We have a nice figure in Figure \ref{fig:hello}, and also a table in Table \ref{tab:iris}.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{>}\StringTok{ }\KeywordTok{par}\NormalTok{(}\DataTypeTok{mar =} \KeywordTok{c}\NormalTok{(}\DecValTok{4}\NormalTok{, }\DecValTok{4}\NormalTok{, }\DecValTok{1}\NormalTok{, }\FloatTok{0.1}\NormalTok{))}
\OperatorTok{>}\StringTok{ }\KeywordTok{plot}\NormalTok{(cars, }\DataTypeTok{pch =} \DecValTok{19}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{>}\StringTok{ }\NormalTok{knitr}\OperatorTok{::}\KeywordTok{kable}\NormalTok{(}\KeywordTok{head}\NormalTok{(iris), }\DataTypeTok{caption =} \StringTok{"The boring iris data."}\NormalTok{, }
\OperatorTok{+}\StringTok{   }\DataTypeTok{booktabs =} \OtherTok{TRUE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

More chapters to come in \texttt{02-foo.Rmd}, \texttt{03-bar}.Rmd, \ldots{}

\hypertarget{introduction-to-r-and-rstudio}{%
\chapter{Introduction to R and RStudio}\label{introduction-to-r-and-rstudio}}

Various statistical and programming software environments are used in data science, including R, Python, SAS, C++, SPSS, and many others. Each has strengths and weaknesses, and often two or more are used in a single project. This book focuses on R for several reasons:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  R is free
\item
  It is one of, if not the, most widely used software environments in data science
\item
  R is under constant and open development by a diverse and expert core group
\item
  It has an incredible variety of contributed packages
\item
  A new user can (relatively) quickly gain enough skills to obtain, manage, and analyze data in R
\end{enumerate}

Several enhanced interfaces for R have been developed. Generally such interfaces are referred to as \emph{integrated development environments (IDE)}. These interfaces are used to facilitate software development. At minimum, an IDE typically consists of a source code editor and build automation tools. We will use the RStudio IDE, which according to its developers ``is a powerful productive user interface for R.''\footnote{\url{http://www.rstudio.com/}} RStudio is widely used, it is used increasingly in the R community, and it makes learning to use R a bit simpler. Although we will use RStudio, most of what is presented in this book can be accomplished in R (without an added interface) with few or no changes.

\hypertarget{obtaining-and-installing-r}{%
\section{Obtaining and Installing R}\label{obtaining-and-installing-r}}

It is simple to install R on computers running Microsoft Windows, macOS, or Linux. For other operating systems users can compile the source code directly.\footnote{Windows, macOS, and Linux users also can compile the source code directly, but for most it is a better idea to install R from already compiled binary distributions.}
Here is a step-by-step guide to installing R for Microsoft Windows.\footnote{New versions of R are released regularly, so the version number in Step 6 might be different from what is listed below.} macOS and Linux users would follow similar steps.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Go to \url{http://www.r-project.org/}
\item
  Click on the \texttt{CRAN} link on the left side of the page
\item
  Choose one of the mirrors.\footnote{The \url{http://cran.rstudio.com/} mirror is usually fast. Otherwise choose a mirror in Michigan.}
\item
  Click on \texttt{Download\ R\ for\ Windows}
\item
  Click on \texttt{base}
\item
  Click on \texttt{Download\ R\ 3.5.0\ for\ Windows}
\item
  Install R as you would install any other Windows program
\end{enumerate}

\hypertarget{obtaining-and-installing-rstudio}{%
\section{Obtaining and Installing RStudio}\label{obtaining-and-installing-rstudio}}

You must install R prior to installing RStudio. RStudio is also simple to install:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Go to \url{http://www.rstudio.com}
\item
  Click on the link \texttt{RStudio} under the \texttt{Products} tab, then select the \texttt{Desktop} option
\item
  Click on the \texttt{Desktop} link
\item
  Choose the \texttt{DOWNLOAD\ RSTUDIO\ DESKTOP} link in the \texttt{Open\ Source\ Edition} column
\item
  On the ensuing page, click on the \texttt{Installer} version for your operating system, and once downloaded, install as you would any program
\end{enumerate}

\hypertarget{using-r-and-rstudio}{%
\section{Using R and RStudio}\label{using-r-and-rstudio}}

Start RStudio as you would any other program in your operating system. For example, under Microsoft Windows use the Start Menu or double click on the shortcut on the desktop (if a shortcut was created in the installation process). A (rather small) view of RStudio is displayed in Figure \ref{fig:rstudioPic}.

Initially the RStudio window contains three smaller windows. For now our main focus will be the large window on the left, the \texttt{Console} window, in which R statements are typed. The next few sections give simple examples of the use of R. In these sections we will focus on small and non-complex data sets, but of course later in the book we will work with much larger and more complex sets of data. Read these sections at your computer with R running, and enter the R commands there to get comfortable using the R console window and RStudio.

\hypertarget{r-as-a-calculator}{%
\subsection{R as a Calculator}\label{r-as-a-calculator}}

R can be used as a calculator. Note that \texttt{\#} is the comment character in R, so R ignores everything following this character. Also, you will see that R prints \texttt{{[}1{]}} before the results of each command. Soon we will explain its relevance, but ignore this for now. The command prompt in R is the greater than sign \texttt{\textgreater{}}.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{>}\StringTok{ }\DecValTok{34} \OperatorTok{+}\StringTok{ }\DecValTok{20} \OperatorTok{*}\StringTok{ }\KeywordTok{sqrt}\NormalTok{(}\DecValTok{100}\NormalTok{)  }\CommentTok{## +,-,*,/ have the expected meanings}
\OperatorTok{>}\StringTok{ }\KeywordTok{exp}\NormalTok{(}\DecValTok{2}\NormalTok{)  }\CommentTok{##The exponential function}
\OperatorTok{>}\StringTok{ }\KeywordTok{log10}\NormalTok{(}\DecValTok{100}\NormalTok{)  }\CommentTok{##Base 10 logarithm}
\OperatorTok{>}\StringTok{ }\KeywordTok{log}\NormalTok{(}\DecValTok{100}\NormalTok{)  }\CommentTok{##Base e logarithm}
\OperatorTok{>}\StringTok{ }\DecValTok{10}\OperatorTok{^}\KeywordTok{log10}\NormalTok{(}\DecValTok{55}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Most functions in R can be applied to vector arguments rather than operating on a single argument at a time. A \texttt{vector} is a data structure that contains elements of the same data type (i.e.~integers).

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{>}\StringTok{ }\DecValTok{1}\OperatorTok{:}\DecValTok{25}  \CommentTok{##The integers from 1 to 25}
\OperatorTok{>}\StringTok{ }\KeywordTok{log}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{25}\NormalTok{)  }\CommentTok{##The base e logarithm of these integers}
\OperatorTok{>}\StringTok{ }\DecValTok{1}\OperatorTok{:}\DecValTok{25} \OperatorTok{*}\StringTok{ }\DecValTok{1}\OperatorTok{:}\DecValTok{25}  \CommentTok{##What will this produce?}
\OperatorTok{>}\StringTok{ }\DecValTok{1}\OperatorTok{:}\DecValTok{25} \OperatorTok{*}\StringTok{ }\DecValTok{1}\OperatorTok{:}\DecValTok{5}  \CommentTok{##What about this?}
\OperatorTok{>}\StringTok{ }\KeywordTok{seq}\NormalTok{(}\DataTypeTok{from =} \DecValTok{0}\NormalTok{, }\DataTypeTok{to =} \DecValTok{1}\NormalTok{, }\DataTypeTok{by =} \FloatTok{0.1}\NormalTok{)  }\CommentTok{##A sequence of numbers from 0 to 1}
\OperatorTok{>}\StringTok{ }\KeywordTok{exp}\NormalTok{(}\KeywordTok{seq}\NormalTok{(}\DataTypeTok{from =} \DecValTok{0}\NormalTok{, }\DataTypeTok{to =} \DecValTok{1}\NormalTok{, }\DataTypeTok{by =} \FloatTok{0.1}\NormalTok{))  }\CommentTok{##What will this produce?}
\end{Highlighting}
\end{Shaded}

Now the mysterious square bracketed numbers appearing next to the output make sense. R puts the position of the beginning value on a line in square brackets before the line of output. For example if the output has 40 values, and 15 values appear on each line, then the first line will have \texttt{{[}1{]}} at the left, the second line will have \texttt{{[}16{]}} to the left, and the third line will have \texttt{{[}31{]}} to the left.

\hypertarget{dec}{%
\subsection{Basic descriptive statistics and graphics in R}\label{dec}}

It is easy to compute basic descriptive statistics and to produce standard graphical representations of data in R. First we create three variables with horsepower, miles per gallon, and names for 15 cars.\footnote{These are from a relatively old data set, with 1974 model cars.} In this case with a small data set we enter the data ``by hand'' using the \texttt{c()} function, which concatenates its arguments into a vector. For larger data sets we will clearly want an alternative. Note that character values are surrounded by quotation marks.

A style note: R has two widely used methods of assignment: the left arrow, which consists of a less than sign followed immediately by a dash: \texttt{\textless{}-} and the equals sign: \texttt{=}. Much ink has been used debating the relative merits of the two methods, and their subtle differences. Many leading R style guides (e.g., the Google style guide at \url{https://google.github.io/styleguide/Rguide.xml} and the Bioconductor style guide at \url{http://www.bioconductor.org/developers/how-to/coding-style/}) recommend the left arrow \texttt{\textless{}-} as an assignment operator, and we will use this throughout the book.

Also you will see that if a command has not been completed but the ENTER key is pressed, the command prompt changes to a \texttt{+} sign.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{>}\StringTok{ }\NormalTok{car.hp <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\DecValTok{110}\NormalTok{, }\DecValTok{110}\NormalTok{, }\DecValTok{93}\NormalTok{, }\DecValTok{110}\NormalTok{, }\DecValTok{175}\NormalTok{, }\DecValTok{105}\NormalTok{, }\DecValTok{245}\NormalTok{, }\DecValTok{62}\NormalTok{, }\DecValTok{95}\NormalTok{, }\DecValTok{123}\NormalTok{, }
\OperatorTok{+}\StringTok{ }\DecValTok{123}\NormalTok{, }\DecValTok{180}\NormalTok{, }\DecValTok{180}\NormalTok{, }\DecValTok{180}\NormalTok{, }\DecValTok{205}\NormalTok{)}
\OperatorTok{>}\StringTok{ }\NormalTok{car.mpg <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\FloatTok{21.0}\NormalTok{, }\FloatTok{21.0}\NormalTok{, }\FloatTok{22.8}\NormalTok{, }\FloatTok{21.4}\NormalTok{, }\FloatTok{18.7}\NormalTok{, }\FloatTok{18.1}\NormalTok{, }\FloatTok{14.3}\NormalTok{, }\FloatTok{24.4}\NormalTok{, }\FloatTok{22.8}\NormalTok{, }
\OperatorTok{+}\StringTok{              }\FloatTok{19.2}\NormalTok{, }\FloatTok{17.8}\NormalTok{, }\FloatTok{16.4}\NormalTok{, }\FloatTok{17.3}\NormalTok{, }\FloatTok{15.2}\NormalTok{, }\FloatTok{10.4}\NormalTok{)}
\OperatorTok{>}\StringTok{ }\NormalTok{car.name <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"Mazda RX4"}\NormalTok{, }\StringTok{"Mazda RX4 Wag"}\NormalTok{, }\StringTok{"Datsun 710"}\NormalTok{, }
\OperatorTok{+}\StringTok{               "Hornet 4 Drive"}\NormalTok{, }\StringTok{"Hornet Sportabout"}\NormalTok{, }\StringTok{"Valiant"}\NormalTok{, }
\OperatorTok{+}\StringTok{               "Duster 360"}\NormalTok{, }\StringTok{"Merc 240D"}\NormalTok{, }\StringTok{"Merc 230"}\NormalTok{, }\StringTok{"Merc 280"}\NormalTok{, }
\OperatorTok{+}\StringTok{               "Merc 280C"}\NormalTok{, }\StringTok{"Merc 450SE"}\NormalTok{, }\StringTok{"Merc 450SL"}\NormalTok{, }
\OperatorTok{+}\StringTok{               "Merc 450SLC"}\NormalTok{, }\StringTok{"Cadillac Fleetwood"}\NormalTok{)}
\OperatorTok{>}\StringTok{ }\NormalTok{car.hp}
\OperatorTok{>}\StringTok{ }\NormalTok{car.mpg}
\OperatorTok{>}\StringTok{ }\NormalTok{car.name}
\end{Highlighting}
\end{Shaded}

Next we compute some descriptive statistics for the two numeric variables (\texttt{car.hp} and \texttt{car.mpg})

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{>}\StringTok{ }\KeywordTok{mean}\NormalTok{(car.hp)}
\OperatorTok{>}\StringTok{ }\KeywordTok{sd}\NormalTok{(car.hp)}
\OperatorTok{>}\StringTok{ }\KeywordTok{summary}\NormalTok{(car.hp)}
\OperatorTok{>}\StringTok{ }\KeywordTok{mean}\NormalTok{(car.mpg)}
\OperatorTok{>}\StringTok{ }\KeywordTok{sd}\NormalTok{(car.mpg)}
\OperatorTok{>}\StringTok{ }\KeywordTok{summary}\NormalTok{(car.mpg)}
\end{Highlighting}
\end{Shaded}

Next, a scatter plot of \texttt{cars.mpg} versus \texttt{cars.hp}:

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{>}\StringTok{ }\KeywordTok{plot}\NormalTok{(car.hp, car.mpg)}
\end{Highlighting}
\end{Shaded}

Unsurprisingly as horsepower increases, mpg tends to decrease. This relationship can be investigated further using linear regression, a statistical procedure that involves fitting a linear model to a data set in order to further understand the relationship between two variables.

\hypertarget{an-initial-tour-of-rstudio}{%
\subsection{An Initial Tour of RStudio}\label{an-initial-tour-of-rstudio}}

When you created the \texttt{car.hp} and other vectors in the previous section, you might have noticed the vector name and a short description of its attributes appear in the top right \texttt{Global\ Environment} window. Similarly, when you called \texttt{plot(car.hp,car.mpg)} the corresponding plot appeared in the lower right \texttt{Plots} window.

A comprehensive, but slightly overwhelming, cheatsheet for RStudio is available here \url{https://www.rstudio.com/wp-content/uploads/2016/01/rstudio-IDE-cheatsheet.pdf}. As we progress in learning R and RStudio, this cheatsheet will become more useful. For now you might use the cheatsheet to locate the various windows and functions identified in the coming chapters.

\hypertarget{getting-help}{%
\section{Getting Help}\label{getting-help}}

There are several free (and several not free) ways to get R help when needed.

Several help-related functions are built into R. If there's a particular R function of interest, such as \texttt{log}, \texttt{help(log)} or \texttt{?log} will bring up a help page for that function. In RStudio the help page is displayed, by default, in the \texttt{Help} tab in the lower right window.\footnote{There are ways to change this default behavior.} The function \texttt{help.start} opens a window which allows browsing of the online documentation included with R. To use this, type \texttt{help.start()} in the console window.\footnote{You may wonder about the parentheses after \texttt{help.start}. A user can specify arguments to any R function inside parentheses. For example \texttt{log(10)} asks R to return the logarithm of the argument 10. Even if no arguments are needed, R requires empty parentheses at the end of any function name. In fact if you just type the function name without parentheses, R returns the definition of the function. For simple functions this can be illuminating.} The \texttt{help.start} function also provides several manuals online and can be a useful interface in addition to the built in help.

Search engines provide another, sometimes more user-friendly, way to receive answers for R questions. A Google search often quickly finds something written by another user who had the same (or a similar) question, or an online tutorial that touches on the question. More specialized is \href{http://rseek.org}{rseek.org}, which is a search engine focused specifically on R. Both Google and \href{http://rseek.org}{rseek.org} are valuable tools, often providing more user-friendly information then R's own help system.

In addition, R users have written many types of contributed documentation. Some of this documentation is available at \url{http://cran.r-project.org/other-docs.html}. Of course there are also numerous books covering general and specialized R topics available for purchase.

\hypertarget{workspace-working-directory-and-keeping-organized}{%
\section{Workspace, Working Directory, and Keeping Organized}\label{workspace-working-directory-and-keeping-organized}}

The \emph{workspace} is your R session working environment and includes any objects you create. Recall these objects are listed in the \texttt{Global\ Environment} window. The command \texttt{ls()}, which stands for list, will also list all the objects in your workspace (note, this is the same list that is given in the \texttt{Global\ Environment} window). When you close RStudio, a dialog box will ask you if you want to save an image of the current workspace. If you choose to save your workspace, RStudio saves your session objects and information in a \texttt{.RData} file (the period makes it a hidden file) in your \emph{working directory}. Next time you start R or RStudio it checks if there is a \texttt{.RData} in the working directory, loads it if it exists, and your session continues where you left off. Otherwise R starts with an empty workspace. This leads to the next question---what is a working directory?

Each R session is associated with a working directory. This is just a directory from which R reads and writes files, e.g., the \texttt{.RData} file, data files you want to analyze, or files you want to save. On Mac when you start RStudio it sets the working directory to your home directory (for me that's \texttt{/Users/andy}). If you're on a different operating system, you can check where the default working directory is by typing \texttt{getwd()} in the console. You can change the default working directory under RStudio's \verb+Global Option+ dialog found under the \texttt{Tools} dropdown menu. There are multiple ways to change the working directory once an R session is started in RStudio. One method is to click on the \texttt{Files} tab in the lower right window and then click the \texttt{More} button. Alternatively, you can set the session's working directory using the \texttt{setwd()} in the console. For example, on Windows \texttt{setwd("C:/Users/andy/for875/exercise1")} will set the working directory to \texttt{C:/Users/andy/for875/exercise1}, assuming that file path and directory exist (Note: Windows file path uses a backslash, \texttt{\textbackslash{}}, but in R the backslash is an escape character, hence specifying file paths in R on Windows uses the forward slash, i.e., \texttt{/}). Similarly on Mac you can use \texttt{setwd("/Users/andy/for875/exercise1")}. Perhaps the most simple method is to click on the \texttt{Session} tab at the top of your screen and click on the \texttt{Set\ Working\ Directory} option. Later on when we start reading and writing data from our R session, it will be very important that you are able to identify your current working directory and change it if needed. We will revisit this in subsequent chapters.

As with all work, keeping organized is the key to efficiency. It is good practice to have a dedicated directory for each R project or exercise.

\hypertarget{quality-of-r-code}{%
\section{Quality of R code}\label{quality-of-r-code}}

Writing well-organized and well-labeled code allows your code to be more easily read and understood by another person. (See xkcd's take on code quality in Figure \ref{fig:comic}.) More importantly, though, your well-written code is more accessible to you hours, days, or even months later. We are hoping that you can use the code you write in this class in future projects and research.

Google provides style guides for many programming languages. You can find the R style guide \href{https://google.github.io/styleguide/Rguide.xml}{here}. Below are a few of the key points from the guide that we will use right away.

\hypertarget{naming-files}{%
\subsection{Naming Files}\label{naming-files}}

File names should be meaningful and end in \texttt{.R}. If we write a script that analyzes a certain species distribution:

\begin{itemize}
\tightlist
\item
  GOOD: \(\color{green}{\verb+african_rhino_distribution.R+}\)
\item
  GOOD: \(\color{green}{\verb+africanRhinoDistribution.R+}\)
\item
  BAD: \(\color{red}{\verb+speciesDist.R+}\) (too ambiguous)
\item
  BAD: \(\color{red}{\verb+species.dist.R+}\) (too ambiguous and two periods can confuse operating systems' file type auto-detect)
\item
  BAD: \(\color{red}{\verb+speciesdist.R+}\) (too ambiguous and confusing)
\end{itemize}

\hypertarget{naming-variables}{%
\subsection{Naming Variables}\label{naming-variables}}

\begin{itemize}
\tightlist
\item
  GOOD: \(\color{green}{\verb+rhino.count+}\)
\item
  GOOD: \(\color{green}{\verb+rhinoCount+}\)
\item
  GOOD: \(\color{green}{\verb+rhino_count+}\) (We don't mind the underscore and use it quite often, although Google's style guide says it's a no-no for some reason)
\item
  BAD: \(\color{red}{\verb+rhinocount+}\) (confusing)
\end{itemize}

\hypertarget{syntax}{%
\subsection{Syntax}\label{syntax}}

\begin{itemize}
\tightlist
\item
  Keep code lines under 80 characters long.
\item
  Indent your code with two spaces. (RStudio does this by default when you press the TAB key.)
\end{itemize}

\hypertarget{scripts-and-r-markdown}{%
\chapter{Scripts and R Markdown}\label{scripts-and-r-markdown}}

Doing work in data science, whether for homework, a project for a business, or a research project, typically involves several iterations. For example creating an effective graphical representation of data can involve trying out several different graphical representations, and then tens if not hundreds of iterations when fine-tuning the chosen representation. Furthermore, each of these representations may require several R commands to create. Although this all could be accomplished by typing and re-typing commands at the R Console, it is easier and more effective to write the commands in a \emph{script file}, which then can be submitted to the R console either a line at a time or all together.\footnote{Unsurprisingly it is also possible to submit several selected lines of code at once.}

In addition to making the workflow more efficient, R scripts provide another large benefit. Often we work on one part of a homework assignment or project for a few hours, then move on to something else, and then return to the original part a few days, months, or sometimes even years later. In such cases we may have forgotten how we created the graphical display that we were so proud of, and will need to again spend a few hours to recreate it. If we save a script file, we have the ingredients immediately available when we return to a portion of a project.\footnote{In principle the R history mechanism provides a similar record. But with history we have to search through a lot of other code to find what we're looking for, and scripts are a much cleaner mechanism to record our work.}

Next consider the larger scientific endeavor. Ideally a scientific study will be reproducible, meaning that an independent group of researchers (or the original researchers) will be able to duplicate the study. Thinking about data science, this means that all the steps taken when working with the data from a study should be reproducible, from the selection of variables to formal data analysis. In principle, this can be facilitated by explaining, in words, each step of the work with data. In practice, it is typically difficult or impossible to reproduce a full data analysis based on a written explanation. Much more effective is to include the actual computer code which accomplished the data work in the report, whether the report is a homework assignment or a research paper. Tools in R such as \emph{R Markdown} facilitate this process.

\hypertarget{scripts-in-r}{%
\section{Scripts in R}\label{scripts-in-r}}

As noted above, scripts help to make work with data more efficient and provide a record of how data were managed and analyzed. Below we describe an example. This example uses features of R that we have not yet discussed, so don't worry about the details, but rather about how it motivates the use of a script file.

First we read in a data set containing data on (among other things) fertility rate and life expectancy for countries throughout the world, for the years 1960 through 2014.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{>}\StringTok{ }\NormalTok{u <-}\StringTok{ "http://blue.for.msu.edu/FOR875/data/WorldBank.csv"}
\OperatorTok{>}\StringTok{ }\NormalTok{WorldBank <-}\StringTok{ }\KeywordTok{read.csv}\NormalTok{(u, }\DataTypeTok{header =} \OtherTok{TRUE}\NormalTok{, }\DataTypeTok{stringsAsFactors =} \OtherTok{FALSE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Next we print the names of the variables in the data set. Don't be concerned about the specific details. Later we will learn much more about reading in data and working with data sets in R.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{>}\StringTok{ }\KeywordTok{names}\NormalTok{(WorldBank)}
\end{Highlighting}
\end{Shaded}

We will try to create a scatter plot of fertility rate versus life expectancy of countries for the year 1960. To do this we'll first create variables containing the values of fertility rate and life expectancy for 1960\footnote{This isn't necessary, but it is convenient}, and print out the first ten values of each variable.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{>}\StringTok{ }\NormalTok{fertility <-}\StringTok{ }\NormalTok{WorldBank}\OperatorTok{$}\NormalTok{fertility.rate[WorldBank}\OperatorTok{$}\NormalTok{year }\OperatorTok{==}\StringTok{ }
\OperatorTok{+}\StringTok{   }\DecValTok{1960}\NormalTok{]}
\OperatorTok{>}\StringTok{ }\NormalTok{lifeexp <-}\StringTok{ }\NormalTok{WorldBank}\OperatorTok{$}\NormalTok{life.expectancy[WorldBank}\OperatorTok{$}\NormalTok{year }\OperatorTok{==}\StringTok{ }\DecValTok{1960}\NormalTok{]}
\OperatorTok{>}\StringTok{ }\NormalTok{fertility[}\DecValTok{1}\OperatorTok{:}\DecValTok{10}\NormalTok{]}
\OperatorTok{>}\StringTok{ }\NormalTok{lifeexp[}\DecValTok{1}\OperatorTok{:}\DecValTok{10}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

We see that some countries do not have data for 1960. R represents missing data via \texttt{NA}. Of course at some point it would be good to investigate which countries' data are missing and why. The \texttt{plot()} function in R will just omit missing values, and for now we will just plot the non-missing data. A scatter plot of the data is drawn next.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{>}\StringTok{ }\KeywordTok{plot}\NormalTok{(lifeexp, fertility)}
\end{Highlighting}
\end{Shaded}

The scatter plot shows that as life expectancy increases, fertility rate tends to decrease in what appears to be a nonlinear relationship. Now that we have a basic scatter plot, it is tempting to make it more informative. We will do this by adding two features. One is to make the points' size proportional to the country's population, and the second is to make the points' color represent the region of the world the country resides in. We'll first extract the population and region variables for 1960.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{>}\StringTok{ }\NormalTok{pop <-}\StringTok{ }\NormalTok{WorldBank}\OperatorTok{$}\NormalTok{population[WorldBank}\OperatorTok{$}\NormalTok{year }\OperatorTok{==}\StringTok{ }\DecValTok{1960}\NormalTok{]}
\OperatorTok{>}\StringTok{ }\NormalTok{region <-}\StringTok{ }\NormalTok{WorldBank}\OperatorTok{$}\NormalTok{region[WorldBank}\OperatorTok{$}\NormalTok{year }\OperatorTok{==}\StringTok{ }\DecValTok{1960}\NormalTok{]}
\OperatorTok{>}\StringTok{ }\NormalTok{pop[}\DecValTok{1}\OperatorTok{:}\DecValTok{10}\NormalTok{]}
\OperatorTok{>}\StringTok{ }\NormalTok{region[}\DecValTok{1}\OperatorTok{:}\DecValTok{10}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

To create the scatter plot we will do two things. First we will create the axes, labels, etc. for the plot, but not plot the points. The argument \texttt{type="n"} tells R to do this. Then we will use the \texttt{symbols()} function to add symbols, the \texttt{circles} argument to set the sizes of the points, and the \texttt{bg} argument to set the colors. Don't worry about the details! In fact, later in the book we will learn about an R package called
\texttt{ggplot2} that provides a different way to create such plots. You'll see two plots below, first the ``empty'' plot which is just a building block, then the plot including the appropriate symbols.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{>}\StringTok{ }\KeywordTok{plot}\NormalTok{(lifeexp, fertility, }\DataTypeTok{type=}\StringTok{"n"}\NormalTok{)}
\OperatorTok{>}\StringTok{ }\KeywordTok{symbols}\NormalTok{(lifeexp, fertility, }\DataTypeTok{circles=}\KeywordTok{sqrt}\NormalTok{(pop}\OperatorTok{/}\NormalTok{pi), }\DataTypeTok{inches=}\FloatTok{0.35}\NormalTok{, }
\OperatorTok{+}\StringTok{         }\DataTypeTok{bg=}\KeywordTok{match}\NormalTok{(region, }\KeywordTok{unique}\NormalTok{(region)))}
\end{Highlighting}
\end{Shaded}

Of course we should have a key which tells the viewer which region each color represents, and a way to determine which country each point represents, and a lot of other refinements. For now we will resist such temptations.

Some of the process leading to the completed plot is shown above, such as reading in the data, creating variables representing the 1960 fertility rate and life expectancy, an intermediate plot that was rejected, and so on. A lot of the process isn't shown, simply to save space. There would likely be mistakes (either minor typing mistakes or more complex errors). Focusing only on the \texttt{symbols()} function that was used to add the colorful symbols to the scatter plot, there would likely have been a substantial number of attempts with different values of the \texttt{circles}, \texttt{inches}, and \texttt{bg} arguments before settling on the actual form used to create the plot. This is the typical process you will soon discover when producing useful data visualizations.

Now imagine trying to recreate the plot a few days later. Possibly someone saw the plot and commented that it would be interesting to see some similar plots, but for years in the 1970s when there were major famines in different countries of the world. If all the work, including all the false starts and refinements, were done at the console, it would be hard to sort things out and would take longer than necessary to create the new plots. This would be especially true if a few months had passed rather than just a few days.

But with a script file, especially a script file with a few well-chosen comments, creating the new scatter plots would be much easier. Fortunately it is quite easy to create and work with script files in RStudio.\footnote{It is also easy in R without RStudio. Just use \texttt{File\ \textgreater{}\ New\ script} to create a script file, and save it before exiting R.} Just choose \texttt{File\ \textgreater{}\ New\ File\ \textgreater{}\ R\ script} and a script window will open up in the upper left of the full RStudio window.

An example of a script window (with some R code already typed in) is shown in Figure \ref{fig:script}. From the script window the user can, among other things, save the script (either using the \texttt{File} menu or the icon near the top left of the window) and run one or more lines of code from the window (using the \texttt{run} icon in the window, or by copying and pasting into the console window). In addition, there is a \texttt{Source\ on\ Save} checkbox. If this is checked, the R code in the script window is automatically read into R and executed when the script file is saved.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{>}\StringTok{ }\NormalTok{knitr}\OperatorTok{::}\KeywordTok{include_graphics}\NormalTok{(}\StringTok{"../figures/ScriptWindow.PNG"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\hypertarget{r-markdown}{%
\section{R Markdown}\label{r-markdown}}

People typically work on data with a larger purpose in mind. Possibly the purpose is to understand a biological system more clearly. Possibly the purpose is to refine a system that recommends movies to users in an online streaming movie service. Possibly the purpose is to complete a homework assignment and demonstrate to the instructor an understanding of an aspect of data analysis. Whatever the purpose, a key aspect is communicating with the desired audience, for example, fellow researchers or an instructor.

One possibility, which is somewhat effective, is to write a document using software such as Microsoft Word\footnote{Or possibly LaTeX if the document is more technical} and to include R output such as computations and graphics by cutting and pasting into the main document. One drawback to this approach is similar to what makes script files so useful: If the document must be revised it may be hard to unearth the R code that created graphics or analyses.\footnote{Organizing the R code using script files and keeping all the work organized in a well-thought-out directory structure can help here, but this requires a level of forethought and organization that most people do not possess\(\ldots\)including myself.} A more subtle but possibly more important drawback is that the reader of the document will not know precisely how analyses were done, or how graphics were created. And over time even the author(s) of the paper will forget the details. A verbal description in a ``methods'' section of a paper can help here, but typically these do not provide all the details of the analysis, but rather might state something like, ``All analyses were carried out using R version 3.6.0.''

RStudio's website provides an excellent overview of R Markdown capabilities for reproducible research. At minimum, follow the \texttt{Get\ Started} link at \url{http://rmarkdown.rstudio.com/} and watch the introduction video.

Among other things, R Markdown provides a way to include R code that reads in data, creates graphics, or performs analyses. This is performed in a single document which is processed to create a research paper, homework assignment, or other written product. The R Markdown file is a plain text file containing text the author wants to have shown in the final document, simple commands to indicate how the text should be formatted (i.e.~boldface, italic, or a bulleted list), and R code which creates output (including graphics) on the fly. Perhaps the simplest way to get started is to see an R Markdown file and the resulting document that is produced after the R Markdown document is processed. Below we code that would comprise a very simple R Markdown file, and Figure \ref{fig:rmdOut} shows the resulting output. In this case the output created is an HTML file, but there are other possible output formats such as Microsoft Word or PDF.

\begin{verbatim}
---
title: "R Markdown"
author: "Andy Finley"
date: "April 3, 2017"
output: html_document
---

Basic formatting:

*italic*

**bold**

~~strikethrough~~
\end{verbatim}

A code chunk:

\begin{verbatim}
```{r}
x <- 1:10
y <- 10:1
mean(x)
sd(y)
```
\end{verbatim}

Inline code:

\texttt{\textasciigrave{}r\ 5+5\textasciigrave{}}

Inline code not executed:

\texttt{\textasciigrave{}5+5\textasciigrave{}}

At the top of the input R Markdown file are some lines with \texttt{-\/-\/-} at the top and bottom. These lines are not needed, but give a convenient way to specify the title, author, and date of the article that are then typeset prominently at the top of the output document. For now, don't be concerned with the lines following \texttt{output:}. These can be omitted (or included as shown).

Next are a few lines showing some of the ways that font effects such as italics, boldface, and strikethrough can be achieved. For example, an asterisk before and after text sets the text in \emph{italics}, and two asterisks before and after text sets the text in \emph{boldface}.

More important for our purposes is the ability to include R code in the R Markdown file, which will be executed with the output appearing in the output document. Bits of R code included this way are called \emph{code chunks}. The beginning of a code chunk is indicated with three backticks and an ``r'' in curly braces: \texttt{\textasciigrave{}\textasciigrave{}\textasciigrave{}\{r\}}. The end of a code chunk is indicated with three backticks: \texttt{\textasciigrave{}\textasciigrave{}\textasciigrave{}}. For example, the R Markdown file described above has one code chunk:

\begin{verbatim}
```{r}
x <- 1:10
y <- 10:1
mean(x)
sd(y)
```
\end{verbatim}

In this code chunk two vectors \texttt{x} and \texttt{y} are created, and the mean of \texttt{x} and the standard deviation of \texttt{y} are computed. In the output in Figure \ref{fig:rmdOut} the R code is reproduced, and the output of the two lines of code asking for the mean and standard deviation is shown.

\hypertarget{creating-and-processing-r-markdown-documents}{%
\subsection{Creating and Processing R Markdown Documents}\label{creating-and-processing-r-markdown-documents}}

RStudio has features which facilitate creating and processing R Markdown documents. Choose \texttt{File\ \textgreater{}\ New\ File\ \textgreater{}\ R\ \ Markdown...}. In the ensuing dialog box make sure that \texttt{Document} is highlighted on the left, enter the title and author (if desired), and choose the Default Output Format (HTML is good to begin). Then click OK. A document will appear in the upper left of the RStudio window. It is an R Markdown document, and the title and author you chose will show up, delimited by \texttt{-\/-\/-} at the top of the document. A generic body of the document will also be included.

For now just keep this generic document as is. To process it to create the HTML output, click the \texttt{Knit\ HTML} button at the top of the R Markdown window. You'll be prompted to choose a filename for the R Markdown file. Use \texttt{.Rmd} as the extension for this file. Once you've saved the file, RStudio will process the file, create the HTML output, and open this output in a new window. The HTML output file will also be saved to your working directory. This file can be shared with others, who can open it using a web browser such as Chrome or Firefox.

There are many options which allow customization of R Markdown documents. Some of these affect formatting of text in the document, while others affect how R code is evaluated and displayed. The RStudio web site contains a useful summary of many R Markdown options at www.rstudio.com/wp-content/uploads/2015/03/rmarkdown-reference.pdf. A different, but mind-numbingly busy, cheatsheet is at www.rstudio.com/wp-content/uploads/2016/03/rmarkdown-cheatsheet-2.0.pdf. Some of the more commonly used R Markdown options are described next.

\hypertarget{text-lists-and-headers}{%
\subsubsection{Text: Lists and Headers}\label{text-lists-and-headers}}

Unordered (sometimes called bulleted) lists and ordered lists are easy in R Markdown. Below we illustrate the creation of unordered and ordered lists.

\begin{itemize}
\tightlist
\item
  For an unordered list, either an asterisk, a plus sign, or a minus sign may precede list items. Use a space after these symbols before including the list text. To have second-level items (sub-lists) indent four spaces before indicating the list item. This can also be done for third-level items.
\item
  For an ordered list use a numeral followed by a period and a space (1. or 2. or 3. or \ldots{}) to indicate a numbered list, and use a letter followed by a period and a space (a. or b. or c. or \ldots{}) to indicate a lettered list. The same four space convention is used to designate sub lists.
\item
  For an ordered list, the first list item will be labeled with the number or letter that you specify, but subsequent list items will be numbered sequentially. This will become clear through the following example. Consider the R Markdown input below and the subsequent output in Figure \ref{fig:listOut}:
\end{itemize}

\begin{verbatim}
An unordered list:

* List item 1
* List item 2
    + Second level list item 1
    + Second level list item 2
        + Third level list item
* List item 3

An ordered list:

1. List item 1
2. List item 2
    c. Sub list item 1
    q. Sub list item 2
17. List item 3
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{>}\StringTok{ }\NormalTok{knitr}\OperatorTok{::}\KeywordTok{include_graphics}\NormalTok{(}\StringTok{"../figures/ListExamples.pdf"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

In those examples notice that for the ordered list, although the first-level numbers given in the R Markdown code are 1, 2, and 17, the numbers printed in the output are 1, 2, and 3. Similarly the letters given in the R Markdown code are c and q, but the output file prints c and d.

R Markdown does not give substantial control over font size. Different ``header'' levels, which provide different font sizes, are available. Put one or more hash marks (\#) in front of text to specify different header levels. Other font choices such as subscripts and superscripts are possible, by surrounding the text either by tildes or carets, respectively. More sophisticated mathematical displays are also possible, and are surrounded by dollar signs. The actual mathematical expressions are specified using a language called LaTeX. See the examples below for further information for working with headers in R Markdown and LaTeX commands.

\begin{verbatim}
# A first *level* ~~header~~

## A second level header

### A third level header

Text subscripts and superscripts:

x~2~ + y~2~

10^3^ = 1000

Mathematics examples:

$x_a$

$x^a$

$\int_0^1 x^2 dx$

$\frac{x}{y}$

$\sqrt{x}$

$\sqrt[n]{x}$

$\sum_{k=1}^n$

$\prod_{k=1}^n$
\end{verbatim}

\hypertarget{code-chunks}{%
\subsubsection{Code Chunks}\label{code-chunks}}

R Markdown provides a large number of options to vary the behavior of code chunks. In some contexts it is useful to display the output but not the R code leading to the output. In some contexts it is useful to display the R prompt and in others it is not. Perhaps it is useful to configure the size of figures created by graphics. And so on. These code chunk options and many more are described in www.rstudio.com/wp-content/uploads/2015/03/rmarkdown-reference.pdf.

Code chunk options are specified in the curly braces near the beginning of a code chunk. For example the option \texttt{echo=FALSE} would be specified via \texttt{\textasciigrave{}\textasciigrave{}\textasciigrave{}\{r,\ echo=FALSE\}}. Below are descriptions of a few of the more commonly used options. The use of these options is illustrated in Figures\textasciitilde{}\ref{FIG:CODE_CHUNK_OPTIONS1} and\textasciitilde{}\ref{FIG:CODE_CHUNK_OPTIONS2}.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \texttt{echo=FALSE} specifies that the R code should not be printed (but any output of the R code should be printed) in the resulting document.
\item
  \texttt{include=FALSE} specifies that neither the R code nor the output should be printed. However, the objects created by the code chunk will be available for use in later code chunks.
\item
  \texttt{eval=FALSE} specifies that the R code should not be evaluated.
  The code will be printed unless, for example, \texttt{echo=FALSE} is also given as an option.
\item
  \texttt{error=FALSE} and \texttt{warning=FALSE} specify that, respectively, error messages and warning messages generated by the R code should not be printed.
\item
  The \texttt{comment} option allows a specified character string to be prepended to each line of results. By default this is set to \texttt{comment\ =\ \textquotesingle{}\#\#\textquotesingle{}} which explains the two hash marks preceding results in Figure \ref{fig:rmdOut} for example. Setting \texttt{comment\ =\ NA} presents output without any character string prepended. That is done in most code chunks in this book.
\item
  \texttt{prompt=TRUE} specifies that R prompt \texttt{\textgreater{}} will be prepended to each line of R code shown in the document. \texttt{prompt\ =\ FALSE} specifies that command prompts should not be included.
\item
  \texttt{fig.height} and \texttt{fig.width} specify the height and width of figures generated by R code. These are specified in inches, so for example \texttt{fig.height=4} specifies a four inch high figure.
\end{enumerate}

The below R Markdown input and \ref{fig:codeOptions} (printed output) give examples of the use of code chunk options.

```

No options:

\begin{verbatim}
x <- 1:10
x
\end{verbatim}

echo=FALSE:
\texttt{\{r,\ echo\ =\ FALSE\}\ x\ \textless{}-\ 1:10\ x}

comment=NA:
\texttt{\{r,\ comment\ =\ NA\}\ x\ \textless{}-\ 1:10\ x}
comment=`\#', prompt=TRUE:
\texttt{\{r,\ comment\ =\ \textquotesingle{}\#\textquotesingle{},\ prompt\ =\ TRUE\}\ x\ \textless{}-\ 1:10\ x}

echo=FALSE, fig.height=4, fig.width=4:

\texttt{\{r,\ echo\ =\ FALSE,\ fig.height\ =\ 4,\ fig.width\ =\ 4\}\ y\ \textless{}-\ 10:1\ plot(x,y)}

```

\hypertarget{output-formats-other-than-html}{%
\subsection{Output Formats other than HTML}\label{output-formats-other-than-html}}

It is possible to use R Markdown to produce documents in formats other than HTML, including Word and PDF documents, among others. Next to the \texttt{Knit\ HTML} button is a down arrow. Click on this and choose \texttt{Knit\ Word} to produce a Microsoft word output document. Although there is also a \texttt{Knit\ PDF} button, PDF output requires additional software called TeX in addition to RStudio.\footnote{It isn't particularly hard to install TeX software. For a Microsoft Windows system, MiKTeX is convenient, and is available from miktex.org. For a Mac system, MacTeX is available from www.tug.org/mactex/.}

\hypertarget{latex-knitr-and-bookdown}{%
\subsection{\texorpdfstring{LaTeX, \texttt{knitr}, and \texttt{bookdown}}{LaTeX, knitr, and bookdown}}\label{latex-knitr-and-bookdown}}

While basic R Markdown provides substantial flexibility and power, it lacks features such as cross-referencing, fine control over fonts, etc. If this is desired, a variant of R Markdown called \texttt{knitr}, which has very similar syntax to R Markdown for code chunks, can be used in conjunction with the typesetting system LaTeX to produce documents. Another option is to use the R package \texttt{bookdown} which uses R Markdown syntax and some additional features to allow for writing more technical documents. In fact this book was initially created using \texttt{knitr} and LaTeX, but the simplicity of markdown syntax and the additional intricacies provided by the \texttt{bookdown} package convinced us to write the book in R Markdown using \texttt{bookdown}. For simpler tasks, basic R Markdown is plenty sufficient, and very easy to use.

\hypertarget{practice-exercises}{%
\section{Practice Exercises}\label{practice-exercises}}

\hypertarget{homework}{%
\section{Homework}\label{homework}}

\textbf{Exercise 1} Learning objectives: practice setting up a working directory and read in data; explore the workspace within RStudio and associated commands; produce basic descriptive statistics and graphics.

\textbf{Exercise 2} Learning objectives: practice working within RStudio; create a R Markdown document and resulting html document in RStudio; calculate descriptive statistics and produce graphics.

\hypertarget{structures}{%
\chapter{Data Structures}\label{structures}}

A data structure is a format for organizing and storing data. The structure is designed so that data can be accessed and worked with in specific ways. Statistical software and programming languages have methods (or functions) designed to operate on different kinds of data structures.

This chapter's focus is on data structures. To help initial understanding, the data in this chapter will be relatively modest in size and complexity. The ideas and methods, however, generalize to larger and more complex data sets.

The base data structures in R are vectors, matrices, arrays, data frames, and lists. The first three, vectors, matrices, and arrays, require all elements to be of the same type or homogeneous, e.g., all numeric or all character. Data frames and lists allow elements to be of different types or heterogeneous, e.g., some elements of a data frame may be numeric while other elements may be character. These base structures can also be organized by their dimensionality, i.e., 1-dimensional, 2-dimensional, or N-dimensional, as shown in Table \ref{tab:dataStructures}.

R has no scalar types, i.e., 0-dimensional. Individual numbers or strings are actually vectors of length one.

An efficient way to understand what comprises a given object is to use the \texttt{str()} function. \texttt{str()} is short for structure and prints a compact, human-readable description of any R data structure. For example, in the code below, we prove to ourselves that what we might think of as a scalar value is actually a vector of length one.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{>}\StringTok{ }\NormalTok{a <-}\StringTok{ }\DecValTok{1}
\OperatorTok{>}\StringTok{ }\KeywordTok{str}\NormalTok{(a)}
\OperatorTok{>}\StringTok{ }\KeywordTok{is.vector}\NormalTok{(a)}
\OperatorTok{>}\StringTok{ }\KeywordTok{length}\NormalTok{(a)}
\end{Highlighting}
\end{Shaded}

Here we assigned \texttt{a} the scalar value one. The \texttt{str(a)} prints \texttt{num\ 1}, which says \texttt{a} is numeric of length one. Then just to be sure we used the function \texttt{is.vector()} to test if \texttt{a} is in fact a vector. Then, just for fun, we asked the length of \texttt{a}, which again returns one. There are a set of similar logical tests for the other base data structures, e.g., \texttt{is.matrix()}, \texttt{is.array()}, \texttt{is.data.frame()}, and \texttt{is.list()}. These will all come in handy as we encounter different R objects.

\hypertarget{vector}{%
\section{Vectors}\label{vector}}

Think of a vector\footnote{Technically the objects described in this section are ``atomic'' vectors (all elements of the same type), since lists, to be described below, also are actually vectors. This will not be an important issue, and the shorter term vector will be used for atomic vectors below.} as a structure to represent one variable in a data set. For example a vector might hold the weights, in pounds, of 7 people in a data set. Or another vector might hold the genders of those 7 people. The \texttt{c()} function in R is useful for creating (small) vectors and for modifying existing vectors. Think of \texttt{c} as standing for ``combine''.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{>}\StringTok{ }\NormalTok{weight <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\DecValTok{123}\NormalTok{, }\DecValTok{157}\NormalTok{, }\DecValTok{205}\NormalTok{, }\DecValTok{199}\NormalTok{, }\DecValTok{223}\NormalTok{, }\DecValTok{140}\NormalTok{, }\DecValTok{105}\NormalTok{)}
\OperatorTok{>}\StringTok{ }\NormalTok{weight}
\OperatorTok{>}\StringTok{ }\NormalTok{gender <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"female"}\NormalTok{, }\StringTok{"female"}\NormalTok{, }\StringTok{"male"}\NormalTok{, }\StringTok{"female"}\NormalTok{, }\StringTok{"male"}\NormalTok{, }
\OperatorTok{+}\StringTok{             "male"}\NormalTok{, }\StringTok{"female"}\NormalTok{)}
\OperatorTok{>}\StringTok{ }\NormalTok{gender}
\end{Highlighting}
\end{Shaded}

Notice that elements of a vector are separated by commas when using the \texttt{c()} function to create a vector. Also notice that character values are placed inside quotation marks.

The \texttt{c()} function also can be used to add to an existing vector. For example, if an eighth male person was included in the data set, and his weight was 194 pounds, the existing vectors could be modified as follows.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{>}\StringTok{ }\NormalTok{weight <-}\StringTok{ }\KeywordTok{c}\NormalTok{(weight, }\DecValTok{194}\NormalTok{)}
\OperatorTok{>}\StringTok{ }\NormalTok{gender <-}\StringTok{ }\KeywordTok{c}\NormalTok{(gender, }\StringTok{"male"}\NormalTok{)}
\OperatorTok{>}\StringTok{ }\NormalTok{weight}
\OperatorTok{>}\StringTok{ }\NormalTok{gender}
\end{Highlighting}
\end{Shaded}

\hypertarget{types-conversion-coercion}{%
\subsection{Types, Conversion, Coercion}\label{types-conversion-coercion}}

Clearly it is important to distinguish between different types of vectors. For example, it makes sense to ask R to calculate the mean of the weights stored in \texttt{weight}, but does not make sense to ask R to compute the mean of the genders stored in \texttt{gender}. Vectors in R may have one of six different ``types'': character, double, integer, logical, complex, and raw. Only the first four of these will be of interest below, and the distinction between double and integer will not be of great import. To illustrate logical vectors, imagine that each of the eight people in the data set was asked whether he or she was taking blood pressure medication, and the responses were coded as \texttt{TRUE} if the person answered yes, and \texttt{FALSE} if the person answered no.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{>}\StringTok{ }\KeywordTok{typeof}\NormalTok{(weight)}
\OperatorTok{>}\StringTok{ }\KeywordTok{typeof}\NormalTok{(gender)}
\OperatorTok{>}\StringTok{ }\NormalTok{bp <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\OtherTok{FALSE}\NormalTok{, }\OtherTok{TRUE}\NormalTok{, }\OtherTok{FALSE}\NormalTok{, }\OtherTok{FALSE}\NormalTok{, }\OtherTok{TRUE}\NormalTok{, }\OtherTok{FALSE}\NormalTok{, }\OtherTok{TRUE}\NormalTok{, }\OtherTok{FALSE}\NormalTok{)}
\OperatorTok{>}\StringTok{ }\NormalTok{bp}
\OperatorTok{>}\StringTok{ }\KeywordTok{typeof}\NormalTok{(bp)}
\end{Highlighting}
\end{Shaded}

It may be surprising to see that the variable \texttt{weight} is of \texttt{double} type, even though its values all are integers. By default R creates a double type vector when numeric values are given via the \texttt{+c()} function.

When it makes sense, it is possible to convert vectors to a different type. Consider the following examples.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{>}\StringTok{ }\NormalTok{weight.int <-}\StringTok{ }\KeywordTok{as.integer}\NormalTok{(weight)}
\OperatorTok{>}\StringTok{ }\NormalTok{weight.int}
\OperatorTok{>}\StringTok{ }\KeywordTok{typeof}\NormalTok{(weight.int)}
\OperatorTok{>}\StringTok{ }\NormalTok{weight.char <-}\StringTok{ }\KeywordTok{as.character}\NormalTok{(weight)}
\OperatorTok{>}\StringTok{ }\NormalTok{weight.char}
\OperatorTok{>}\StringTok{ }\NormalTok{bp.double <-}\StringTok{ }\KeywordTok{as.double}\NormalTok{(bp)}
\OperatorTok{>}\StringTok{ }\NormalTok{bp.double}
\OperatorTok{>}\StringTok{ }\NormalTok{gender.oops <-}\StringTok{ }\KeywordTok{as.double}\NormalTok{(gender)}
\OperatorTok{>}\StringTok{ }\NormalTok{gender.oops}
\OperatorTok{>}\StringTok{ }\KeywordTok{sum}\NormalTok{(bp)}
\end{Highlighting}
\end{Shaded}

The integer version of \texttt{weight} doesn't look any different, but it is stored differently, which can be important both for computational efficiency and for interfacing with other languages such as \texttt{C++}. As noted above, however, we will not worry about the distinction between integer and double types. Converting \texttt{weight} to character goes as expected: The character representations of the numbers replace the numbers themselves. Converting the logical vector \texttt{bp} to double is pretty straightforward too: \texttt{FALSE} is converted to zero, and \texttt{TRUE} is converted to one. Now think about converting the character vector \texttt{gender} to a numeric double vector. It's not at all clear how to represent ``female'' and ``male'' as numbers. In fact in this case what R does is to create a character vector, but with each element set to \texttt{NA}, which is the representation of missing data.\footnote{Missing data will be discussed in more detail later in the chapter.} Finally consider the code \texttt{sum(bp)}. Now \texttt{bp} is a logical vector, but when R sees that we are asking to sum this logical vector, it automatically converts it to a numerical vector and then adds the zeros and ones representing \texttt{FALSE} and \texttt{TRUE}.

R also has functions to test whether a vector is of a particular type.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{>}\StringTok{ }\KeywordTok{is.double}\NormalTok{(weight)}
\OperatorTok{>}\StringTok{ }\KeywordTok{is.character}\NormalTok{(weight)}
\OperatorTok{>}\StringTok{ }\KeywordTok{is.integer}\NormalTok{(weight.int)}
\OperatorTok{>}\StringTok{ }\KeywordTok{is.logical}\NormalTok{(bp)}
\end{Highlighting}
\end{Shaded}

\hypertarget{coercion}{%
\subsubsection{Coercion}\label{coercion}}

Consider the following examples.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{>}\StringTok{ }\NormalTok{xx <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{, }\OtherTok{TRUE}\NormalTok{)}
\OperatorTok{>}\StringTok{ }\NormalTok{xx}
\OperatorTok{>}\StringTok{ }\NormalTok{yy <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{, }\StringTok{"dog"}\NormalTok{)}
\OperatorTok{>}\StringTok{ }\NormalTok{yy}
\OperatorTok{>}\StringTok{ }\NormalTok{zz <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\OtherTok{TRUE}\NormalTok{, }\OtherTok{FALSE}\NormalTok{, }\StringTok{"cat"}\NormalTok{)}
\OperatorTok{>}\StringTok{ }\NormalTok{zz}
\OperatorTok{>}\StringTok{ }\NormalTok{weight }\OperatorTok{+}\StringTok{ }\NormalTok{bp}
\end{Highlighting}
\end{Shaded}

Vectors in R can only contain elements of one type. If more than one type is included in a \texttt{c()} function, R silently \emph{coerces} the vector to be of one type. The examples illustrate the hierarchy---if any element is a character, then the whole vector is character. If some elements are numeric (either integer or double) and other elements are logical, the whole vector is numeric. Note what happened when R was asked to add the numeric vector \texttt{weight} to the logical vector \texttt{bp}. The logical vector was silently coerced to be numeric, so that FALSE became zero and TRUE became one, and then the two numeric vectors were added.

\hypertarget{accessing-specific-elements-of-vectors}{%
\subsection{Accessing Specific Elements of Vectors}\label{accessing-specific-elements-of-vectors}}

To access and possibly change specific elements of vectors, refer to the position of the element in square brackets. For example, \texttt{weight{[}4{]}} refers to the fourth element of the vector \texttt{weight}. Note that R starts the numbering of elements at 1, i.e., the first element of a vector \texttt{x} is \texttt{x{[}1{]}}.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{>}\StringTok{ }\NormalTok{weight}
\OperatorTok{>}\StringTok{ }\NormalTok{weight[}\DecValTok{5}\NormalTok{]}
\OperatorTok{>}\StringTok{ }\NormalTok{weight[}\DecValTok{1}\OperatorTok{:}\DecValTok{3}\NormalTok{]}
\OperatorTok{>}\StringTok{ }\KeywordTok{length}\NormalTok{(weight)}
\OperatorTok{>}\StringTok{ }\NormalTok{weight[}\KeywordTok{length}\NormalTok{(weight)]}
\OperatorTok{>}\StringTok{ }\NormalTok{weight[]}
\OperatorTok{>}\StringTok{ }\NormalTok{weight[}\DecValTok{3}\NormalTok{] <-}\StringTok{ }\DecValTok{202}
\OperatorTok{>}\StringTok{ }\NormalTok{weight}
\end{Highlighting}
\end{Shaded}

Note that including nothing in the square brackets results in the whole vector being returned.

Negative numbers in the square brackets tell R to omit the corresponding value. And a zero as a subscript returns nothing (more precisely, it returns a length zero vector of the appropriate type).

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{>}\StringTok{ }\NormalTok{weight[}\OperatorTok{-}\DecValTok{3}\NormalTok{]}
\OperatorTok{>}\StringTok{ }\NormalTok{weight[}\OperatorTok{-}\KeywordTok{length}\NormalTok{(weight)]}
\OperatorTok{>}\StringTok{ }\NormalTok{lessWeight <-}\StringTok{ }\NormalTok{weight[}\OperatorTok{-}\KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{5}\NormalTok{)]}
\OperatorTok{>}\StringTok{ }\NormalTok{lessWeight}
\OperatorTok{>}\StringTok{ }\NormalTok{weight[}\DecValTok{0}\NormalTok{]}
\OperatorTok{>}\StringTok{ }\NormalTok{weight[}\KeywordTok{c}\NormalTok{(}\DecValTok{0}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{1}\NormalTok{)]}
\OperatorTok{>}\StringTok{ }\NormalTok{weight[}\KeywordTok{c}\NormalTok{(}\OperatorTok{-}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{)]}
\end{Highlighting}
\end{Shaded}

Note that mixing zero and other nonzero subscripts is allowed, but mixing negative and positive subscripts is not allowed.

What about the (usual) case where we don't know the positions of the elements we want? For example possibly we want the weights of all females in the data. Later we will learn how to subset using logical indices, which is a very powerful way to access desired elements of a vector.

\hypertarget{factors}{%
\section{Factors}\label{factors}}

Categorical variables such as \texttt{gender} can be represented as character vectors. In many cases this simple representation is sufficient. Consider, however, two other categorical variables, one representing age via categories \texttt{youth}, \texttt{young\ adult}, \texttt{middle\ age}, \texttt{senior}, and another representing income via categories \texttt{lower}, \texttt{middle}, and \texttt{upper}. Suppose that for the small health data set, all the people are either middle aged or senior citizens. If we just represented the variable via a character vector, there would be no way to know that there are two other categories, representing youth and senior citizens, which happen not to be present in the data set. And for the income variable, the character vector representation does not explicitly indicate that there is an ordering of the levels.

Factors in R provide a more sophisticated way to represent categorical variables. Factors explicitly contain all possible levels, and allow ordering of levels.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{>}\StringTok{ }\NormalTok{age <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"middle age"}\NormalTok{, }\StringTok{"senior"}\NormalTok{, }\StringTok{"middle age"}\NormalTok{, }\StringTok{"senior"}\NormalTok{, }
\OperatorTok{+}\StringTok{          "senior"}\NormalTok{, }\StringTok{"senior"}\NormalTok{, }\StringTok{"senior"}\NormalTok{, }\StringTok{"middle age"}\NormalTok{)}
\OperatorTok{>}\StringTok{ }\NormalTok{income <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"lower"}\NormalTok{, }\StringTok{"lower"}\NormalTok{, }\StringTok{"upper"}\NormalTok{, }\StringTok{"middle"}\NormalTok{, }\StringTok{"upper"}\NormalTok{, }
\OperatorTok{+}\StringTok{             "lower"}\NormalTok{, }\StringTok{"lower"}\NormalTok{, }\StringTok{"middle"}\NormalTok{)}
\OperatorTok{>}\StringTok{ }\NormalTok{age}
\OperatorTok{>}\StringTok{ }\NormalTok{income}
\OperatorTok{>}\StringTok{ }\NormalTok{age <-}\StringTok{ }\KeywordTok{factor}\NormalTok{(age, }\DataTypeTok{levels=}\KeywordTok{c}\NormalTok{(}\StringTok{"youth"}\NormalTok{, }\StringTok{"young adult"}\NormalTok{, }\StringTok{"middle age"}\NormalTok{, }
\OperatorTok{+}\StringTok{                             "senior"}\NormalTok{))}
\OperatorTok{>}\StringTok{ }\NormalTok{age}
\OperatorTok{>}\StringTok{ }\NormalTok{income <-}\StringTok{ }\KeywordTok{factor}\NormalTok{(income, }\DataTypeTok{levels=}\KeywordTok{c}\NormalTok{(}\StringTok{"lower"}\NormalTok{, }\StringTok{"middle"}\NormalTok{, }\StringTok{"upper"}\NormalTok{), }
\OperatorTok{+}\StringTok{                  }\DataTypeTok{ordered =} \OtherTok{TRUE}\NormalTok{)}
\OperatorTok{>}\StringTok{ }\NormalTok{income}
\end{Highlighting}
\end{Shaded}

In the factor version of \texttt{age} the levels are explicitly listed, so it is clear that the two included levels are not all the possible levels. And in the factor version of income, the ordering is explicit.

In many cases the character vector representation of a categorical variable is sufficient and easier to work with. In this book, factors will not be used extensively. It is important to note that R often by default creates a factor when character data are read in, and sometimes it is necessary to use the argument \texttt{stringsAsFactors\ =\ FALSE} to explicitly tell R not to do this. This is shown later in the chapter when data frames are introduced.

\hypertarget{names-of-objects-in-r}{%
\section{Names of Objects in R}\label{names-of-objects-in-r}}

There are few hard and fast restrictions on the names of objects (such as vectors) in R. In addition to these restrictions, there are certain good practices, and many things to avoid as well.

From the help page for \texttt{make.names} in R, the name of an R object is ``syntactically valid'' if the name ``consists of letters, numbers and the dot or underline characters and starts with a letter or the dot not followed by a number'' and is not one of the ``reserved words'' in R such as \texttt{if}, \texttt{TRUE}, \texttt{function}, etc. For example, \texttt{c45t.le\_dog} and \texttt{.ty56} are both syntactically valid (although not very good names) while \texttt{4cats} and \texttt{log\#@gopher} are not.

A few important comments about naming objects follow:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  It is important to be aware that names of objects in R are case-sensitive, so \texttt{weight} and \texttt{Weight} do not refer to the same object.
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{>}\StringTok{ }\NormalTok{weight}
\OperatorTok{>}\StringTok{ }\NormalTok{Weight}
\end{Highlighting}
\end{Shaded}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{1}
\tightlist
\item
  It is unwise to create an object with the same name as a built in R object such as the function \texttt{c} or the function \texttt{mean}. In earlier versions of R this could be somewhat disastrous, but even in current versions, it is definitely not a good idea!
\item
  As much as possible, choose names that are informative. When creating a variable you may initially remember that \texttt{x} contains heights and \texttt{y} contains genders, but after a few hours, a few days, or a few weeks, you probably will forget this. Better options are \texttt{Height} and \texttt{Gender}.
\item
  As much as possible, be consistent in how you name objects. In particular, decide how to separate multi-word names. Some options include:

  \begin{itemize}
  \tightlist
  \item
    Using case to separate: \texttt{BloodPressure} or \texttt{bloodPressure} for example
  \item
    Using underscores to separate: \texttt{blood\_pressure} for example
  \item
    Using a period to separate: \texttt{blood.pressure} for example
  \end{itemize}
\end{enumerate}

\hypertarget{missing-data-infinity-etc.}{%
\section{Missing Data, Infinity, etc.}\label{missing-data-infinity-etc.}}

Most real-world data sets have variables where some observations are missing. In a longitudinal study participants may drop out. In a survey, participants may decide not to respond to certain questions. Statistical software should be able to represent missing data and to analyze data sets in which some data are missing.

In R, the value \texttt{NA} is used for a missing data value. Since missing values may occur in numeric, character, and other types of data, and since R requires that a vector contain only elements of one type, there are different types of \texttt{NA} values. Usually R determines the appropriate type of \texttt{NA} value automatically. It is worth noting that the default type for \texttt{NA} is logical, and that \texttt{NA} is NOT the same as the character string \texttt{"NA"}.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{>}\StringTok{ }\NormalTok{missingCharacter <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"dog"}\NormalTok{, }\StringTok{"cat"}\NormalTok{, }\OtherTok{NA}\NormalTok{, }\StringTok{"pig"}\NormalTok{, }\OtherTok{NA}\NormalTok{, }\StringTok{"horse"}\NormalTok{)}
\OperatorTok{>}\StringTok{ }\NormalTok{missingCharacter}
\OperatorTok{>}\StringTok{ }\KeywordTok{is.na}\NormalTok{(missingCharacter)}
\OperatorTok{>}\StringTok{ }\NormalTok{missingCharacter <-}\StringTok{ }\KeywordTok{c}\NormalTok{(missingCharacter, }\StringTok{"NA"}\NormalTok{)}
\OperatorTok{>}\StringTok{ }\NormalTok{missingCharacter}
\OperatorTok{>}\StringTok{ }\KeywordTok{is.na}\NormalTok{(missingCharacter)}
\OperatorTok{>}\StringTok{ }\NormalTok{allMissing <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\OtherTok{NA}\NormalTok{, }\OtherTok{NA}\NormalTok{, }\OtherTok{NA}\NormalTok{)}
\OperatorTok{>}\StringTok{ }\KeywordTok{typeof}\NormalTok{(allMissing)}
\end{Highlighting}
\end{Shaded}

How should missing data be treated in computations, such as finding the mean or standard deviation of a variable? One possibility is to return \texttt{NA}. Another is to remove the missing value(s) and then perform the computation.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{>}\StringTok{ }\KeywordTok{mean}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{, }\OtherTok{NA}\NormalTok{, }\DecValTok{5}\NormalTok{))}
\OperatorTok{>}\StringTok{ }\KeywordTok{mean}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{, }\OtherTok{NA}\NormalTok{, }\DecValTok{5}\NormalTok{), }\DataTypeTok{na.rm =} \OtherTok{TRUE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

As this example shows, the default behavior for the \texttt{mean()} function is to return \texttt{NA}. If removal of the missing values and then computing the mean is desired, the argument \texttt{na.rm} is set to \texttt{TRUE}. Different R functions have different default behaviors, and there are other possible actions. Consulting the help for a function provides the details.

\hypertarget{infinity-and-nan}{%
\subsection{Infinity and NaN}\label{infinity-and-nan}}

What happens if R code requests division by zero, or results in a number that is too large to be represented? Here are some examples.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{>}\StringTok{ }\NormalTok{x <-}\StringTok{ }\DecValTok{0}\OperatorTok{:}\DecValTok{4}
\OperatorTok{>}\StringTok{ }\NormalTok{x}
\OperatorTok{>}\StringTok{ }\DecValTok{1}\OperatorTok{/}\NormalTok{x}
\OperatorTok{>}\StringTok{ }\NormalTok{x}\OperatorTok{/}\NormalTok{x}
\OperatorTok{>}\StringTok{ }\NormalTok{y <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\DecValTok{10}\NormalTok{, }\DecValTok{1000}\NormalTok{, }\DecValTok{10000}\NormalTok{)}
\OperatorTok{>}\StringTok{ }\DecValTok{2}\OperatorTok{^}\NormalTok{y}
\end{Highlighting}
\end{Shaded}

\texttt{Inf} and \texttt{-Inf} represent infinity and negative infinity (and numbers which are too large in magnitude to be represented as floating point numbers). \texttt{NaN} represents the result of a calculation where the result is undefined, such as dividing zero by zero. All of these are common to a variety of programming languages, including R.

\hypertarget{dataFrames}{%
\section{Data Frames}\label{dataFrames}}

Commonly, data is rectangular in form, with variables as columns and cases as rows. Continuing with the (contrived) data on weight, gender, and blood pressure medication, each of those variables would be a column of the data set, and each person's measurements would be a row. In R, such data are represented as a \emph{data frame}.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{>}\StringTok{ }\NormalTok{healthData <-}\StringTok{ }\KeywordTok{data.frame}\NormalTok{(}\DataTypeTok{Weight =}\NormalTok{ weight, }\DataTypeTok{Gender=}\NormalTok{gender, }\DataTypeTok{bp.meds =}\NormalTok{ bp,}
\OperatorTok{+}\StringTok{                          }\DataTypeTok{stringsAsFactors=}\OtherTok{FALSE}\NormalTok{)}
\OperatorTok{>}\StringTok{ }\NormalTok{healthData}
\OperatorTok{>}\StringTok{ }\KeywordTok{names}\NormalTok{(healthData)}
\OperatorTok{>}\StringTok{ }\KeywordTok{colnames}\NormalTok{(healthData)}
\OperatorTok{>}\StringTok{ }\KeywordTok{names}\NormalTok{(healthData) <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"Wt"}\NormalTok{, }\StringTok{"Gdr"}\NormalTok{, }\StringTok{"bp"}\NormalTok{)}
\OperatorTok{>}\StringTok{ }\NormalTok{healthData}
\OperatorTok{>}\StringTok{ }\KeywordTok{rownames}\NormalTok{(healthData)}
\OperatorTok{>}\StringTok{ }\KeywordTok{names}\NormalTok{(healthData) <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"Weight"}\NormalTok{, }\StringTok{"Gender"}\NormalTok{, }\StringTok{"bp.meds"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

The \texttt{data.frame} function can be used to create a data frame (although it's more common to read a data frame into R from an external file, something that will be introduced later). The names of the variables in the data frame are given as arguments, as are the vectors of data that make up the variable's values. The argument \texttt{stringsAsFactors=FALSE} asks R not to convert character vectors into factors, which R does by default, to the dismay of many users. Names of the columns (variables) can be extracted and set via either \texttt{names} or \texttt{colnames}. In the example, the variable names are changed to \texttt{Wt,\ Gdr,\ bp} and then changed back to the original \texttt{Weight,\ Gender,\ bp.meds} in this way. Rows can be named also. In this case since specific row names were not provided, the default row names of \texttt{"1",\ "2"} etc. are used.

In the next example a built-in dataset called \texttt{mtcars} is made available by the \texttt{data} function, and then the first and last six rows are displayed using \texttt{head} and \texttt{tail}.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{>}\StringTok{ }\KeywordTok{data}\NormalTok{(mtcars)}
\OperatorTok{>}\StringTok{ }\KeywordTok{head}\NormalTok{(mtcars)}
\OperatorTok{>}\StringTok{ }\KeywordTok{tail}\NormalTok{(mtcars)}
\end{Highlighting}
\end{Shaded}

Note that the \texttt{mtcars} data frame does have non-default row names which give the make and model of the cars.

\hypertarget{accessing-specific-elements-of-data-frames}{%
\subsection{Accessing Specific Elements of Data Frames}\label{accessing-specific-elements-of-data-frames}}

Data frames are two-dimensional, so to access a specific element (or elements) we need to specify both the row and column.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{>}\StringTok{ }\NormalTok{mtcars[}\DecValTok{1}\NormalTok{, }\DecValTok{4}\NormalTok{]}
\OperatorTok{>}\StringTok{ }\NormalTok{mtcars[}\DecValTok{1}\OperatorTok{:}\DecValTok{3}\NormalTok{, }\DecValTok{3}\NormalTok{]}
\OperatorTok{>}\StringTok{ }\NormalTok{mtcars[}\DecValTok{1}\OperatorTok{:}\DecValTok{3}\NormalTok{, }\DecValTok{2}\OperatorTok{:}\DecValTok{3}\NormalTok{]}
\OperatorTok{>}\StringTok{ }\NormalTok{mtcars[, }\DecValTok{1}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

Note that \texttt{mtcars{[},1{]}} returns ALL elements in the first column. This agrees with the behavior for vectors, where leaving a subscript out of the square brackets tells R to return all values. In this case we are telling R to return all rows, and the first column.

For a data frame there is another way to access specific columns, using the \texttt{\$} notation.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{>}\StringTok{ }\NormalTok{mtcars}\OperatorTok{$}\NormalTok{mpg}
\OperatorTok{>}\StringTok{ }\NormalTok{mtcars}\OperatorTok{$}\NormalTok{cyl}
\OperatorTok{>}\StringTok{ }\NormalTok{mpg}
\OperatorTok{>}\StringTok{ }\NormalTok{cyl}
\OperatorTok{>}\StringTok{ }\NormalTok{weight}
\end{Highlighting}
\end{Shaded}

Notice that typing the variable name, such as \texttt{mpg}, without the name of the data frame (and a dollar sign) as a prefix, does not work. This is sensible. There may be several data frames that have variables named \texttt{mpg}, and just typing \texttt{mpg} doesn't provide enough information to know which is desired. But if there is a vector named \texttt{mpg} that is created outside a data frame, it will be retrieved when \texttt{mpg} is typed, which is why typing \texttt{weight} does work, since \texttt{weight} was created outside of a data frame, although ultimately it was incorporated into the \texttt{healthData} data frame.

\hypertarget{lists}{%
\section{Lists}\label{lists}}

The third main data structure we will work with is a list. Technically a list is a vector, but one in which elements can be of different types. For example a list may have one element that is a vector, one element that is a data frame, and another element that is a function. Consider designing a function that fits a simple linear regression model to two quantitative variables. We might want that function to compute and return several things such as

\begin{itemize}
\tightlist
\item
  The fitted slope and intercept (a numeric vector with two components)
\item
  The residuals (a numeric vector with \(n\) components, where \(n\) is the number of data points)
\item
  Fitted values for the data (a numeric vector with \(n\) components, where \(n\) is the number of data points)
\item
  The names of the dependent and independent variables (a character vector with two components)
\end{itemize}

In fact R has a function, \texttt{lm}, which does this (and much more).

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{>}\StringTok{ }\NormalTok{mpgHpLinMod <-}\StringTok{ }\KeywordTok{lm}\NormalTok{(mpg }\OperatorTok{~}\StringTok{ }\NormalTok{hp, }\DataTypeTok{data =}\NormalTok{ mtcars)}
\OperatorTok{>}\StringTok{ }\KeywordTok{mode}\NormalTok{(mpgHpLinMod)}
\OperatorTok{>}\StringTok{ }\KeywordTok{names}\NormalTok{(mpgHpLinMod)}
\OperatorTok{>}\StringTok{ }\NormalTok{mpgHpLinMod}\OperatorTok{$}\NormalTok{coefficients}
\OperatorTok{>}\StringTok{ }\NormalTok{mpgHpLinMod}\OperatorTok{$}\NormalTok{residuals}
\end{Highlighting}
\end{Shaded}

The \texttt{lm} function returns a list (which in the code above has been assigned to the object \texttt{mpgHpLinMod}).\footnote{The \texttt{mode} function returns the type or storage mode of an object.} One component of the list is the length \texttt{length(mpgHpLinMod\$coefficients)} vector of coefficients, while another component is the length \texttt{length(mpgHpLinMod\$residuals)} vector of residuals. The code also illustrates that named components of a list can be accessed using the dollar sign notation, as with data frames.

The \texttt{list} function is used to create lists.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{>}\StringTok{ }\NormalTok{temporaryList <-}\StringTok{ }\KeywordTok{list}\NormalTok{(}\DataTypeTok{first=}\NormalTok{weight, }\DataTypeTok{second=}\NormalTok{healthData,}
\OperatorTok{+}\StringTok{                       }\DataTypeTok{pickle=}\KeywordTok{list}\NormalTok{(}\DataTypeTok{a =} \DecValTok{1}\OperatorTok{:}\DecValTok{10}\NormalTok{, }\DataTypeTok{b=}\NormalTok{healthData))}
\OperatorTok{>}\StringTok{ }\NormalTok{temporaryList}
\end{Highlighting}
\end{Shaded}

Here, for illustration, I assembled a list to hold some of the R data structures we have been working with in this chapter. The first list element, named \texttt{first}, holds the \texttt{weight} vector we created in Section \ref{vector}, the second list element, named \texttt{second}, holds the \texttt{healthData} data frame, and the third list element, named \texttt{pickle}, holds a list with elements named \texttt{a} and \texttt{b} that hold a vector of values 1 through 10 and another copy of the \texttt{healthData} data frame, respectively. As this example shows, a list can contain another list.

\hypertarget{accessing-specific-elements-of-lists}{%
\subsection{Accessing Specific Elements of Lists}\label{accessing-specific-elements-of-lists}}

We already have seen the dollar sign notation works for lists. In addition, the square bracket subsetting notation can be used. There is an added, somewhat subtle wrinkle---using either single or double square brackets.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{>}\StringTok{ }\NormalTok{temporaryList}\OperatorTok{$}\NormalTok{first}
\OperatorTok{>}\StringTok{ }\KeywordTok{mode}\NormalTok{(temporaryList}\OperatorTok{$}\NormalTok{first)}
\OperatorTok{>}\StringTok{ }\NormalTok{temporaryList[[}\DecValTok{1}\NormalTok{]]}
\OperatorTok{>}\StringTok{ }\KeywordTok{mode}\NormalTok{(temporaryList[[}\DecValTok{1}\NormalTok{]])}
\OperatorTok{>}\StringTok{ }\NormalTok{temporaryList[}\DecValTok{1}\NormalTok{]}
\OperatorTok{>}\StringTok{ }\KeywordTok{mode}\NormalTok{(temporaryList[}\DecValTok{1}\NormalTok{])}
\end{Highlighting}
\end{Shaded}

Note the dollar sign and double bracket notation return a numeric vector, while the single bracket notation returns a list. Notice also the difference in results below.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{>}\StringTok{ }\NormalTok{temporaryList[}\KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{)]}
\OperatorTok{>}\StringTok{ }\NormalTok{temporaryList[[}\KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{)]]}
\end{Highlighting}
\end{Shaded}

The single bracket form returns the first and second elements of the list, while the double bracket form returns the second element in the first element of the list. Generally, do not put a vector of indices or names in a double bracket, you will likely get unexpected results. See, for example, the results below.\footnote{Try this example using only single brackets\(\ldots\) it will return a list holding elements \texttt{first}, \texttt{second}, and \texttt{pickle}.}

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{>}\StringTok{ }\NormalTok{temporaryList[[}\KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{)]]}
\end{Highlighting}
\end{Shaded}

So, in summary, there are two main differences between using the single bracket \texttt{{[}{]}} and double bracket \texttt{{[}{[}{]}{]}}. First, the single bracket will return a list that holds the object(s) held at the given indices or names placed in the bracket, whereas the double brackets will return the actual object held at the index or name placed in the innermost bracket. Put differently, a single bracket can be used to access a range of list elements and will return a list, and a double bracket can only access a single element in the list and will return the object held at the index.

\hypertarget{subsetting}{%
\section{Subsetting with Logical Vectors}\label{subsetting}}

Consider the \texttt{healthData} data frame. How can we access only those weights which are more than 200? How can we access the genders of those whose weights are more than 200? How can we compute the mean weight of males and the mean weight of females? Or consider the \texttt{mtcars} data frame. How can we obtain the miles per gallon for all six cylinder cars? Both of these data sets are small enough that it would not be too onerous to extract the values by hand. But for larger or more complex data sets, this would be very difficult or impossible to do in a reasonable amount of time, and would likely result in errors.

R has a powerful method for solving these sorts of problems using a variant of the subsetting methods that we already have learned. When given a logical vector in square brackets, R will return the values corresponding to \texttt{TRUE}.
To begin, focus on the \texttt{weight} and \texttt{gender} vectors created in Section \ref{vector}.

The R code \texttt{weight\ \textgreater{}\ 200} returns a \texttt{TRUE} for each value of \texttt{weight} which is more than 200, and a \texttt{FALSE} for each value of \texttt{weight} which is less than or equal to 200. Similarly \texttt{gender\ ==\ "female"} returns \texttt{TRUE} or \texttt{FALSE} depending on whether an element of \texttt{gender} is equal to \texttt{female}.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{>}\StringTok{ }\NormalTok{weight}
\OperatorTok{>}\StringTok{ }\NormalTok{weight }\OperatorTok{>}\StringTok{ }\DecValTok{200}
\OperatorTok{>}\StringTok{ }\NormalTok{gender[weight }\OperatorTok{>}\StringTok{ }\DecValTok{200}\NormalTok{]}
\OperatorTok{>}\StringTok{ }\NormalTok{weight[weight }\OperatorTok{>}\StringTok{ }\DecValTok{200}\NormalTok{]}
\OperatorTok{>}\StringTok{ }\NormalTok{gender }\OperatorTok{==}\StringTok{ "female"}
\OperatorTok{>}\StringTok{ }\NormalTok{weight[gender }\OperatorTok{==}\StringTok{ "female"}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

Consider the lines of R code one by one.

\begin{itemize}
\tightlist
\item
  \texttt{weight} instructs R to display the values in the vector \texttt{weight}.
\item
  \texttt{weight\ \textgreater{}\ 200} instructs R to check whether each value in \texttt{weight} is greater than 200, and to return \texttt{TRUE} if so, and \texttt{FALSE} otherwise.
  +The next line, \texttt{gender{[}weight\ \textgreater{}\ 200{]}}, does two things. First, inside the square brackets, it does the same thing as the second line, namely, returning \texttt{TRUE} or \texttt{FALSE} depending on whether a value of \texttt{weight} is or is not greater than 200. Second, each element of \texttt{gender} is matched with the corresponding \texttt{TRUE} or \texttt{FALSE} value, and is returned if and only if the corresponding value is \texttt{TRUE}. For example the first value of \texttt{gender} is \texttt{gender{[}1{]}}. Since the first \texttt{TRUE} or \texttt{FALSE} value is \texttt{FALSE}, the first value of \texttt{gender} is not returned. Only the third and fifth values of \texttt{gender}, both of which happen to be \texttt{male}, are returned. Briefly, this line returns the genders of those people whose weight is over 200 pounds.
\item
  The fourth line of code, \texttt{weight{[}weight\ \textgreater{}\ 200{]}}, again begins by returning \texttt{TRUE} or \texttt{FALSE} depending on whether elements of \texttt{weight} are larger than 200. Then those elements of \texttt{weight} corresponding to \texttt{TRUE} values, are returned. So this line returns the weights of those people whose weights are more than 200 pounds.
\item
  The fifth line returns \texttt{TRUE} or \texttt{FALSE} depending on whether elements of \texttt{gender} are equal to \texttt{female} or not.
\item
  The sixth line returns the weights of those whose gender is \texttt{female}.
\end{itemize}

There are six comparison operators in R, \texttt{\textgreater{},\ \textless{},\ \textgreater{}=,\ \textless{}=,\ ==,\ !=}. Note that to test for equality a ``double equals sign'' is used, while \texttt{!=} tests for inequality.

\hypertarget{modifying-or-creating-objects-via-subsetting}{%
\subsection{Modifying or Creating Objects via Subsetting}\label{modifying-or-creating-objects-via-subsetting}}

The results of subsetting can be assigned to a new (or existing) R object, and subsetting on the left side of an assignment is a common way to modify an existing R object.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{>}\StringTok{ }\NormalTok{weight}
\OperatorTok{>}\StringTok{ }\NormalTok{lightweight <-}\StringTok{ }\NormalTok{weight[weight }\OperatorTok{<}\StringTok{ }\DecValTok{200}\NormalTok{]}
\OperatorTok{>}\StringTok{ }\NormalTok{lightweight}
\OperatorTok{>}\StringTok{ }\NormalTok{x <-}\StringTok{ }\DecValTok{1}\OperatorTok{:}\DecValTok{10}
\OperatorTok{>}\StringTok{ }\NormalTok{x}
\OperatorTok{>}\StringTok{ }\NormalTok{x[x }\OperatorTok{<}\StringTok{ }\DecValTok{5}\NormalTok{] <-}\StringTok{ }\DecValTok{0}
\OperatorTok{>}\StringTok{ }\NormalTok{x}
\OperatorTok{>}\StringTok{ }\NormalTok{y <-}\StringTok{ }\DecValTok{-3}\OperatorTok{:}\DecValTok{9}
\OperatorTok{>}\StringTok{ }\NormalTok{y}
\OperatorTok{>}\StringTok{ }\NormalTok{y[y }\OperatorTok{<}\StringTok{ }\DecValTok{0}\NormalTok{] <-}\StringTok{ }\OtherTok{NA}
\OperatorTok{>}\StringTok{ }\NormalTok{y}
\OperatorTok{>}\StringTok{ }\KeywordTok{rm}\NormalTok{(x)}
\OperatorTok{>}\StringTok{ }\KeywordTok{rm}\NormalTok{(y)}
\end{Highlighting}
\end{Shaded}

\hypertarget{logical-subsetting-and-data-frames}{%
\subsection{Logical Subsetting and Data Frames}\label{logical-subsetting-and-data-frames}}

First consider the small and simple \texttt{healthData} data frame.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{>}\StringTok{ }\NormalTok{healthData}
\OperatorTok{>}\StringTok{ }\NormalTok{healthData}\OperatorTok{$}\NormalTok{Weight[healthData}\OperatorTok{$}\NormalTok{Gender }\OperatorTok{==}\StringTok{ "male"}\NormalTok{]}
\OperatorTok{>}\StringTok{ }\NormalTok{healthData[healthData}\OperatorTok{$}\NormalTok{Gender }\OperatorTok{==}\StringTok{ "female"}\NormalTok{, ]}
\OperatorTok{>}\StringTok{ }\NormalTok{healthData[healthData}\OperatorTok{$}\NormalTok{Weight }\OperatorTok{>}\StringTok{ }\DecValTok{190}\NormalTok{, }\DecValTok{2}\OperatorTok{:}\DecValTok{3}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

The first example is really just subsetting a vector, since the \texttt{\$} notation creates vectors. The second two examples return subsets of the whole data frame. Note that the logical vector subsets the rows of the data frame, choosing those rows where the gender is female or the weight is more than 190. Note also that the specification for the columns (after the comma) is left blank in the first case, telling R to return all the columns. In the second case the second and third columns are requested explicitly.

Next consider the much larger and more complex \texttt{WorldBank} data frame. Recall, the \texttt{str} function displays the ``structure'' of an R object. Here is a look at the structure of several R objects.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{>}\StringTok{ }\KeywordTok{str}\NormalTok{(mtcars)}
\OperatorTok{>}\StringTok{ }\KeywordTok{str}\NormalTok{(temporaryList)}
\OperatorTok{>}\StringTok{ }\KeywordTok{str}\NormalTok{(WorldBank)}
\end{Highlighting}
\end{Shaded}

First we see that \texttt{mtcars} is a data frame which has 32 observations (rows) on each of 11 variables (columns). The names of the variables are given, along with their type (in this case, all numeric), and the first few values of each variable is given.

Second we see that \texttt{temporaryList} is a list with three components. Each of the components is described separately, with the first few values again given.

Third we examine the structure of \texttt{WorldBank}. It is a data frame with 11880 observations on each of 15 variables. Some of these are character variables, some are numeric, and one (\texttt{year}) is integer. Looking at the first few values we see that some variables have missing values.

Consider creating a data frame which only has the observations from one year, say 1971. That's relatively easy. Just choose rows for which \texttt{year} is equal to 1971.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{>}\StringTok{ }\NormalTok{WorldBank1971 <-}\StringTok{ }\NormalTok{WorldBank[WorldBank}\OperatorTok{$}\NormalTok{year }\OperatorTok{==}\StringTok{ }\DecValTok{1971}\NormalTok{, ]}
\OperatorTok{>}\StringTok{ }\KeywordTok{dim}\NormalTok{(WorldBank1971)}
\end{Highlighting}
\end{Shaded}

The \texttt{dim} function returns the dimensions of a data frame, i.e., the number of rows and the number of columns. From \texttt{dim} we see that there are \texttt{dim(WorldBank1971){[}1{]}} cases from 1971.

Next, how can we create a data frame which only contains data from 1971, and also only contains cases for which there are no missing values in the fertility rate variable? R has a built in function \texttt{is.na} which returns \texttt{TRUE} if the observation is missing and returns \texttt{FALSE} otherwise. And \texttt{!is.na} returns the negation, i.e., it returns \texttt{FALSE} if the observation is missing and \texttt{TRUE} if the observation is not missing.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{>}\StringTok{ }\NormalTok{WorldBank1971}\OperatorTok{$}\NormalTok{fertility.rate[}\DecValTok{1}\OperatorTok{:}\DecValTok{25}\NormalTok{]}
\OperatorTok{>}\StringTok{ }\OperatorTok{!}\KeywordTok{is.na}\NormalTok{(WorldBank1971}\OperatorTok{$}\NormalTok{fertility.rate[}\DecValTok{1}\OperatorTok{:}\DecValTok{25}\NormalTok{])}
\OperatorTok{>}\StringTok{ }\NormalTok{WorldBank1971 <-}\StringTok{ }\NormalTok{WorldBank1971[}\OperatorTok{!}\KeywordTok{is.na}\NormalTok{(WorldBank1971}\OperatorTok{$}\NormalTok{fertility.rate), }
\OperatorTok{+}\StringTok{   }\NormalTok{]}
\OperatorTok{>}\StringTok{ }\KeywordTok{dim}\NormalTok{(WorldBank1971)}
\end{Highlighting}
\end{Shaded}

From \texttt{dim} we see that there are \texttt{dim(WorldBank1971){[}1{]}} cases from 1971 with non-missing fertility rate data.

Return attention now to the original \texttt{WorldBank} data frame with data not only from 1971. How can we extract only those cases (rows) which have NO missing data? Consider the following simple example:

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{>}\StringTok{ }\NormalTok{temporaryDataFrame <-}\StringTok{ }\KeywordTok{data.frame}\NormalTok{(}\DataTypeTok{V1 =} \KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{4}\NormalTok{, }\OtherTok{NA}\NormalTok{),}
\OperatorTok{+}\StringTok{                                  }\DataTypeTok{V2 =} \KeywordTok{c}\NormalTok{(}\OtherTok{NA}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{4}\NormalTok{, }\DecValTok{5}\NormalTok{, }\OtherTok{NA}\NormalTok{),}
\OperatorTok{+}\StringTok{                                  }\DataTypeTok{V3 =} \KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{7}\NormalTok{))}
\OperatorTok{>}\StringTok{ }\NormalTok{temporaryDataFrame}
\OperatorTok{>}\StringTok{ }\KeywordTok{is.na}\NormalTok{(temporaryDataFrame)}
\OperatorTok{>}\StringTok{ }\KeywordTok{rowSums}\NormalTok{(}\KeywordTok{is.na}\NormalTok{(temporaryDataFrame))}
\end{Highlighting}
\end{Shaded}

First notice that \texttt{is.na} will test each element of a data frame for missingness. Also recall that if R is asked to sum a logical vector, it will first convert the logical vector to numeric and then compute the sum, which effectively counts the number of elements in the logical vector which are \texttt{TRUE}. The \texttt{rowSums} function computes the sum of each row. So \texttt{rowSums(is.na(temporaryDataFrame))} returns a vector with as many elements as there are rows in the data frame. If an element is zero, the corresponding row has no missing values. If an element is greater than zero, the value is the number of variables which are missing in that row. This gives a simple method to return all the cases which have no missing data.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{>}\StringTok{ }\KeywordTok{dim}\NormalTok{(WorldBank)}
\OperatorTok{>}\StringTok{ }\NormalTok{WorldBankComplete <-}\StringTok{ }\NormalTok{WorldBank[}\KeywordTok{rowSums}\NormalTok{(}\KeywordTok{is.na}\NormalTok{(WorldBank)) }\OperatorTok{==}\StringTok{ }
\OperatorTok{+}\StringTok{   }\DecValTok{0}\NormalTok{, ]}
\OperatorTok{>}\StringTok{ }\KeywordTok{dim}\NormalTok{(WorldBankComplete)}
\end{Highlighting}
\end{Shaded}

Out of the \texttt{dim(WorldBankComplete){[}1{]}} rows in the original data frame, only \texttt{dim(WorldBankComplete){[}1{]}} have no missing observations!

\hypertarget{patterned-data}{%
\section{Patterned Data}\label{patterned-data}}

Sometimes it is useful to generate all the integers from 1 through 20, to generate a sequence of 100 points equally spaced between 0 and 1, etc. The R functions \texttt{seq()} and \texttt{rep()} as well as the ``colon operator'' \texttt{:} help to generate such sequences.

The colon operator generates a sequence of values with increments of \(1\) or \(-1\).

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{>}\StringTok{ }\DecValTok{1}\OperatorTok{:}\DecValTok{10}
\OperatorTok{>}\StringTok{ }\DecValTok{-5}\OperatorTok{:}\DecValTok{3}
\OperatorTok{>}\StringTok{ }\DecValTok{10}\OperatorTok{:}\DecValTok{4}
\OperatorTok{>}\StringTok{ }\NormalTok{pi}\OperatorTok{:}\DecValTok{7}
\end{Highlighting}
\end{Shaded}

The \texttt{seq()} function generates either a sequence of pre-specified length or a sequence with pre-specified increments.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{>}\StringTok{ }\KeywordTok{seq}\NormalTok{(}\DataTypeTok{from =} \DecValTok{0}\NormalTok{, }\DataTypeTok{to =} \DecValTok{1}\NormalTok{, }\DataTypeTok{length =} \DecValTok{11}\NormalTok{)}
\OperatorTok{>}\StringTok{ }\KeywordTok{seq}\NormalTok{(}\DataTypeTok{from =} \DecValTok{1}\NormalTok{, }\DataTypeTok{to =} \DecValTok{5}\NormalTok{, }\DataTypeTok{by =} \DecValTok{1}\OperatorTok{/}\DecValTok{3}\NormalTok{)}
\OperatorTok{>}\StringTok{ }\KeywordTok{seq}\NormalTok{(}\DataTypeTok{from =} \DecValTok{3}\NormalTok{, }\DataTypeTok{to =} \DecValTok{-1}\NormalTok{, }\DataTypeTok{length =} \DecValTok{10}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

The \texttt{rep()} function replicates the values in a given vector.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{>}\StringTok{ }\KeywordTok{rep}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{4}\NormalTok{), }\DataTypeTok{length =} \DecValTok{9}\NormalTok{)}
\OperatorTok{>}\StringTok{ }\KeywordTok{rep}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{4}\NormalTok{), }\DataTypeTok{times =} \DecValTok{3}\NormalTok{)}
\OperatorTok{>}\StringTok{ }\KeywordTok{rep}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\StringTok{"a"}\NormalTok{, }\StringTok{"b"}\NormalTok{, }\StringTok{"c"}\NormalTok{), }\DataTypeTok{times =} \KeywordTok{c}\NormalTok{(}\DecValTok{3}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{7}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\hypertarget{practice-exercises-1}{%
\section{Practice Exercises}\label{practice-exercises-1}}

\hypertarget{homework-1}{%
\section{Homework}\label{homework-1}}

\textbf{Exercise 3} Learning objectives: create, subset, and manipulate vector contents and attributes; summarize vector data using R \texttt{table()} and other functions; generate basic graphics using vector data.

\textbf{Exercise 4} Learning objectives: use functions to describe data frame characteristics; summarize and generate basic graphics for variables held in data frames; apply the subset function with logical operators; illustrate \texttt{NA}, \texttt{NaN}, \texttt{Inf}, and other special values occur; recognize the implications of using floating point arithmetic with logical operators.

\textbf{Exercise 5} Learning objectives: practice with lists, data frames, and associated functions; summarize variables held in lists and data frames; work with R's linear regression \texttt{lm()} function output; review logical subsetting of vectors for partitioning and assigning of new values; generate and visualize data from mathematical functions.

\hypertarget{graphics-in-r}{%
\chapter{Graphics in R}\label{graphics-in-r}}

R can be used to create a vast array of graphical representations of data. Creating ``standard'' graphical displays is straightforward, but a main strength of R is the ability to customize graphical displays to create either non-standard graphics or to modify more standard graphical displays to create publication-ready versions.

There are several packages available in R for creating graphics. The two leading packages are the \texttt{graphics} package, which comes with your base installation of R, and the \texttt{ggplot2} package, which must be installed and made available by the user.\footnote{Other graphics packages include \texttt{lattice} and \texttt{grid}} Knowing how to use both the \texttt{graphics} and \texttt{ggplot2} packages is worthwhile. For beginners \texttt{ggplot2} has somewhat simpler syntax, and also produces excellent graphics without much tinkering, so the focus in this book will be on \texttt{ggplot2}.

The \texttt{gg} in \texttt{ggplot2} stands for \emph{Grammar of Graphics}. The package provides a unified and logical way to describe graphical displays such as scatter plots, histograms, bar charts, and many other types of graphics. The grammar describes the mapping from data to the graphical display's aesthetic attributes (color, shape, size) of geometric objects (points, lines, bars). As will become obvious, once this grammar is mastered for a particular type of plot, such as a scatter plot, it is easy to transfer this knowledge to other types of graphics.

Once you work through this chapter, the best place to learn more about \texttt{ggplot2} is from the package's official book \citet{WickhamGgplot2Book} by Hadley Wickham. It is available on-line in digital format from MSU's library. The book goes into much more depth on the theory underlying the grammar and syntax, and has many examples on solving practical graphical problems. In addition to the free on-line version available through MSU, the book's source code is available at \url{https://github.com/hadley/ggplot2-book}.

Another useful resource is the \texttt{ggplot2} extensions guide \texttt{http://www.ggplot2-exts.org}. This site lists packages that extend \texttt{ggplot2}. It's a good place to start if you're trying to do something that seems hard with \texttt{ggplot2}. We'll explore a few of these extension packages toward the end of this chapter.

\hypertarget{scatter-plots}{%
\section{Scatter Plots}\label{scatter-plots}}

Scatter plots are a workhorse of data visualization and provide a good entry point to the \texttt{ggplot2} system. Begin by considering a simple and classic data set sometimes called \emph{Fisher's Iris Data}. These data are available in R.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{>}\StringTok{ }\KeywordTok{data}\NormalTok{(iris)}
\OperatorTok{>}\StringTok{ }\KeywordTok{str}\NormalTok{(iris)}
\end{Highlighting}
\end{Shaded}

The data contain measurements on petal and sepal length and width for \texttt{dim(iris){[}1{]}} iris plants. The plants are from one of three species, and the species information is also included in the data frame. The data are commonly used to test classification methods, where the goal would be to correctly determine the species based on the four length and width measurements. To get a preliminary sense of how this might work, we can draw some scatter plots of length versus width. Recall that \texttt{ggplot2} is not available by default, so we first have to download and install the package.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{>}\StringTok{ }\KeywordTok{install.packages}\NormalTok{(}\StringTok{"ggplot2"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Once this is done the package is installed on the local hard drive, and we can use the \texttt{library} function to make the package available during the current R session.

Next a basic scatter plot is drawn. We'll keep the focus on sepal length and width, but of course similar plots could be drawn using petal length and width. The prompt is not displayed below, since the continuation prompt \texttt{+} can cause confusion.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(ggplot2)}
\KeywordTok{ggplot}\NormalTok{(}\DataTypeTok{data =}\NormalTok{ iris, }\KeywordTok{aes}\NormalTok{(}\DataTypeTok{x =}\NormalTok{ Sepal.Length, }\DataTypeTok{y =}\NormalTok{ Sepal.Width)) }\OperatorTok{+}\StringTok{ }
\StringTok{    }\KeywordTok{geom_point}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

In this case the first argument to the \texttt{ggplot} function is the name of the data frame. Second, the \texttt{aes} (short for aesthetics) function specifies the mapping to the \texttt{x} and \texttt{y} axes. By itself the \texttt{ggplot} function as written doesn't tell R what sort of graphical display is desired. That is done by adding a \texttt{geom} (short for geometry) specification, in this case \texttt{geom\_point}.

Looking at the scatter plot and thinking about the focus of finding a method to classify the species, two thoughts come to mind. First, the plot might be improved by increasing the size of the points. And second, using different colors for the points corresponding to the three species would help.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{ggplot}\NormalTok{(}\DataTypeTok{data =}\NormalTok{ iris, }\KeywordTok{aes}\NormalTok{(}\DataTypeTok{x =}\NormalTok{ Sepal.Length, }\DataTypeTok{y =}\NormalTok{ Sepal.Width)) }\OperatorTok{+}\StringTok{ }
\StringTok{    }\KeywordTok{geom_point}\NormalTok{(}\DataTypeTok{size =} \DecValTok{4}\NormalTok{, }\KeywordTok{aes}\NormalTok{(}\DataTypeTok{color=}\NormalTok{Species))}
\end{Highlighting}
\end{Shaded}

Notice that a legend showing what the colors represent is automatically generated and included in the graphic. Next, the size of the points seems a bit big now, and it might be helpful to use different shapes for the different species.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{ggplot}\NormalTok{(}\DataTypeTok{data =}\NormalTok{ iris, }\KeywordTok{aes}\NormalTok{(}\DataTypeTok{x =}\NormalTok{ Sepal.Length, }\DataTypeTok{y =}\NormalTok{ Sepal.Width)) }\OperatorTok{+}\StringTok{ }
\StringTok{    }\KeywordTok{geom_point}\NormalTok{(}\DataTypeTok{size =} \DecValTok{3}\NormalTok{, }\KeywordTok{aes}\NormalTok{(}\DataTypeTok{color=}\NormalTok{Species, }\DataTypeTok{shape=}\NormalTok{Species))}
\end{Highlighting}
\end{Shaded}

Here we see that the legend automatically changes to include species specific color and shape. The size of the points seems more appropriate.

\hypertarget{structure-of-a-typical-ggplot}{%
\subsection{\texorpdfstring{Structure of a Typical \texttt{ggplot}}{Structure of a Typical ggplot}}\label{structure-of-a-typical-ggplot}}

The examples above start with the function \texttt{ggplot()}, which takes as arguments the data frame containing the data to be plotted as well as a mapping from the data to the axes, enclosed by the \texttt{aes()} function. Next a \texttt{geom} function, in the above case \texttt{geom\_point()}, is added. It might just specify the geometry, but also might specify aspects such as size, color, or shape.

Typically many graphics are created and discarded in the search for an informative graphic, and often the initial specification of data and basic aesthetics from \texttt{ggplot()} stays the same in all the attempts. In such a case it can be helpful to assign that portion of the graphic to an R object, both to minimize the amount of typing and to keep certain aspects of all the graphics constant. Here's how that could be done for the graphics above.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{iris.p <-}\StringTok{ }\KeywordTok{ggplot}\NormalTok{(}\DataTypeTok{data =}\NormalTok{ iris, }\KeywordTok{aes}\NormalTok{(}\DataTypeTok{x =}\NormalTok{ Sepal.Length, }\DataTypeTok{y =}\NormalTok{ Sepal.Width))}
\NormalTok{iris.p }\OperatorTok{+}\StringTok{ }\KeywordTok{geom_point}\NormalTok{()}
\NormalTok{iris.p }\OperatorTok{+}\StringTok{ }\KeywordTok{geom_point}\NormalTok{(}\DataTypeTok{size =} \DecValTok{3}\NormalTok{, }\KeywordTok{aes}\NormalTok{(}\DataTypeTok{color =}\NormalTok{ Species, }\DataTypeTok{shape =}\NormalTok{ Species))}
\end{Highlighting}
\end{Shaded}

\hypertarget{adding-lines-to-a-scatter-plot}{%
\subsection{Adding lines to a scatter plot}\label{adding-lines-to-a-scatter-plot}}

To add a fitted least squares line to a scatter plot, use \texttt{stat\_smooth}, which adds a smoother (possibly a least squares line, possibly a smooth curve fit to the data, etc.). The argument \texttt{method\ =\ lm} specifies a line fitted by least squares, and the argument \texttt{se\ =\ FALSE} suppresses the default display of a confidence band around the line or curve which was fit to the data.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{ggplot}\NormalTok{(}\DataTypeTok{data =}\NormalTok{ iris, }\KeywordTok{aes}\NormalTok{(}\DataTypeTok{x =}\NormalTok{ Sepal.Length, }\DataTypeTok{y =}\NormalTok{ Sepal.Width)) }\OperatorTok{+}\StringTok{ }
\StringTok{    }\KeywordTok{geom_point}\NormalTok{(}\DataTypeTok{size=}\DecValTok{3}\NormalTok{, }\KeywordTok{aes}\NormalTok{(}\DataTypeTok{color=}\NormalTok{Species))}

\KeywordTok{ggplot}\NormalTok{(}\DataTypeTok{data =}\NormalTok{ iris, }\KeywordTok{aes}\NormalTok{(}\DataTypeTok{x =}\NormalTok{ Sepal.Length, }\DataTypeTok{y =}\NormalTok{ Sepal.Width)) }\OperatorTok{+}\StringTok{ }
\StringTok{    }\KeywordTok{geom_point}\NormalTok{(}\DataTypeTok{size=}\DecValTok{3}\NormalTok{, }\KeywordTok{aes}\NormalTok{(}\DataTypeTok{color=}\NormalTok{Species)) }\OperatorTok{+}\StringTok{ }
\StringTok{    }\KeywordTok{stat_smooth}\NormalTok{(}\DataTypeTok{method =}\NormalTok{ lm, }\DataTypeTok{se=}\OtherTok{FALSE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

For the iris data, it probably makes more sense to fit separate lines by species. This can be specified using the \texttt{aes()} function inside \texttt{stat\_smooth()}.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{ggplot}\NormalTok{(}\DataTypeTok{data =}\NormalTok{ iris, }\KeywordTok{aes}\NormalTok{(}\DataTypeTok{x =}\NormalTok{ Sepal.Length, }\DataTypeTok{y =}\NormalTok{ Sepal.Width)) }\OperatorTok{+}\StringTok{ }
\StringTok{    }\KeywordTok{geom_point}\NormalTok{(}\DataTypeTok{size=}\DecValTok{3}\NormalTok{, }\KeywordTok{aes}\NormalTok{(}\DataTypeTok{color=}\NormalTok{Species)) }\OperatorTok{+}\StringTok{ }
\StringTok{    }\KeywordTok{stat_smooth}\NormalTok{(}\DataTypeTok{method =}\NormalTok{ lm, }\DataTypeTok{se=}\OtherTok{FALSE}\NormalTok{, }\KeywordTok{aes}\NormalTok{(}\DataTypeTok{color=}\NormalTok{Species))}
\end{Highlighting}
\end{Shaded}

In this case we specified the same color aesthetic for the points and the lines. If we know we want this color aesthetic (colors corresponding to species) for all aspects of the graphic, we can specify it in the main \texttt{ggplot()} function:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{ggplot}\NormalTok{(}\DataTypeTok{data =}\NormalTok{ iris, }\KeywordTok{aes}\NormalTok{(}\DataTypeTok{x =}\NormalTok{ Sepal.Length, }\DataTypeTok{y =}\NormalTok{ Sepal.Width, }\DataTypeTok{color =}\NormalTok{ Species)) }\OperatorTok{+}\StringTok{ }
\StringTok{    }\KeywordTok{geom_point}\NormalTok{(}\DataTypeTok{size=}\DecValTok{3}\NormalTok{) }\OperatorTok{+}\StringTok{ }\KeywordTok{stat_smooth}\NormalTok{(}\DataTypeTok{method =}\NormalTok{ lm, }\DataTypeTok{se=}\OtherTok{FALSE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Another common use of line segments in a graphic is to connect the points in order, accomplished via the \texttt{geom\_line()} function. Although it is not clear why this helps in understanding the iris data, the technique is illustrated next, first doing this for all the points in the graphic, and second doing this separately for the three species.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{ggplot}\NormalTok{(}\DataTypeTok{data =}\NormalTok{ iris, }\KeywordTok{aes}\NormalTok{(}\DataTypeTok{x =}\NormalTok{ Sepal.Length, }\DataTypeTok{y =}\NormalTok{ Sepal.Width)) }\OperatorTok{+}\StringTok{ }
\StringTok{    }\KeywordTok{geom_point}\NormalTok{(}\DataTypeTok{size =} \DecValTok{4}\NormalTok{, }\KeywordTok{aes}\NormalTok{(}\DataTypeTok{color=}\NormalTok{Species, }\DataTypeTok{shape =}\NormalTok{ Species)) }\OperatorTok{+}\StringTok{ }
\StringTok{    }\KeywordTok{geom_line}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{ggplot}\NormalTok{(}\DataTypeTok{data =}\NormalTok{ iris, }\KeywordTok{aes}\NormalTok{(}\DataTypeTok{x =}\NormalTok{ Sepal.Length, }\DataTypeTok{y =}\NormalTok{ Sepal.Width)) }\OperatorTok{+}\StringTok{ }
\StringTok{    }\KeywordTok{geom_point}\NormalTok{(}\DataTypeTok{size =} \DecValTok{4}\NormalTok{, }\KeywordTok{aes}\NormalTok{(}\DataTypeTok{color=}\NormalTok{Species)) }\OperatorTok{+}\StringTok{ }
\StringTok{    }\KeywordTok{geom_line}\NormalTok{(}\KeywordTok{aes}\NormalTok{(}\DataTypeTok{color=}\NormalTok{Species))}
\end{Highlighting}
\end{Shaded}

\hypertarget{labels-axes-text-etc.}{%
\section{Labels, Axes, Text, etc.}\label{labels-axes-text-etc.}}

The default settings of \texttt{ggplot2} often produce excellent graphics, but once a graphic is chosen for dissemination, the user will likely want to customize things like the title, axes, etc. In this section some tools for customization are presented. Most will be illustrated in the context of a data set on crime rates in the 50 states in the United States. These data were made available by Nathan Yau at \url{http://flowingdata.com/2010/11/23/how-to-make-bubble-charts/}. The data include crime rates per 100,000 people for various crimes such as murder and robbery, and also include each state's population. The crime rates are from the year 2005, while the population numbers are from the year 2008, but the difference in population between the years is not great, and the exact population is not particularly important for what we'll do below.

First, read in the data, examine its structure, and produce a simple scatter plot of motor vehicle theft versus burglary.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{>}\StringTok{ }\NormalTok{u.crime <-}\StringTok{ "http://blue.for.msu.edu/FOR875/data/crimeRatesByState2005.csv"}
\OperatorTok{>}\StringTok{ }\NormalTok{crime <-}\StringTok{ }\KeywordTok{read.csv}\NormalTok{(u.crime, }\DataTypeTok{header=}\OtherTok{TRUE}\NormalTok{)}
\OperatorTok{>}\StringTok{ }\KeywordTok{str}\NormalTok{(crime)}
\OperatorTok{>}\StringTok{ }\KeywordTok{ggplot}\NormalTok{(data <-}\StringTok{ }\NormalTok{crime, }\KeywordTok{aes}\NormalTok{(}\DataTypeTok{x =}\NormalTok{ burglary, }\DataTypeTok{y =}\NormalTok{ motor_vehicle_theft)) }\OperatorTok{+}\StringTok{ }
\OperatorTok{+}\StringTok{     }\KeywordTok{geom_point}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\hypertarget{labels}{%
\subsection{Labels}\label{labels}}

By default axis and legend labels are the names of the relevant columns in the data frame. While convenient, we often want to customize these labels. Here we use \texttt{labs()} to change the x and y axis labels and other descriptive text.\footnote{Axis and legend labels can also be set in the individual scales, see the subsequent sections.}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{ggplot}\NormalTok{(}\DataTypeTok{data =}\NormalTok{ crime, }\KeywordTok{aes}\NormalTok{(}\DataTypeTok{x =}\NormalTok{ burglary, }\DataTypeTok{y =}\NormalTok{ motor_vehicle_theft)) }\OperatorTok{+}\StringTok{ }
\StringTok{    }\KeywordTok{geom_point}\NormalTok{() }\OperatorTok{+}\StringTok{ }
\StringTok{    }\KeywordTok{labs}\NormalTok{(}\DataTypeTok{x =} \StringTok{"Burglaries per 100,000 population"}\NormalTok{, }
         \DataTypeTok{y =} \StringTok{"Motor vehicle theft per 100,000 population"}\NormalTok{,}
         \DataTypeTok{title =} \StringTok{"Burglaries vs motor vehicle theft for US states"}\NormalTok{,}
         \DataTypeTok{subtitle =} \StringTok{"2005 crime rates and 2008 population"}\NormalTok{,}
         \DataTypeTok{caption =} \StringTok{"Data from Nathan Yau http://flowingdata.com"}
\NormalTok{         )}
\end{Highlighting}
\end{Shaded}

\hypertarget{customizing-axes}{%
\section{Customizing Axes}\label{customizing-axes}}

\texttt{ggplot} also provides default axis extents (i.e., limits) and other axis features. These, and other axis features such as tick marks, labels, and transformations, can be changed using the scale functions. Here the range of the x and y axis is altered to start at zero and go to the maximum of the x and y variables.\footnote{\texttt{ggplot2} makes the axes extend slightly beyond the given range, since typically this is what the user wants.} Here too, axis labels are specified within the scale function, which is an alterative to using the \texttt{labs()} function.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{ggplot}\NormalTok{(}\DataTypeTok{data =}\NormalTok{ crime, }\KeywordTok{aes}\NormalTok{(}\DataTypeTok{x =}\NormalTok{ burglary, }\DataTypeTok{y =}\NormalTok{ motor_vehicle_theft)) }\OperatorTok{+}\StringTok{ }
\StringTok{    }\KeywordTok{geom_point}\NormalTok{() }\OperatorTok{+}\StringTok{ }
\StringTok{    }\KeywordTok{scale_x_continuous}\NormalTok{(}\DataTypeTok{name=}\StringTok{"Burglaries per 100,000 population"}\NormalTok{, }
                       \DataTypeTok{limits=}\KeywordTok{c}\NormalTok{(}\DecValTok{0}\NormalTok{,}\KeywordTok{max}\NormalTok{(crime}\OperatorTok{$}\NormalTok{burglary))) }\OperatorTok{+}
\StringTok{    }\KeywordTok{scale_y_continuous}\NormalTok{(}\DataTypeTok{name=}\StringTok{"Motor vehicle theft per 100,000 population"}\NormalTok{, }
                       \DataTypeTok{limits =} \KeywordTok{c}\NormalTok{(}\DecValTok{0}\NormalTok{, }\KeywordTok{max}\NormalTok{(crime}\OperatorTok{$}\NormalTok{motor_vehicle_theft)))}
\end{Highlighting}
\end{Shaded}

\hypertarget{text-point-size-and-color}{%
\subsection{Text, Point Size, and Color}\label{text-point-size-and-color}}

Next we make point size proportional to population, change the color, and add a state label. Note, in the \texttt{ggplot()} call I scaled \texttt{population} by 100,000 to help with the interpretability of the legend. Accordingly, I also changed the ``population'' label on the legend to ``Population\textbackslash{}n(100,000)'' using the \texttt{labs()} function\footnote{The \textbackslash{}n is the line break and puts ``(100,000)'' below ``Population''.}. We use the \texttt{geom\_label()} function to add the label, which provides an outline around the label text and allows you to control the box characteristics, e.g., I make the boxes slightly transparent using the \texttt{alpha} argument.\footnote{You can also add labels via \texttt{geom\_text()} function or a \texttt{label} argument in the \texttt{ggplot()} call.}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{ggplot}\NormalTok{(}\DataTypeTok{data =}\NormalTok{ crime, }\KeywordTok{aes}\NormalTok{(}\DataTypeTok{x =}\NormalTok{ burglary, }\DataTypeTok{y =}\NormalTok{ motor_vehicle_theft, }
           \DataTypeTok{size=}\NormalTok{population}\OperatorTok{/}\DecValTok{100000}\NormalTok{)) }\OperatorTok{+}\StringTok{ }
\StringTok{    }\KeywordTok{geom_point}\NormalTok{(}\DataTypeTok{color =} \StringTok{"blue"}\NormalTok{) }\OperatorTok{+}\StringTok{ }
\StringTok{    }\KeywordTok{geom_label}\NormalTok{(}\KeywordTok{aes}\NormalTok{(}\DataTypeTok{label =}\NormalTok{ state), }\DataTypeTok{alpha =} \FloatTok{0.5}\NormalTok{) }\OperatorTok{+}
\StringTok{    }\KeywordTok{scale_x_continuous}\NormalTok{(}\DataTypeTok{name=}\StringTok{"Burglaries per 100,000 population"}\NormalTok{, }
                       \DataTypeTok{limits=}\KeywordTok{c}\NormalTok{(}\DecValTok{0}\NormalTok{,}\KeywordTok{max}\NormalTok{(crime}\OperatorTok{$}\NormalTok{burglary))) }\OperatorTok{+}
\StringTok{    }\KeywordTok{scale_y_continuous}\NormalTok{(}\DataTypeTok{name=}\StringTok{"Motor vehicle theft per 100,000 population"}\NormalTok{, }
                       \DataTypeTok{limits =} \KeywordTok{c}\NormalTok{(}\DecValTok{0}\NormalTok{, }\KeywordTok{max}\NormalTok{(crime}\OperatorTok{$}\NormalTok{motor_vehicle_theft))) }\OperatorTok{+}
\StringTok{    }\KeywordTok{labs}\NormalTok{(}\DataTypeTok{size=}\StringTok{"Population}\CharTok{\textbackslash{}n}\StringTok{(100,000)"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

The labels are helpful but just too cluttered. There are some additional arguments that can go into \texttt{geom\_label()} that allow for label offset; however, this won't help us much here. Instead, we can try the \texttt{ggrepel} package by Kamil Slowikowski. This useful package will automatically adjust labels so that they don't overlap. First we need to download and add the package using either RStudio's install package buttons or via \texttt{install.packages("ggrepel")}. Next to make all of \texttt{ggrepel}'s functions available we can call \texttt{library(ggrepel)} function or, if we know which function we want, we can load only that particular function using the \texttt{::} operators. I use \texttt{::} below to make clear which function is coming from \texttt{ggrepel} and which is coming from \texttt{ggplot2}.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{ggplot}\NormalTok{(}\DataTypeTok{data =}\NormalTok{ crime, }\KeywordTok{aes}\NormalTok{(}\DataTypeTok{x =}\NormalTok{ burglary, }\DataTypeTok{y =}\NormalTok{ motor_vehicle_theft, }
           \DataTypeTok{size=}\NormalTok{population}\OperatorTok{/}\DecValTok{100000}\NormalTok{)) }\OperatorTok{+}\StringTok{ }
\StringTok{    }\KeywordTok{geom_point}\NormalTok{(}\DataTypeTok{color =} \StringTok{"blue"}\NormalTok{) }\OperatorTok{+}\StringTok{ }
\StringTok{    }\KeywordTok{scale_x_continuous}\NormalTok{(}\DataTypeTok{name=}\StringTok{"Burglaries per 100,000 population"}\NormalTok{, }
                       \DataTypeTok{limits=}\KeywordTok{c}\NormalTok{(}\DecValTok{0}\NormalTok{,}\KeywordTok{max}\NormalTok{(crime}\OperatorTok{$}\NormalTok{burglary))) }\OperatorTok{+}
\StringTok{    }\KeywordTok{scale_y_continuous}\NormalTok{(}\DataTypeTok{name=}\StringTok{"Motor vehicle theft per 100,000 population"}\NormalTok{, }
                       \DataTypeTok{limits =} \KeywordTok{c}\NormalTok{(}\DecValTok{0}\NormalTok{, }\KeywordTok{max}\NormalTok{(crime}\OperatorTok{$}\NormalTok{motor_vehicle_theft))) }\OperatorTok{+}
\StringTok{    }\KeywordTok{labs}\NormalTok{(}\DataTypeTok{size=}\StringTok{"Population}\CharTok{\textbackslash{}n}\StringTok{(100,000)"}\NormalTok{) }\OperatorTok{+}
\StringTok{    }\NormalTok{ggrepel}\OperatorTok{::}\KeywordTok{geom_label_repel}\NormalTok{(}\KeywordTok{aes}\NormalTok{(}\DataTypeTok{label =}\NormalTok{ state), }\DataTypeTok{alpha =} \FloatTok{0.5}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

This looks a bit better. We'll resist making additional improvements to the figure for now.

\hypertarget{other-types-of-graphics}{%
\section{Other Types of Graphics}\label{other-types-of-graphics}}

Scatter and line plots, which have just been presented, are common but certainly not the only graphical displays in common use. Histograms, boxplots, and bar graphs, as well as more ``mathematical'' displays such as the graph of a function, are commonly used to represent data. Examples of each are presented below.

\hypertarget{histograms}{%
\subsection{Histograms}\label{histograms}}

Simon Newcomb conducted several experiments to estimate the speed of light by measuring the time it took for light to travel from his laboratory to a mirror at the base of the Washington Monument, and then back to his lab. This is a distance of \(7.44373\) km, and by dividing this distance by the measured time, an estimate for the speed of light is obtained.

The times are of course quite small, and to avoid working with very small numbers, the data are recoded to be the deviation from \(24800\) nanoseconds. For example an observation coded as \(28\) represents a time of \(24828\) nanoseconds, while an observation coded as \(-44\) represents a time of \(24756\) nanoseconds.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{>}\StringTok{ }\NormalTok{u.newcomb <-}\StringTok{ "http://blue.for.msu.edu/FOR875/data/Newcomb.csv"}
\OperatorTok{>}\StringTok{ }\NormalTok{Newcomb <-}\StringTok{ }\KeywordTok{read.csv}\NormalTok{(u.newcomb, }\DataTypeTok{header =} \OtherTok{TRUE}\NormalTok{)}
\OperatorTok{>}\StringTok{ }\KeywordTok{head}\NormalTok{(Newcomb)}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{ggplot}\NormalTok{(Newcomb, }\KeywordTok{aes}\NormalTok{(}\DataTypeTok{x =}\NormalTok{ Time)) }\OperatorTok{+}\StringTok{ }\KeywordTok{geom_histogram}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

The software has an algorithm to calculate bin widths for the histogram. Sometimes the algorithm makes choices that aren't suitable (hence the R message above), and these can be changed by specifying a \texttt{binwidth}. In addition, the appearance of the bars also can be changed.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{ggplot}\NormalTok{(Newcomb, }\KeywordTok{aes}\NormalTok{(}\DataTypeTok{x =}\NormalTok{ Time)) }\OperatorTok{+}\StringTok{ }
\StringTok{    }\KeywordTok{geom_histogram}\NormalTok{(}\DataTypeTok{binwidth =} \DecValTok{5}\NormalTok{, }\DataTypeTok{color =} \StringTok{"black"}\NormalTok{, }\DataTypeTok{fill =} \StringTok{"blue"}\NormalTok{ )}
\end{Highlighting}
\end{Shaded}

\hypertarget{boxplots}{%
\subsection{Boxplots}\label{boxplots}}

Next we consider some data from the gap minder data set to construct some box plots. These data are available in the \texttt{gapminder} package, which might need to be installed via \texttt{install.packages("gapminder")}.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(gapminder)}
\KeywordTok{ggplot}\NormalTok{(}\DataTypeTok{data =} \KeywordTok{subset}\NormalTok{(gapminder,  year }\OperatorTok{==}\StringTok{ }\DecValTok{2002}\NormalTok{), }
       \KeywordTok{aes}\NormalTok{(}\DataTypeTok{x =}\NormalTok{ continent, }\DataTypeTok{y =}\NormalTok{ gdpPercap)) }\OperatorTok{+}\StringTok{ }
\StringTok{    }\KeywordTok{geom_boxplot}\NormalTok{(}\DataTypeTok{color =} \StringTok{"black"}\NormalTok{, }\DataTypeTok{fill =} \StringTok{"lightblue"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Here's the same set of boxplots, but with different colors, different axis labels, and the boxes plotted horizontally rather than vertically.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{ggplot}\NormalTok{(}\DataTypeTok{data =} \KeywordTok{subset}\NormalTok{(gapminder,  year }\OperatorTok{==}\StringTok{ }\DecValTok{2002}\NormalTok{), }
       \KeywordTok{aes}\NormalTok{(}\DataTypeTok{x =}\NormalTok{ continent, }\DataTypeTok{y =}\NormalTok{ gdpPercap)) }\OperatorTok{+}\StringTok{ }
\StringTok{    }\KeywordTok{geom_boxplot}\NormalTok{(}\DataTypeTok{color =} \StringTok{"red"}\NormalTok{, }\DataTypeTok{fill =} \StringTok{"lightblue"}\NormalTok{) }\OperatorTok{+}\StringTok{ }
\StringTok{    }\KeywordTok{scale_x_discrete}\NormalTok{(}\DataTypeTok{name =} \StringTok{"Continent"}\NormalTok{) }\OperatorTok{+}\StringTok{ }
\StringTok{    }\KeywordTok{scale_y_continuous}\NormalTok{(}\DataTypeTok{name =} \StringTok{"Per Capita GDP"}\NormalTok{) }\OperatorTok{+}\StringTok{ }\KeywordTok{coord_flip}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

\hypertarget{bar-graphs}{%
\subsection{Bar Graphs}\label{bar-graphs}}

As part of a study, elementary school students were asked which was more important to them: good grades, popularity, or athletic ability. Here is a brief look at the data.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{>}\StringTok{ }\NormalTok{u.goals <-}\StringTok{ "http://blue.for.msu.edu/FOR875/data/StudentGoals.csv"}
\OperatorTok{>}\StringTok{ }\NormalTok{StudentGoals <-}\StringTok{ }\KeywordTok{read.csv}\NormalTok{(u.goals, }\DataTypeTok{header =} \OtherTok{TRUE}\NormalTok{)}
\OperatorTok{>}\StringTok{ }\KeywordTok{head}\NormalTok{(StudentGoals)}
\end{Highlighting}
\end{Shaded}

First, a simple bar graph of the most important goal chosen is drawn, followed by a stacked bar graph which also includes the student's gender. We then add a side by side bar graph that includes the student's gender.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{ggplot}\NormalTok{(StudentGoals, }\KeywordTok{aes}\NormalTok{(}\DataTypeTok{x =}\NormalTok{ Goals)) }\OperatorTok{+}\StringTok{ }\KeywordTok{geom_bar}\NormalTok{()}
\KeywordTok{ggplot}\NormalTok{(StudentGoals, }\KeywordTok{aes}\NormalTok{(}\DataTypeTok{x =}\NormalTok{ Goals, }\DataTypeTok{fill =}\NormalTok{ Gender)) }\OperatorTok{+}\StringTok{ }\KeywordTok{geom_bar}\NormalTok{()}
\KeywordTok{ggplot}\NormalTok{(StudentGoals, }\KeywordTok{aes}\NormalTok{(}\DataTypeTok{x =}\NormalTok{ Goals, }\DataTypeTok{fill =}\NormalTok{ Gender)) }\OperatorTok{+}\StringTok{ }
\StringTok{    }\KeywordTok{geom_bar}\NormalTok{(}\DataTypeTok{position =} \StringTok{"dodge"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

In this example R counted the number of students who had each goal and used these counts as the height of the bars. Sometimes the data contain the bar heights as a variable. For example, we create a bar graph of India's per capita GDP with separate bars for each year in the data\footnote{R offers a large color palette, run \texttt{colors()} on the console to see a list of color names.}.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{ggplot}\NormalTok{(}\KeywordTok{subset}\NormalTok{(gapminder, country }\OperatorTok{==}\StringTok{ "India"}\NormalTok{), }\KeywordTok{aes}\NormalTok{(}\DataTypeTok{x =}\NormalTok{ year, }\DataTypeTok{y =}\NormalTok{ gdpPercap)) }\OperatorTok{+}\StringTok{ }
\StringTok{    }\KeywordTok{geom_bar}\NormalTok{(}\DataTypeTok{stat =} \StringTok{"identity"}\NormalTok{, }\DataTypeTok{color =} \StringTok{"black"}\NormalTok{, }\DataTypeTok{fill =} \StringTok{"steelblue2"}\NormalTok{) }\OperatorTok{+}\StringTok{ }
\StringTok{    }\KeywordTok{ggtitle}\NormalTok{(}\StringTok{"India's per-capita GDP"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\hypertarget{graphs-of-functions}{%
\subsection{Graphs of Functions}\label{graphs-of-functions}}

One way to create a plot of a mathematical function \(f\) is to create a data frame with \(x\) values in one column and \(f(x)\) values in another column, and then draw a line plot.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\KeywordTok{seq}\NormalTok{(}\OperatorTok{-}\NormalTok{pi, pi, }\DataTypeTok{len =} \DecValTok{1000}\NormalTok{)}
\NormalTok{sin.data <-}\StringTok{ }\KeywordTok{data.frame}\NormalTok{(}\DataTypeTok{x =}\NormalTok{ x, }\DataTypeTok{y =} \KeywordTok{sin}\NormalTok{(x))}
\KeywordTok{ggplot}\NormalTok{(}\DataTypeTok{data =}\NormalTok{ sin.data, }\KeywordTok{aes}\NormalTok{(}\DataTypeTok{x =}\NormalTok{ x, }\DataTypeTok{y =}\NormalTok{ y)) }\OperatorTok{+}\StringTok{ }\KeywordTok{geom_line}\NormalTok{() }\OperatorTok{+}\StringTok{ }
\StringTok{    }\KeywordTok{scale_y_continuous}\NormalTok{(}\DataTypeTok{name =} \StringTok{"sin(x)"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

This method works well, but with a better understanding of functions in R we will be able to plot mathematical functions in a simpler and more natural way.

\hypertarget{themes}{%
\section{Themes}\label{themes}}

The theme defines non-data aspects of the plot's characteristics such as background color, axes, and grid lines. Default themes include: \texttt{theme\_bw()}, \texttt{theme\_classic()}, \texttt{theme\_dark()}, \texttt{theme\_gray()}, \texttt{theme\_light()}, \texttt{theme\_linedraw()}, \texttt{theme\_minimal()}, and \texttt{theme\_void()}. Changing the theme is as easy as adding it to your initial \texttt{ggplot()} call. Here I replace the default implicit \texttt{theme\_bw()} theme with the classic theme.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{ggplot}\NormalTok{(}\DataTypeTok{data =}\NormalTok{ sin.data, }\KeywordTok{aes}\NormalTok{(}\DataTypeTok{x =}\NormalTok{ x, }\DataTypeTok{y =}\NormalTok{ y)) }\OperatorTok{+}\StringTok{ }\KeywordTok{geom_line}\NormalTok{() }\OperatorTok{+}\StringTok{ }
\StringTok{    }\KeywordTok{scale_y_continuous}\NormalTok{(}\DataTypeTok{name =} \StringTok{"sin(x)"}\NormalTok{) }\OperatorTok{+}
\StringTok{    }\KeywordTok{theme_classic}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

The \texttt{ggthemes} add-on package {[}\url{https://github.com/jrnold/ggthemes}{]} by Jeffrey Arnold provides a large selection of themes beyond the eight themes that come with \texttt{ggplot2}.

\hypertarget{saving-graphics}{%
\section{Saving Graphics}\label{saving-graphics}}

We often want to export our graphics to use in an external document or share with colleagues. There are several ways to save graphics in a variety of file formats. The \texttt{ggsave()} function will allow you to save your most recent \texttt{ggplot()} to a variety of vector (e.g., ``eps'', ``ps'', ``pdf'', ``svg'') or raster (e.g., ``jpeg'', ``tiff'', ``png'', ``bmp'', ``wmf'') formats \footnote{Vector files comprise lines and curves known as paths, whereas raster files are comprised of pixels. Vector images are often preferred for publication quality graphics because they can be edited, scale well, and provide crisper detail.}. The subsequent call to \texttt{ggsave()} saves the \texttt{sin.data} plot to a pdf file called ``sin-plot.pdf''.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{ggplot}\NormalTok{(}\DataTypeTok{filename =} \StringTok{"sin-plot.pdf"}\NormalTok{, }\DataTypeTok{device=}\StringTok{"pdf"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

The \texttt{ggplot()} function takes additional arguments to control scale, measurement units, and raster plot resolution, i.e., dots per inch (dpi).

\hypertarget{more-resources}{%
\section{More Resources}\label{more-resources}}

In summary, \texttt{ggplot2} provides a fairly intuitive\footnote{Like everything else in this book, it takes practice to get used to the syntax.} framework for developing an enormous variety of graphics. In addition to the resources mentioned at the beginning of this chapter, there are numerous online \texttt{ggplot2} resources and galleries to get ideas for creating beautiful graphics to convey the stories in your data. See, for example,

\begin{itemize}
\tightlist
\item
  \url{http://docs.ggplot2.org}
\item
  \url{http://www.r-graph-gallery.com/portfolio/ggplot2-package}
\item
  \url{http://www.ggplot2-exts.org/gallery}
\item
  \url{http://www.cookbook-r.com/Graphs}
\item
  and of course www.google.com
\end{itemize}

While the built-in \texttt{ggplot2} package documentation (accessible via the help tab in RStudio) is helpful, the official online documentation at \url{http://docs.ggplot2.org} is particularly useful because it provides example plots and easy navigation between related topics. The large number number of functions and syntax in \texttt{ggplot2} can be daunting. RStudio provides some handy cheatsheets to help you along www.rstudio.com/resources/cheatsheets or direct link www.rstudio.com/wp-content/uploads/2016/11/ggplot2-cheatsheet-2.1.pdf.

\texttt{ggplot2} also has an active mailing list at \url{http://groups.google.com/group/ggplot2}. The list is an excellent resource for users at all stages of experience. Another useful resource is stackoverflow, \url{http://stackoverflow.com}. There is an active \texttt{ggplot2} community on stackoverflow, and many common questions have already been asked and answered. When posting questions on any programming mailing list, it is best to provide a minimal reproducible example of your issue. The \texttt{reprex} \url{https://github.com/jennybc/reprex} package by Jenny Bryan provides a convenient way to do this, and also includes advice on creating a good example. The more information you provide about your issue, the more likely the community is to help you.

\hypertarget{practice-exercises-2}{%
\section{Practice Exercises}\label{practice-exercises-2}}

\hypertarget{homework-2}{%
\section{Homework}\label{homework-2}}

\textbf{Exercise 6} Learning objectives: practice using \texttt{ggplot2} functions; summarize variables using graphics; introduce \texttt{ggplot2} facets.

\hypertarget{data2}{%
\chapter{Working with Data}\label{data2}}

Bringing data into R, exporting data from R in a form that is readable by other software, cleaning and reshaping data, and other data manipulation tasks are an important and often overlooked component of data science. The book \citet{SpectorDataManipulation}, while a few years old, is still an excellent reference for data-related issues. And the \emph{R Data Import/Export} manual, available online at \url{https://cran.r-project.org/doc/manuals/r-release/R-data.html}, is an up-to-date (and free) reference on importing a wide variety of datasets into R and on exporting data in various forms.

\hypertarget{reading-data-into-r}{%
\section{Reading Data into R}\label{reading-data-into-r}}

Data come in a dizzying variety of forms. It might be in a proprietary format such as an \href{https://en.wikipedia.org/wiki/Microsoft_Excel}{.xlsx} Excel file, a \href{https://en.wikipedia.org/wiki/SPSS}{.sav} SPSS file, or a \href{https://en.wikipedia.org/wiki/Minitab}{.mtw} Minitab file. It might be structured using a \href{https://en.wikipedia.org/wiki/Relational_model\%7D\%7Brelational\%20model}{relational model} comprising many tables that need to be connected via key-value pairs. It might be a data-interchange format such as \href{http://www.json.org/}{JSON} (JavaScript Object Notation), or a markup language such as \href{https://en.wikipedia.org/wiki/XML}{XML} (Extensible Markup Language), perhaps with specialized standards for describing ecological information, see \href{https://en.wikipedia.org/wiki/Ecological_Metadata_Language}{EML} (Ecological Metadata Language). Both XML and EML are common data metadata formats (i.e., data that provides information about other data). Fortunately many datasets are (or can be) saved as plain text files, and most software can both read and write such files, so our initial focus will be on reading plain text files into R and saving data from R in plain text format. RStudio provides a handy \href{http://www.rstudio.com/resources/cheatsheets}{data import cheat sheet} for many of the read functions detailed in this section.

The \texttt{foreign} R package provides functions to directly read data saved in some of the proprietary formats into R, which is sometimes unavoidable, but if possible it is good to save data from another package as plain text and then read this plain text file into R. In Chapter \ref{xml} methods for reading web-based data sets into R will be discussed.

The function \texttt{read.table()} and its offshoots such as \texttt{read.csv()} are used to read in rectangular data from a text file. For example, the file \texttt{BrainAndBody.csv} contains data\footnote{These data come from the \texttt{MASS} R library.} on the brain weight, body weight, and name of some terrestrial animals. Here are the first few lines of that file:

\begin{verbatim}
body,brain,name
1.35,8.1,Mountain beaver
465,423,Cow
36.33,119.5,Grey wolf
27.66,115,Goat
1.04,5.5,Guinea pig
\end{verbatim}

As is evident, the first line of the file contains the names of the three variables, separated (delimited) by commas. Each subsequent line contains the body weight, brain weight, and name of a specific terrestrial animal.

This file is accessible at the url \url{http://blue.for.msu.edu/FOR875/data/BrainAndBody.csv}. The \texttt{read.table()} function is used to read these data into an R data frame.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{>}\StringTok{ }\NormalTok{u.bb <-}\StringTok{ "http://blue.for.msu.edu/FOR875/data/BrainAndBody.csv"}
\OperatorTok{>}\StringTok{ }\NormalTok{BrainBody <-}\StringTok{ }\KeywordTok{read.table}\NormalTok{(}\DataTypeTok{file =}\NormalTok{ u.bb, }\DataTypeTok{header =} \OtherTok{TRUE}\NormalTok{, }\DataTypeTok{sep =} \StringTok{","}\NormalTok{, }
\OperatorTok{+}\StringTok{                         }\DataTypeTok{stringsAsFactors =} \OtherTok{FALSE}\NormalTok{)}
\OperatorTok{>}\StringTok{ }\KeywordTok{head}\NormalTok{(BrainBody)}
\end{Highlighting}
\end{Shaded}

The arguments used in this call to \texttt{read.table()} include:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \texttt{file\ =\ u.bb}, which tells R the location of the file. In this case the string \texttt{http://blue.for.msu.edu/FOR875/data/BrainAndBody.csv} giving the location is rather long, so it was first assigned to the object \texttt{u.bb}.
\item
  \texttt{header\ =\ TRUE}, which tells R the first line of the file gives the names of the variables.
\item
  \texttt{sep\ =\ ","}, which tells R that a comma separates the fields in the file.
\item
  \texttt{stringsAsFactors\ =\ FALSE} which tells R not to convert character vectors to factors.
\end{enumerate}

The function \texttt{read.csv()} is the same as \texttt{read.table()} except the default separator is a comma, whereas the default separator for \texttt{read.table()} is whitespace.

The file \texttt{BrainAndBody.tsv} contains the same data, except a tab is used in place of a comma to separate fields. The only change needed to read in the data in this file is in the \texttt{sep} argument (and of course the \texttt{file} argument, since the data are stored in a different file):

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{>}\StringTok{ }\NormalTok{u.bb <-}\StringTok{ "http://blue.for.msu.edu/FOR875/data/BrainAndBody.tsv"}
\OperatorTok{>}\StringTok{ }\NormalTok{BrainBody2 <-}\StringTok{ }\KeywordTok{read.table}\NormalTok{(}\DataTypeTok{file =}\NormalTok{ u.bb, }\DataTypeTok{header =} \OtherTok{TRUE}\NormalTok{, }\DataTypeTok{sep =} \StringTok{"}\CharTok{\textbackslash{}t}\StringTok{"}\NormalTok{, }
\OperatorTok{+}\StringTok{                          }\DataTypeTok{stringsAsFactors =} \OtherTok{FALSE}\NormalTok{)}
\OperatorTok{>}\StringTok{ }\KeywordTok{head}\NormalTok{(BrainBody2)}
\end{Highlighting}
\end{Shaded}

File extensions, e.g., \texttt{.csv} or \texttt{.tsv}, are naming conventions only and are there to remind us how the columns are separated. In other words, they have no influence on R's file read functions.

A third file, \texttt{BrainAndBody.txt}, contains the same data, but also contains a few lines of explanatory text above the names of the variables. It also uses whitespace rather than a comma or a tab as a separator. Here are the first several lines of the file.

\begin{verbatim}
This file contains data
on brain and body
weights of several terrestrial animals

"body" "brain" "name"
1.35 8.1 "Mountain beaver"
465 423 "Cow"
36.33 119.5 "Grey wolf"
27.66 115 "Goat"
1.04 5.5 "Guinea pig"
11700 50 "Dipliodocus"
2547 4603 "Asian elephant"
\end{verbatim}

Notice that in this file the values of \texttt{name} are put inside of quotation marks. This is necessary since instead R would (reasonably) assume the first line contained the values of four variables, the values being \texttt{1.35}, \texttt{8.1}, \texttt{Mountain}, and \texttt{beaver} while in reality there are only three values desired, with \texttt{Mountain\ beaver} being the third.

To read in this file we need to tell R to skip the first five lines and to use whitespace as the separator. The \texttt{skip} argument handles the first, and the \texttt{sep} argument the second. First let's see what happens if we don't use the \texttt{skip} argument.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{>}\StringTok{ }\NormalTok{u.bb <-}\StringTok{ "http://blue.for.msu.edu/FOR875/data/BrainAndBody.txt"}
\OperatorTok{>}\StringTok{ }\NormalTok{BrainBody3 <-}\StringTok{ }\KeywordTok{read.table}\NormalTok{(u.bb, }\DataTypeTok{header =} \OtherTok{TRUE}\NormalTok{, }\DataTypeTok{sep =} \StringTok{" "}\NormalTok{, }
\OperatorTok{+}\StringTok{                          }\DataTypeTok{stringsAsFactors =} \OtherTok{FALSE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

R assumed the first line of the file contained the variable names, since \texttt{header\ =\ TRUE} was specified, and counted four including \texttt{This}, \texttt{file}, \texttt{contains}, and \texttt{data}. So in the first line of actual data, R expected four columns containing data plus possibly a fifth column containing row names for the data set, and complained that ``line 1 did not have 5 elements.'' The error message is somewhat mysterious, since it starts with ``Error in scan.'' This happens because \texttt{read.table()} actually uses a more basic R function called \texttt{scan()} to do the work.

Here's how to read in the file correctly.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{>}\StringTok{ }\NormalTok{u.bb <-}\StringTok{ "http://blue.for.msu.edu/FOR875/data/BrainAndBody.txt"}
\OperatorTok{>}\StringTok{ }\NormalTok{BrainBody3 <-}\StringTok{ }\KeywordTok{read.table}\NormalTok{(u.bb, }\DataTypeTok{header =} \OtherTok{TRUE}\NormalTok{, }\DataTypeTok{sep =} \StringTok{" "}\NormalTok{, }
\OperatorTok{+}\StringTok{                          }\DataTypeTok{stringsAsFactors =} \OtherTok{FALSE}\NormalTok{, }\DataTypeTok{skip =} \DecValTok{4}\NormalTok{)}
\OperatorTok{>}\StringTok{ }\NormalTok{BrainBody3[}\DecValTok{1}\OperatorTok{:}\DecValTok{10}\NormalTok{,]}
\end{Highlighting}
\end{Shaded}

\hypertarget{reading-data-with-missing-observations}{%
\section{Reading Data with Missing Observations}\label{reading-data-with-missing-observations}}

Missing data are represented in many ways. Sometimes a missing data point is just that, i.e., the place where it should be in the file is blank. Other times specific numbers such as \(-9999\) or specific symbols are used. The \texttt{read.table()} function has an argument \texttt{na.string} that allows the user to specify how missing data is indicated in the source file.

The site \url{http://www.wunderground.com/history/} makes weather data available for locations around the world from dates going back to 1945. The file \texttt{WeatherKLAN2014.csv} contains weather data for Lansing, Michigan for the year 2014. Here are the first few lines of that file:

\begin{verbatim}
EST,Max TemperatureF,Min TemperatureF, Events
1/1/14,14,9,Snow
1/2/14,13,-3,Snow
1/3/14,13,-11,Snow
1/4/14,31,13,Snow
1/5/14,29,16,Fog-Snow
1/6/14,16,-12,Fog-Snow
1/7/14,2,-13,Snow
1/8/14,17,-1,Snow
1/9/14,21,2,Snow
1/10/14,39,21,Fog-Rain-Snow
1/11/14,41,32,Fog-Rain
1/12/14,39,31,
\end{verbatim}

Look at the last line, and notice that instead of an \texttt{Event} such as \texttt{Snow} or \texttt{Fog-Snow} there is nothing after the comma. This observation is missing, but rather than using an explicit code such as \texttt{NA}, the site just leaves that entry blank. To read these data into R we will supply the argument \texttt{na.string\ =\ ""} which tells R the file indicates missing data by leaving the appropriate entry blank.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{>}\StringTok{ }\NormalTok{u.weather <-}\StringTok{ "http://blue.for.msu.edu/FOR875/data/WeatherKLAN2014.csv"}
\OperatorTok{>}\StringTok{ }\NormalTok{WeatherKLAN2014 <-}\StringTok{ }\KeywordTok{read.csv}\NormalTok{(u.weather, }\DataTypeTok{header=}\OtherTok{TRUE}\NormalTok{, }
\OperatorTok{+}\StringTok{                             }\DataTypeTok{stringsAsFactors =} \OtherTok{FALSE}\NormalTok{, }\DataTypeTok{na.string =} \StringTok{""}\NormalTok{)}
\OperatorTok{>}\StringTok{ }\NormalTok{WeatherKLAN2014[}\DecValTok{1}\OperatorTok{:}\DecValTok{15}\NormalTok{,]}
\end{Highlighting}
\end{Shaded}

\hypertarget{summarizing-data-frames}{%
\section{Summarizing Data Frames}\label{summarizing-data-frames}}

Some common data tasks include variable summaries such as means or standard deviations, transforming an existing variable, and creating new variables. As with many tasks, there are several ways to accomplish each of these.

\hypertarget{column-and-row-summaries}{%
\subsection{Column (and Row) Summaries}\label{column-and-row-summaries}}

The file \texttt{WeatherKLAN2014Full.csv} contains a more complete set of weather data variables than \texttt{WeatherKLAN2014.csv}, from the same source, \url{http://www.wunderground.com/history}.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{>}\StringTok{ }\NormalTok{u.weather <-}\StringTok{ "http://blue.for.msu.edu/FOR875/data/WeatherKLAN2014Full.csv"}
\OperatorTok{>}\StringTok{ }\NormalTok{WeatherKLAN2014Full <-}\StringTok{ }\KeywordTok{read.csv}\NormalTok{(u.weather, }\DataTypeTok{header=}\OtherTok{TRUE}\NormalTok{, }
\OperatorTok{+}\StringTok{                                }\DataTypeTok{stringsAsFactors =} \OtherTok{FALSE}\NormalTok{, }
\OperatorTok{+}\StringTok{                                }\DataTypeTok{na.string =} \StringTok{""}\NormalTok{)}
\OperatorTok{>}\StringTok{ }\KeywordTok{names}\NormalTok{(WeatherKLAN2014Full)}
\end{Highlighting}
\end{Shaded}

How can we compute the mean for each variable? One possibility is to do this a variable at a time:

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{>}\StringTok{ }\KeywordTok{mean}\NormalTok{(WeatherKLAN2014Full}\OperatorTok{$}\NormalTok{Mean.TemperatureF)}
\OperatorTok{>}\StringTok{ }\KeywordTok{mean}\NormalTok{(WeatherKLAN2014Full}\OperatorTok{$}\NormalTok{Min.TemperatureF)}
\OperatorTok{>}\StringTok{ }\KeywordTok{mean}\NormalTok{(WeatherKLAN2014Full}\OperatorTok{$}\NormalTok{Max.TemperatureF)}
\OperatorTok{>}\StringTok{ }\CommentTok{## Et Cetera}
\end{Highlighting}
\end{Shaded}

This is pretty inefficient. Fortunately there is a \texttt{colMeans()} function which computes the mean of each column (or a specified number of columns) in a data frame. Some columns in the current data frame are not numeric, and obviously we don't want to ask R to compute means for these columns. We use \texttt{str()} to investigate.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{>}\StringTok{ }\KeywordTok{str}\NormalTok{(WeatherKLAN2014Full)}
\end{Highlighting}
\end{Shaded}

It isn't surprising that \texttt{EST} and \texttt{Events} are not numeric, but is surprising that \texttt{PrecipitationIn}, which measures precipitation in inches, also is not numeric, but is character. Let's investigate further.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{>}\StringTok{ }\NormalTok{WeatherKLAN2014Full}\OperatorTok{$}\NormalTok{PrecipitationIn[}\DecValTok{1}\OperatorTok{:}\DecValTok{50}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

Now it's more clear. The original data file included \texttt{T} in the precipitation column to represent a ``trace'' of precipitation, which is precipitation greater than \(0\) but less than \(0.01\) inches. One possibility would be to set all these values to \texttt{"0"}, and then to convert the column to numeric. For now we will just leave the \texttt{PrecipitationIn} column out of the columns for which we request the mean.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{>}\StringTok{ }\KeywordTok{colMeans}\NormalTok{(WeatherKLAN2014Full[, }\KeywordTok{c}\NormalTok{(}\DecValTok{2}\OperatorTok{:}\DecValTok{19}\NormalTok{, }\DecValTok{21}\NormalTok{, }\DecValTok{23}\NormalTok{)])}
\end{Highlighting}
\end{Shaded}

\hypertarget{apply}{%
\subsection{\texorpdfstring{The \texttt{apply()} Function}{The apply() Function}}\label{apply}}

R also has functions \texttt{rowMeans()}, \texttt{colSums()}, and \texttt{rowSums()}. But what if we want to compute the median or standard deviation of columns of data, or some other summary statistic? For this the \texttt{apply()} function can be used. This function applies a user-chosen function to either the rows or columns (or both) of a data frame. The arguments are:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \texttt{X}: the data frame of interest
\item
  \texttt{MARGIN}: specifying either rows (\texttt{MARGIN\ =\ 1}) or columns (\texttt{MARGIN\ =\ 2})
\item
  \texttt{FUN}: the function to be applied.
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{>}\StringTok{ }\KeywordTok{apply}\NormalTok{(}\DataTypeTok{X =}\NormalTok{ WeatherKLAN2014Full[, }\KeywordTok{c}\NormalTok{(}\DecValTok{2}\OperatorTok{:}\DecValTok{19}\NormalTok{, }\DecValTok{21}\NormalTok{, }\DecValTok{23}\NormalTok{)], }\DataTypeTok{MARGIN =} \DecValTok{2}\NormalTok{, }
\OperatorTok{+}\StringTok{   }\DataTypeTok{FUN =}\NormalTok{ sd)}
\end{Highlighting}
\end{Shaded}

As with any R function the arguments don't need to be named as long as they are specified in the correct order, so

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{>}\StringTok{ }\KeywordTok{apply}\NormalTok{(WeatherKLAN2014Full[, }\KeywordTok{c}\NormalTok{(}\DecValTok{2}\OperatorTok{:}\DecValTok{19}\NormalTok{, }\DecValTok{21}\NormalTok{, }\DecValTok{23}\NormalTok{)], }\DecValTok{2}\NormalTok{, sd)}
\end{Highlighting}
\end{Shaded}

has the same result.

\hypertarget{saving-typing-using-with}{%
\subsection{\texorpdfstring{Saving Typing Using \texttt{with()}}{Saving Typing Using with()}}\label{saving-typing-using-with}}

Consider calculating the mean of the maximum temperature values for those days where the cloud cover is less than 4 and when the maximum humidity is over 85. We can do this using subsetting.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{>}\StringTok{ }\KeywordTok{mean}\NormalTok{(WeatherKLAN2014Full}\OperatorTok{$}\NormalTok{Max.TemperatureF[}
\OperatorTok{+}\StringTok{                              }\NormalTok{WeatherKLAN2014Full}\OperatorTok{$}\NormalTok{CloudCover }\OperatorTok{<}\StringTok{ }\DecValTok{4} \OperatorTok{&}\StringTok{ }
\OperatorTok{+}\StringTok{                              }\NormalTok{WeatherKLAN2014Full}\OperatorTok{$}\NormalTok{Max.Humidity }\OperatorTok{>}\StringTok{ }\DecValTok{85}\NormalTok{])}
\end{Highlighting}
\end{Shaded}

While this works, it requires a lot of typing, since each time we refer to a variable in the data set we need to preface its name by \texttt{WeatherKLAN2014Full\$}. The \texttt{with()} function tells R that we are working with a particular data frame, and we don't need to keep typing the name of the data frame.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{>}\StringTok{ }\KeywordTok{with}\NormalTok{(WeatherKLAN2014Full, }\KeywordTok{mean}\NormalTok{(Max.TemperatureF[CloudCover }\OperatorTok{<}\StringTok{ }
\OperatorTok{+}\StringTok{   }\DecValTok{4} \OperatorTok{&}\StringTok{ }\NormalTok{Max.Humidity }\OperatorTok{>}\StringTok{ }\DecValTok{85}\NormalTok{]))}
\end{Highlighting}
\end{Shaded}

\hypertarget{transforming-a-data-frame}{%
\section{Transforming a Data Frame}\label{transforming-a-data-frame}}

Variables are often added to, removed from, changed in, or rearranged in a data frame. The subsetting features of R make this reasonably easy. We will investigate this in the context of the \texttt{gapminder} data frame. If the \texttt{gapminder} library is not yet installed, use \texttt{install.packages("gapminder")} to install it locally.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{>}\StringTok{ }\KeywordTok{library}\NormalTok{(gapminder)}
\OperatorTok{>}\StringTok{ }\KeywordTok{str}\NormalTok{(gapminder)}
\end{Highlighting}
\end{Shaded}

\hypertarget{adding-variables}{%
\subsection{Adding Variables}\label{adding-variables}}

The data frame contains per capita GDP and population, and it might be interesting to create a variable that gives the total GDP by multiplying these two variables. (If we were interested in an accurate value for the total GDP we would probably be better off getting this information directly, since it is likely that the per capita GDP values in the data frame are rounded substantially.)

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{>}\StringTok{ }\NormalTok{gapminder}\OperatorTok{$}\NormalTok{TotalGDP <-}\StringTok{ }\NormalTok{gapminder}\OperatorTok{$}\NormalTok{gdpPercap }\OperatorTok{*}\StringTok{ }\NormalTok{gapminder}\OperatorTok{$}\NormalTok{pop}
\OperatorTok{>}\StringTok{ }\KeywordTok{str}\NormalTok{(gapminder)}
\end{Highlighting}
\end{Shaded}

Analogous to the \texttt{with()} function, there is a function \texttt{within()} which can simplify the syntax. Whereas \texttt{with()} does not change the data frame, \texttt{within()} can. Note, below I first remove the altered gapminder dataframe using \texttt{rm()} then bring a clean copy back in by reloading the \texttt{gapminder} package.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{>}\StringTok{ }\KeywordTok{rm}\NormalTok{(gapminder)}
\OperatorTok{>}\StringTok{ }\KeywordTok{library}\NormalTok{(gapminder)}
\OperatorTok{>}\StringTok{ }\KeywordTok{str}\NormalTok{(gapminder)}
\OperatorTok{>}\StringTok{ }\NormalTok{gapminder <-}\StringTok{ }\KeywordTok{within}\NormalTok{(gapminder, TotalGDP <-}\StringTok{ }\NormalTok{gdpPercap }\OperatorTok{*}\StringTok{ }\NormalTok{pop)}
\OperatorTok{>}\StringTok{ }\KeywordTok{str}\NormalTok{(gapminder)}
\end{Highlighting}
\end{Shaded}

A nice feature of \texttt{within()} is its ability to add more than one variable at a time to a data frame. In this case the two or more formulas creating new variables must be enclosed in braces.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{>}\StringTok{ }\NormalTok{gapminder <-}\StringTok{ }\KeywordTok{within}\NormalTok{(gapminder, \{TotalGDP <-}\StringTok{ }\NormalTok{gdpPercap }\OperatorTok{*}\StringTok{ }\NormalTok{pop}
\OperatorTok{+}\StringTok{     }\NormalTok{lifeExpMonths <-}\StringTok{ }\NormalTok{lifeExp }\OperatorTok{*}\StringTok{ }\DecValTok{12}\NormalTok{\})}
\OperatorTok{>}\StringTok{ }\KeywordTok{str}\NormalTok{(gapminder)}
\end{Highlighting}
\end{Shaded}

\hypertarget{removing-variables}{%
\subsection{Removing Variables}\label{removing-variables}}

After reflection we may realize the new variables we added to the \texttt{gapminder} data frame are not useful, and should be removed.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{>}\StringTok{ }\KeywordTok{str}\NormalTok{(gapminder)}
\OperatorTok{>}\StringTok{ }\NormalTok{gapminder <-}\StringTok{ }\NormalTok{gapminder[}\DecValTok{1}\OperatorTok{:}\DecValTok{6}\NormalTok{]}
\OperatorTok{>}\StringTok{ }\KeywordTok{str}\NormalTok{(gapminder)}
\end{Highlighting}
\end{Shaded}

The same result could be obtained via \texttt{gapminder\ \textless{}-\ gapminder{[},\ 1:6{]}}. The first method uses the fact that a data frame is also a list, and uses list subsetting methods. It is slightly preferable, since even if only one variable is retained, the object will still be a data frame, while the other method can return a vector in this case. Note this difference in the resulting \texttt{x} variable below (again this behavior can be frustrating at times if it is not anticipated).

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{>}\StringTok{ }\NormalTok{a <-}\StringTok{ }\KeywordTok{data.frame}\NormalTok{(}\DataTypeTok{x =} \DecValTok{1}\OperatorTok{:}\DecValTok{3}\NormalTok{, }\DataTypeTok{y =} \KeywordTok{c}\NormalTok{(}\StringTok{"dog"}\NormalTok{, }\StringTok{"cat"}\NormalTok{, }\StringTok{"pig"}\NormalTok{), }\DataTypeTok{z =} \KeywordTok{seq}\NormalTok{(}\DataTypeTok{from =} \DecValTok{1}\NormalTok{, }
\OperatorTok{+}\StringTok{   }\DataTypeTok{to =} \DecValTok{2}\NormalTok{, }\DataTypeTok{length =} \DecValTok{3}\NormalTok{))}
\OperatorTok{>}\StringTok{ }\NormalTok{a}
\OperatorTok{>}\StringTok{ }\NormalTok{a <-}\StringTok{ }\NormalTok{a[}\DecValTok{1}\NormalTok{]}
\OperatorTok{>}\StringTok{ }\NormalTok{a}
\OperatorTok{>}\StringTok{ }\NormalTok{a <-}\StringTok{ }\KeywordTok{data.frame}\NormalTok{(}\DataTypeTok{x =} \DecValTok{1}\OperatorTok{:}\DecValTok{3}\NormalTok{, }\DataTypeTok{y =} \KeywordTok{c}\NormalTok{(}\StringTok{"dog"}\NormalTok{, }\StringTok{"cat"}\NormalTok{, }\StringTok{"pig"}\NormalTok{), }\DataTypeTok{z =} \KeywordTok{seq}\NormalTok{(}\DataTypeTok{from =} \DecValTok{1}\NormalTok{, }
\OperatorTok{+}\StringTok{   }\DataTypeTok{to =} \DecValTok{2}\NormalTok{, }\DataTypeTok{length =} \DecValTok{3}\NormalTok{))}
\OperatorTok{>}\StringTok{ }\NormalTok{a}
\OperatorTok{>}\StringTok{ }\NormalTok{a <-}\StringTok{ }\NormalTok{a[, }\DecValTok{1}\NormalTok{]}
\OperatorTok{>}\StringTok{ }\NormalTok{a}
\end{Highlighting}
\end{Shaded}

One can also use a negative sign in front of the variable number(s). For example, \texttt{a{[}-(2:3){]}} would drop the first two columns of \texttt{a}. Some care is needed when removing variables using the negative sign---what happens if you write \texttt{a{[}-2:3{]}} instead of \texttt{a{[}-(2:3){]}} (why are the parentheses important here)?

An alternative approach is to set the variables you'd like to remove to \texttt{NULL}. For example, \texttt{a{[}c("y","z"){]}\ \textless{}-\ NULL} and \texttt{a{[},2:3{]}\ \textless{}-\ NULL} produce the same result as above.

\hypertarget{transforming-variables}{%
\subsection{Transforming Variables}\label{transforming-variables}}

Consider the gapminder data again. Possibly we don't want to add a new variable that gives life expectancy in months, but rather want to modify the existing variable to measure life expectancy in months. Here are two ways to accomplish this.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{>}\StringTok{ }\KeywordTok{rm}\NormalTok{(gapminder)}
\OperatorTok{>}\StringTok{ }\KeywordTok{library}\NormalTok{(gapminder)}
\OperatorTok{>}\StringTok{ }\NormalTok{gapminder}\OperatorTok{$}\NormalTok{lifeExp[}\DecValTok{1}\OperatorTok{:}\DecValTok{5}\NormalTok{]}
\OperatorTok{>}\StringTok{ }\NormalTok{gapminder}\OperatorTok{$}\NormalTok{lifeExp <-}\StringTok{ }\NormalTok{gapminder}\OperatorTok{$}\NormalTok{lifeExp }\OperatorTok{*}\StringTok{ }\DecValTok{12}
\OperatorTok{>}\StringTok{ }\NormalTok{gapminder}\OperatorTok{$}\NormalTok{lifeExp[}\DecValTok{1}\OperatorTok{:}\DecValTok{5}\NormalTok{]}
\OperatorTok{>}\StringTok{ }\KeywordTok{rm}\NormalTok{(gapminder)}
\OperatorTok{>}\StringTok{ }\KeywordTok{library}\NormalTok{(gapminder)}
\OperatorTok{>}\StringTok{ }\NormalTok{gapminder}\OperatorTok{$}\NormalTok{lifeExp[}\DecValTok{1}\OperatorTok{:}\DecValTok{5}\NormalTok{]}
\OperatorTok{>}\StringTok{ }\NormalTok{gapminder <-}\StringTok{ }\KeywordTok{within}\NormalTok{(gapminder, lifeExp <-}\StringTok{ }\NormalTok{lifeExp }\OperatorTok{*}\StringTok{ }\DecValTok{12}\NormalTok{)}
\OperatorTok{>}\StringTok{ }\NormalTok{gapminder}\OperatorTok{$}\NormalTok{lifeExp[}\DecValTok{1}\OperatorTok{:}\DecValTok{5}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\hypertarget{rearranging-variables}{%
\section{Rearranging Variables}\label{rearranging-variables}}

Consider the full weather data set again.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{>}\StringTok{ }\NormalTok{u.weather <-}\StringTok{ "http://blue.for.msu.edu/FOR875/data/WeatherKLAN2014Full.csv"}
\OperatorTok{>}\StringTok{ }\NormalTok{WeatherKLAN2014Full <-}\StringTok{ }\KeywordTok{read.csv}\NormalTok{(u.weather, }\DataTypeTok{header=}\OtherTok{TRUE}\NormalTok{, }
\OperatorTok{+}\StringTok{                                 }\DataTypeTok{stringsAsFactors =} \OtherTok{FALSE}\NormalTok{,}
\OperatorTok{+}\StringTok{                                 }\DataTypeTok{na.string =} \StringTok{""}\NormalTok{)}
\OperatorTok{>}\StringTok{ }\KeywordTok{names}\NormalTok{(WeatherKLAN2014Full)}
\end{Highlighting}
\end{Shaded}

If we want the wind speed variables to come right after the date, we can again use subsetting.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{>}\StringTok{ }\NormalTok{WeatherKLAN2014Full <-}\StringTok{ }\NormalTok{WeatherKLAN2014Full[}\KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{17}\NormalTok{, }\DecValTok{18}\NormalTok{, }
\OperatorTok{+}\StringTok{   }\DecValTok{19}\NormalTok{, }\DecValTok{2}\OperatorTok{:}\DecValTok{16}\NormalTok{, }\DecValTok{20}\OperatorTok{:}\DecValTok{23}\NormalTok{)]}
\OperatorTok{>}\StringTok{ }\KeywordTok{names}\NormalTok{(WeatherKLAN2014Full)}
\end{Highlighting}
\end{Shaded}

\hypertarget{reshaping-data}{%
\section{Reshaping Data}\label{reshaping-data}}

A data set can be represented in several different formats. Consider a (fictitious) data set on incomes of three people during three different years. Here is one representation of the data:

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{>}\StringTok{ }\NormalTok{yearlyIncomeWide}
\end{Highlighting}
\end{Shaded}

Here is another representation of the same data:

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{>}\StringTok{ }\NormalTok{yearlyIncomeLong}
\end{Highlighting}
\end{Shaded}

For hopefully obvious reasons, the first representation is called a \emph{wide} representation of the data, and the second is called a \emph{long} representation. Each has its merits. The first representation is probably easier for people to read, while the second is often the form needed for analysis by statistical software such as R. There are of course other representations. For example the rows and columns could be interchanged to create a different wide representation, or the long representation, which currently groups data by year, could group by name instead.

Whatever the relative merits of wide and long representations of data, transforming data from wide to long or long to wide is often required. As with many tasks, there are several ways to accomplish this in R. We will focus on a library called \texttt{tidyr} written by Hadley Wickham that performs the transformations and more.

\hypertarget{tidyr}{%
\subsection{\texorpdfstring{\texttt{tidyr}}{tidyr}}\label{tidyr}}

The R library \texttt{tidyr} has functions for converting data between formats. To illustrate its use, we examine a simple data set that explores the relationship between religion and income in the United States. The data come from a Pew survey, and are used in the \texttt{tidyr} documentation to illustrate transforming data from wide to long format.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{>}\StringTok{ }\NormalTok{u.rel <-}\StringTok{ "http://blue.for.msu.edu/FOR875/data/religion2.csv"}
\OperatorTok{>}\StringTok{ }\NormalTok{religion <-}\StringTok{ }\KeywordTok{read.csv}\NormalTok{(u.rel, }\DataTypeTok{header =} \OtherTok{TRUE}\NormalTok{, }\DataTypeTok{stringsAsFactors =} \OtherTok{FALSE}\NormalTok{)}
\OperatorTok{>}\StringTok{ }\KeywordTok{head}\NormalTok{(religion)}
\end{Highlighting}
\end{Shaded}

As given, the columns include religion and income level, and there are counts for each of the combinations of religion and income level. For example, there are 27 people who are Agnostic and whose income is less than 10 thousand dollars, and there are 617 people who are Catholic and whose income is between 10 and 20 thousand dollars.

The \texttt{gather()} function can transform data from wide to long format.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{>}\StringTok{ }\KeywordTok{library}\NormalTok{(tidyr)}
\OperatorTok{>}\StringTok{ }\NormalTok{religionLong <-}\StringTok{ }\KeywordTok{gather}\NormalTok{(}\DataTypeTok{data =}\NormalTok{ religion, }\DataTypeTok{key =}\NormalTok{ IncomeLevel, }
\OperatorTok{+}\StringTok{                        }\DataTypeTok{value =}\NormalTok{ Frequency, }\DecValTok{2}\OperatorTok{:}\DecValTok{11}\NormalTok{)}
\OperatorTok{>}\StringTok{ }\KeywordTok{head}\NormalTok{(religionLong)}
\OperatorTok{>}\StringTok{ }\KeywordTok{tail}\NormalTok{(religionLong)}
\end{Highlighting}
\end{Shaded}

To use \texttt{gather()} we specified the data frame (\texttt{data\ =\ religion}), the name we want to give to the column created from the income levels (\texttt{key\ =\ IncomeLevel}), the name we want to give to the column containing the frequency values (\texttt{value\ =\ Frequency}) and the columns to gather (\texttt{2:11}).

Columns to be gathered can be specified by name also, and we can also specify which columns should be omitted using a negative sign in front of the name(s). So the following creates an equivalent data frame:

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{>}\StringTok{ }\NormalTok{religionLong <-}\StringTok{ }\KeywordTok{gather}\NormalTok{(}\DataTypeTok{data =}\NormalTok{ religion, }\DataTypeTok{key =}\NormalTok{ IncomeLevel, }
\OperatorTok{+}\StringTok{                        }\DataTypeTok{value =}\NormalTok{ Frequency, }\OperatorTok{-}\NormalTok{religion)}
\OperatorTok{>}\StringTok{ }\KeywordTok{head}\NormalTok{(religionLong)}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{>}\StringTok{ }\NormalTok{religionWide <-}\StringTok{ }\KeywordTok{spread}\NormalTok{(}\DataTypeTok{data =}\NormalTok{ religionLong, }\DataTypeTok{key =}\NormalTok{ IncomeLevel, }
\OperatorTok{+}\StringTok{   }\DataTypeTok{value =}\NormalTok{ Frequency)}
\OperatorTok{>}\StringTok{ }\KeywordTok{head}\NormalTok{(religionWide)}
\end{Highlighting}
\end{Shaded}

Here we specify the data frame (\texttt{religionLong}), the column (\texttt{IncomeLevel}) to be spread, and the column of values (\texttt{Frequency}) to be spread among the newly created columns. As can be seen, this particular call to \texttt{spread()} yields the original data frame.

\texttt{tidyr} provides two other useful functions to separate and unite variables based on some deliminator. Consider again the \texttt{yearlyIncomeWide} table. Say we want to split the \texttt{name} variable into first and last name. This can be done using the \texttt{separate()} function.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{>}\StringTok{ }\NormalTok{firstLast <-}\StringTok{ }\KeywordTok{separate}\NormalTok{(}\DataTypeTok{data =}\NormalTok{ yearlyIncomeLong, }\DataTypeTok{col =}\NormalTok{ name, }
\OperatorTok{+}\StringTok{                       }\DataTypeTok{into =} \KeywordTok{c}\NormalTok{(}\StringTok{"first"}\NormalTok{, }\StringTok{"last"}\NormalTok{), }\DataTypeTok{sep=}\StringTok{"}\CharTok{\textbackslash{}\textbackslash{}}\StringTok{s"}\NormalTok{)}
\OperatorTok{>}\StringTok{ }\KeywordTok{print}\NormalTok{(firstLast)}
\end{Highlighting}
\end{Shaded}

Now say, you're not happy with that and you want to combine the name column again, but this time separate the first and last name with a underscore. This is done using the \texttt{unite()} function.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{>}\StringTok{ }\KeywordTok{unite}\NormalTok{(firstLast, }\DataTypeTok{col =}\NormalTok{ name, first, last, }\DataTypeTok{sep =} \StringTok{"_"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\hypertarget{manipulating-data-with-dplyr-dplyr}{%
\section{\texorpdfstring{Manipulating Data with \texttt{dplyr} \#\{dplyr\}}{Manipulating Data with dplyr \#\{dplyr\}}}\label{manipulating-data-with-dplyr-dplyr}}

Much of the effort (a figure of 80\% is sometimes suggested) in data analysis is spent cleaning the data and getting it ready for analysis. Having effective tools for this task can save substantial time and effort. The R package \texttt{dplyr} written by Hadley Wickham is designed, in Hadley's words, to be ``a grammar of data manipulation, providing a consistent set of verbs that help you solve the most common data manipulation challenges.'' Casting data analysis tasks in terms of ``grammar'' should be familiar from our work with the \texttt{ggplot2} package, which was also authored by Hadley. Functions provided by \texttt{dplyr} do in fact capture key data analysis actions (i.e., verbs). These functions include

\begin{itemize}
\tightlist
\item
  \texttt{mutate()} adds new variables that are functions of existing variables
\item
  \texttt{select()} picks variables based on their names
\item
  \texttt{filter()} picks cases based on their values
\item
  \texttt{summarize()} reduces multiple values down to a single summary
\item
  \texttt{arrange()} changes the ordering of the rows.
\end{itemize}

These all combine naturally with a \texttt{group\_by()} function that allows you to perform any operation grouped by values of one or more variables. All the tasks done using \texttt{dplyr} can be accomplished using tools already covered in this text; however, \texttt{dplyr}'s functions provide a potentially more efficient and convenient framework to accomplish these tasks. RStudio provides a convenient \href{https://www.rstudio.com/wp-content/uploads/2015/02/data-wrangling-cheatsheet.pdf}{data wrangling cheat sheet} that covers many aspects of the \texttt{tidyr} and \texttt{dplyr} packages.

This somewhat long section on \texttt{dplyr} adapts the nice introduction by Jenny Bryan, available at \url{http://stat545-ubc.github.io/block010_dplyr-end-single-table.html}.

\hypertarget{improved-data-frames}{%
\subsection{Improved Data Frames}\label{improved-data-frames}}

The \texttt{dplyr} package provides two functions that offer improvements on data frames. First, \texttt{data\_frame()} is a trimmed down version of the \texttt{data.frame()} function that is somewhat more user friendly, and won't be discussed here. Second, \texttt{tbl\_df()} creates a tibble\footnote{Reminds me of \href{https://en.wikipedia.org/wiki/The_Trouble_with_Tribbles}{The Trouble with Tribbles}}. A tibble has two advantages over a data frame. First, when printing, it only prints the first ten rows and the columns that fit on the page, as well as some additional information about the table's dimension, data type of variables, and non-printed columns. Second, recall that subsetting a data frame can sometimes return a vector rather than a data frame (if only one row or column is the result of the subset), a tibble does not have this behavior. Here is an example using the \texttt{religionWide} data frame.\footnote{The text printed immediately after \texttt{library(dplyr)} means the \texttt{stats} and \texttt{base} packages, which are automatically loaded when you start R, have functions with the same name as functions in \texttt{dplyr}. So, for example, if you call the \texttt{filter()} or \texttt{lag()} functions, R will use \texttt{library(dplyr)}`s functions. Use the \texttt{::} operator to explicity identify which packages' function you want to use, e.g., if you want \texttt{stats}'s \texttt{lag()} then call \texttt{stats::lag()}.}

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{>}\StringTok{ }\KeywordTok{library}\NormalTok{(dplyr)}
\OperatorTok{>}\StringTok{ }\KeywordTok{head}\NormalTok{(religionWide)}
\OperatorTok{>}\StringTok{ }\NormalTok{religionWide[, }\DecValTok{1}\NormalTok{]}
\OperatorTok{>}\StringTok{ }\NormalTok{religionWideTbl <-}\StringTok{ }\KeywordTok{tbl_df}\NormalTok{(religionWide)}
\OperatorTok{>}\StringTok{ }\KeywordTok{head}\NormalTok{(religionWideTbl)}
\OperatorTok{>}\StringTok{ }\NormalTok{religionWideTbl[, }\DecValTok{1}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

As seen above, note that once the data frame is reduced to one dimension by subsetting to one column, it is no longer a data frame and has been \emph{simplified} to a vector. This might not seem like a big deal; however, it can be very frustrating and potentially break your code when you expect an object to behave like a data frame and it doesn't because it's now a vector. Alternatively, once we convert \texttt{religionWide} to a \texttt{tbl\_df} via the \texttt{tbl\_df()} function the object remains a data frame even when subsetting down to one dimension (there is no automatic simplification). Converting data frames using \texttt{tbl\_df()} is not required for using \texttt{dplyr} but is convenient. Also, it is important to note that \texttt{tbl\_df} is simply a wrapper around a data frame that provides some additional behaviors. The newly formed \texttt{tbl\_df} object will still behave like a data frame (because it technically still is a data frame) but will have some added niceties (some of which are illustrated below).

\hypertarget{filtering-data-by-row}{%
\subsection{Filtering Data by Row}\label{filtering-data-by-row}}

Recall the \texttt{gapminder} data. These data are available in tab-separated format in \texttt{gapminder.tsv}, and can be read in using \texttt{read.delim()} (or the related read functions described previously). The \texttt{read.delim()} function defaults to \texttt{header\ =\ TRUE} so this doesn't need to be specified explicitly. In this section we will be working with the \texttt{gapminder} data often, so we will use a short name for the data frame to save typing.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{>}\StringTok{ }\NormalTok{u.gm <-}\StringTok{ "http://blue.for.msu.edu/FOR875/data/gapminder.tsv"}
\OperatorTok{>}\StringTok{ }\NormalTok{gm <-}\StringTok{ }\KeywordTok{read.delim}\NormalTok{(u.gm)}
\OperatorTok{>}\StringTok{ }\NormalTok{gm <-}\StringTok{ }\KeywordTok{tbl_df}\NormalTok{(gm)}
\OperatorTok{>}\StringTok{ }\KeywordTok{str}\NormalTok{(gm)}
\OperatorTok{>}\StringTok{ }\KeywordTok{head}\NormalTok{(gm)}
\end{Highlighting}
\end{Shaded}

Filtering helps us to examine subsets of the data such as data from a particular country, from several specified countries, from certain years, from countries with certain populations, etc. Some examples:

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{>}\StringTok{ }\KeywordTok{filter}\NormalTok{(gm, country }\OperatorTok{==}\StringTok{ "Brazil"}\NormalTok{)}
\OperatorTok{>}\StringTok{ }\KeywordTok{filter}\NormalTok{(gm, country }\OperatorTok{%in%}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"Brazil"}\NormalTok{, }\StringTok{"Mexico"}\NormalTok{))}
\OperatorTok{>}\StringTok{ }\KeywordTok{filter}\NormalTok{(gm, country }\OperatorTok{%in%}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"Brazil"}\NormalTok{, }\StringTok{"Mexico"}\NormalTok{) }\OperatorTok{&}\StringTok{ }\NormalTok{year }\OperatorTok{%in%}\StringTok{ }
\OperatorTok{+}\StringTok{   }\KeywordTok{c}\NormalTok{(}\DecValTok{1952}\NormalTok{, }\DecValTok{1972}\NormalTok{))}
\OperatorTok{>}\StringTok{ }\KeywordTok{filter}\NormalTok{(gm, pop }\OperatorTok{>}\StringTok{ }\FloatTok{3e+08}\NormalTok{)}
\OperatorTok{>}\StringTok{ }\KeywordTok{filter}\NormalTok{(gm, pop }\OperatorTok{>}\StringTok{ }\FloatTok{3e+08} \OperatorTok{&}\StringTok{ }\NormalTok{year }\OperatorTok{==}\StringTok{ }\DecValTok{2007}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Notice the full results are not printed. For example, when we asked for the data for Brazil and Mexico, only the first ten rows were printed. This is an effect of using the \texttt{tbl\_df()} function. Of course if we wanted to analyze the results (as we will below) the full set of data would be available.

\hypertarget{selecting-variables-by-column}{%
\subsection{Selecting variables by column}\label{selecting-variables-by-column}}

Continuing with the \texttt{gapminder} data, another common task is to restrict attention to some subset of variables in the data set. The \texttt{select()} function does this.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{>}\StringTok{ }\NormalTok{dplyr}\OperatorTok{::}\KeywordTok{select}\NormalTok{(gm, country, year, lifeExp)}
\OperatorTok{>}\StringTok{ }\NormalTok{dplyr}\OperatorTok{::}\KeywordTok{select}\NormalTok{(gm, }\DecValTok{2}\OperatorTok{:}\DecValTok{4}\NormalTok{)}
\OperatorTok{>}\StringTok{ }\NormalTok{dplyr}\OperatorTok{::}\KeywordTok{select}\NormalTok{(gm, }\OperatorTok{-}\KeywordTok{c}\NormalTok{(}\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{4}\NormalTok{))}
\OperatorTok{>}\StringTok{ }\NormalTok{dplyr}\OperatorTok{::}\KeywordTok{select}\NormalTok{(gm, }\KeywordTok{starts_with}\NormalTok{(}\StringTok{"c"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

Notice a few things. Variables can be selected by name or column number. As usual, a negative sign tells R to leave something out. And there are special functions such as \texttt{starts\_with} that provide ways to match part of a variable's name.

\hypertarget{pipes}{%
\subsection{Pipes}\label{pipes}}

Consider selecting the country, year, and population for countries in Asia or Europe. One possibility is to nest a \texttt{filter()} function inside a \texttt{select()} function.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{>}\StringTok{ }\NormalTok{dplyr}\OperatorTok{::}\KeywordTok{select}\NormalTok{(}\KeywordTok{filter}\NormalTok{(gm, continent }\OperatorTok{%in%}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"Asia"}\NormalTok{, }\StringTok{"Europe"}\NormalTok{)), }
\OperatorTok{+}\StringTok{   }\NormalTok{country, year, pop)}
\end{Highlighting}
\end{Shaded}

Even a two-step process like this becomes hard to follow in this nested form, and often we will want to perform more than two operations. There is a nice feature in \texttt{dplyr} that allows us to ``feed'' results of one function into the first argument of a subsequent function. Another way of saying this is that we are ``piping'' the results into another function. The \texttt{\%\textgreater{}\%} operator does the piping. Here we again restrict attention to country, year, and population for countries in Asia or Europe\footnote{Notice the indentation used in the code. This is not necessary, as the code could be all on one line, but I often find it easier to read in this more organized format}.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{>}\StringTok{ }\NormalTok{gm }\OperatorTok{%>%}\StringTok{ }
\OperatorTok{+}\StringTok{   }\KeywordTok{filter}\NormalTok{(continent }\OperatorTok{%in%}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"Asia"}\NormalTok{, }\StringTok{"Europe"}\NormalTok{)) }\OperatorTok{%>%}\StringTok{ }
\OperatorTok{+}\StringTok{   }\NormalTok{dplyr}\OperatorTok{::}\KeywordTok{select}\NormalTok{(country, year, pop)}
\end{Highlighting}
\end{Shaded}

It can help to think of \texttt{\%\textgreater{}\%} as representing the word ``then''. The above can be read as, ``Start with the data frame \texttt{gm} \emph{then} filter it to select data from the continents Asia and Europe \emph{then} select the variables country, year, and population from these data''.

The pipe operator \texttt{\%\textgreater{}\%} is not restricted to functions in \texttt{dplyr}. In fact the pipe operator itself was introduced in another package called \texttt{magrittr}, but is included in \texttt{dplyr} as a convenience.

\hypertarget{arranging-data-by-row}{%
\subsection{Arranging Data by Row}\label{arranging-data-by-row}}

By default the \texttt{gapminder} data are arranged by country and then by year.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{>}\StringTok{ }\KeywordTok{head}\NormalTok{(gm, }\DecValTok{15}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Possibly arranging the data by year and then country would be desired. The \texttt{arrange()} function makes this easy. We will again use pipes.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{>}\StringTok{ }\NormalTok{gm }\OperatorTok{%>%}\StringTok{ }\KeywordTok{arrange}\NormalTok{(year, country)}
\end{Highlighting}
\end{Shaded}

How about the data for Rwanda, arranged in order of life expectancy.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{>}\StringTok{ }\NormalTok{gm }\OperatorTok{%>%}\StringTok{ }
\OperatorTok{+}\StringTok{   }\KeywordTok{filter}\NormalTok{(country }\OperatorTok{==}\StringTok{ "Rwanda"}\NormalTok{) }\OperatorTok{%>%}\StringTok{ }
\OperatorTok{+}\StringTok{   }\KeywordTok{arrange}\NormalTok{(lifeExp)}
\end{Highlighting}
\end{Shaded}

Possibly we want these data to be in decreasing (descending) order. Here, \texttt{desc()} is one of many \texttt{dplyr} helper functions.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{>}\StringTok{ }\NormalTok{gm }\OperatorTok{%>%}\StringTok{ }
\OperatorTok{+}\StringTok{   }\KeywordTok{filter}\NormalTok{(country }\OperatorTok{==}\StringTok{ "Rwanda"}\NormalTok{) }\OperatorTok{%>%}\StringTok{ }
\OperatorTok{+}\StringTok{   }\KeywordTok{arrange}\NormalTok{(}\KeywordTok{desc}\NormalTok{(lifeExp))}
\end{Highlighting}
\end{Shaded}

Possibly we want to include only the year and life expectancy, to make the message more stark.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{>}\StringTok{ }\NormalTok{gm }\OperatorTok{%>%}\StringTok{ }
\OperatorTok{+}\StringTok{   }\KeywordTok{filter}\NormalTok{(country }\OperatorTok{==}\StringTok{ "Rwanda"}\NormalTok{) }\OperatorTok{%>%}\StringTok{ }
\OperatorTok{+}\StringTok{   }\NormalTok{dplyr}\OperatorTok{::}\KeywordTok{select}\NormalTok{(year, lifeExp) }\OperatorTok{%>%}\StringTok{ }
\OperatorTok{+}\StringTok{   }\KeywordTok{arrange}\NormalTok{(}\KeywordTok{desc}\NormalTok{(lifeExp)) }
\end{Highlighting}
\end{Shaded}

For analyzing data in R, the order shouldn't matter. But for presentation to human eyes, the order is important.

\hypertarget{renaming-variables}{%
\subsection{Renaming Variables}\label{renaming-variables}}

The \texttt{dplyr} package has a \texttt{rename} function that makes renaming variables in a data frame quite easy.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{>}\StringTok{ }\NormalTok{gm <-}\StringTok{ }\KeywordTok{rename}\NormalTok{(gm, }\DataTypeTok{population =}\NormalTok{ pop)}
\OperatorTok{>}\StringTok{ }\KeywordTok{head}\NormalTok{(gm)}
\end{Highlighting}
\end{Shaded}

\hypertarget{data-summaries-and-grouping}{%
\subsection{Data Summaries and Grouping}\label{data-summaries-and-grouping}}

The \texttt{summarize()} function computes summary statistics using user provided functions for one or more columns of data in a data frame.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{>}\StringTok{ }\KeywordTok{summarize}\NormalTok{(gm, }\DataTypeTok{meanpop =} \KeywordTok{mean}\NormalTok{(population), }\DataTypeTok{medpop =} \KeywordTok{median}\NormalTok{(population))}
\OperatorTok{>}\StringTok{ }\CommentTok{##or}
\ErrorTok{>}\StringTok{ }\NormalTok{gm }\OperatorTok{%>%}\StringTok{ }
\OperatorTok{+}\StringTok{   }\KeywordTok{summarize}\NormalTok{(}\DataTypeTok{meanpop =} \KeywordTok{mean}\NormalTok{(population), }\DataTypeTok{medpop =} \KeywordTok{median}\NormalTok{(population))}
\end{Highlighting}
\end{Shaded}

Often we want summaries for specific components of the data. For example, we might want the median life expectancy for each continent separately. One option is subsetting:

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{>}\StringTok{ }\KeywordTok{median}\NormalTok{(gm}\OperatorTok{$}\NormalTok{lifeExp[gm}\OperatorTok{$}\NormalTok{continent }\OperatorTok{==}\StringTok{ "Africa"}\NormalTok{])}
\OperatorTok{>}\StringTok{ }\KeywordTok{median}\NormalTok{(gm}\OperatorTok{$}\NormalTok{lifeExp[gm}\OperatorTok{$}\NormalTok{continent }\OperatorTok{==}\StringTok{ "Asia"}\NormalTok{])}
\OperatorTok{>}\StringTok{ }\KeywordTok{median}\NormalTok{(gm}\OperatorTok{$}\NormalTok{lifeExp[gm}\OperatorTok{$}\NormalTok{continent }\OperatorTok{==}\StringTok{ "Europe"}\NormalTok{])}
\OperatorTok{>}\StringTok{ }\KeywordTok{median}\NormalTok{(gm}\OperatorTok{$}\NormalTok{lifeExp[gm}\OperatorTok{$}\NormalTok{continent }\OperatorTok{==}\StringTok{ "Americas"}\NormalTok{])}
\OperatorTok{>}\StringTok{ }\KeywordTok{median}\NormalTok{(gm}\OperatorTok{$}\NormalTok{lifeExp[gm}\OperatorTok{$}\NormalTok{continent }\OperatorTok{==}\StringTok{ "Oceania"}\NormalTok{])}
\end{Highlighting}
\end{Shaded}

The \texttt{group\_by()} function makes this easier, and makes the output more useful.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{>}\StringTok{ }\NormalTok{gm }\OperatorTok{%>%}\StringTok{ }
\OperatorTok{+}\StringTok{   }\KeywordTok{group_by}\NormalTok{(continent) }\OperatorTok{%>%}\StringTok{ }
\OperatorTok{+}\StringTok{   }\KeywordTok{summarize}\NormalTok{(}\DataTypeTok{medLifeExp =} \KeywordTok{median}\NormalTok{(lifeExp)) }
\end{Highlighting}
\end{Shaded}

Or if we want the results ordered by the median life expectancy:

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{>}\StringTok{ }\NormalTok{gm }\OperatorTok{%>%}\StringTok{ }
\OperatorTok{+}\StringTok{   }\KeywordTok{group_by}\NormalTok{(continent) }\OperatorTok{%>%}\StringTok{ }
\OperatorTok{+}\StringTok{   }\KeywordTok{summarize}\NormalTok{(}\DataTypeTok{medLifeExp =} \KeywordTok{median}\NormalTok{(lifeExp)) }\OperatorTok{%>%}\StringTok{ }
\OperatorTok{+}\StringTok{   }\KeywordTok{arrange}\NormalTok{(medLifeExp)}
\end{Highlighting}
\end{Shaded}

As another example, we calculate the number of observations we have per continent (using the \texttt{n()} helper function), and then, among continents, how many distinct countries are represented (using \texttt{n\_distinct()}).

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{>}\StringTok{ }\NormalTok{gm }\OperatorTok{%>%}\StringTok{ }
\OperatorTok{+}\StringTok{   }\KeywordTok{group_by}\NormalTok{(continent) }\OperatorTok{%>%}\StringTok{ }
\OperatorTok{+}\StringTok{   }\KeywordTok{summarize}\NormalTok{(}\DataTypeTok{numObs =} \KeywordTok{n}\NormalTok{())}
\OperatorTok{>}\StringTok{ }\NormalTok{gm }\OperatorTok{%>%}
\OperatorTok{+}\StringTok{   }\KeywordTok{group_by}\NormalTok{(continent) }\OperatorTok{%>%}
\OperatorTok{+}\StringTok{   }\KeywordTok{summarize}\NormalTok{(}\DataTypeTok{n_obs =} \KeywordTok{n}\NormalTok{(), }\DataTypeTok{n_countries =} \KeywordTok{n_distinct}\NormalTok{(country))}
\end{Highlighting}
\end{Shaded}

Here is a bit more involved example that calculates the minimum and maximum life expectancies for countries in Africa by year.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{>}\StringTok{ }\NormalTok{gm }\OperatorTok{%>%}
\OperatorTok{+}\StringTok{   }\KeywordTok{filter}\NormalTok{(continent }\OperatorTok{==}\StringTok{ "Africa"}\NormalTok{) }\OperatorTok{%>%}
\OperatorTok{+}\StringTok{   }\KeywordTok{group_by}\NormalTok{(year) }\OperatorTok{%>%}
\OperatorTok{+}\StringTok{   }\KeywordTok{summarize}\NormalTok{(}\DataTypeTok{min_lifeExp =} \KeywordTok{min}\NormalTok{(lifeExp), }\DataTypeTok{max_lifeExp =} \KeywordTok{max}\NormalTok{(lifeExp))}
\end{Highlighting}
\end{Shaded}

This is interesting, but the results don't include the countries that achieved the minimum and maximum life expectancies. Here is one way to achieve that. We will start with the minimum life expectancy. Note the rank of the minimum value will be 1.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{>}\StringTok{ }\NormalTok{gm }\OperatorTok{%>%}\StringTok{ }
\OperatorTok{+}\StringTok{   }\NormalTok{dplyr}\OperatorTok{::}\KeywordTok{select}\NormalTok{(country, continent, year, lifeExp) }\OperatorTok{%>%}\StringTok{ }
\OperatorTok{+}\StringTok{   }\KeywordTok{group_by}\NormalTok{(year) }\OperatorTok{%>%}\StringTok{ }
\OperatorTok{+}\StringTok{   }\KeywordTok{arrange}\NormalTok{(year) }\OperatorTok{%>%}\StringTok{ }
\OperatorTok{+}\StringTok{   }\KeywordTok{filter}\NormalTok{(}\KeywordTok{rank}\NormalTok{(lifeExp) }\OperatorTok{==}\StringTok{ }\DecValTok{1}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Next we add the maximum life expectancy. Here we need to better understand the \texttt{desc()} function, which will transform a vector into a numeric vector which will be sorted in descending order. Here are some examples.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{>}\StringTok{ }\KeywordTok{desc}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{5}\NormalTok{)}
\OperatorTok{>}\StringTok{ }\KeywordTok{desc}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{6}\NormalTok{, }\DecValTok{-4}\NormalTok{))}
\OperatorTok{>}\StringTok{ }\KeywordTok{desc}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\StringTok{"a"}\NormalTok{, }\StringTok{"c"}\NormalTok{, }\StringTok{"b"}\NormalTok{, }\StringTok{"w"}\NormalTok{, }\StringTok{"e"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

We now use this to extract the maximum life expectancy. Recall that \texttt{\textbar{}} represents ``or''. Also by default only the first few rows of a \texttt{tbl\_df} object will be printed. To see all the rows we pipe the output to \texttt{print(n\ =\ 24)} to ask for all 24 rows to be printed.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{>}\StringTok{ }\NormalTok{gm }\OperatorTok{%>%}\StringTok{ }
\OperatorTok{+}\StringTok{   }\NormalTok{dplyr}\OperatorTok{::}\KeywordTok{select}\NormalTok{(country, continent, year, lifeExp) }\OperatorTok{%>%}\StringTok{ }
\OperatorTok{+}\StringTok{   }\KeywordTok{group_by}\NormalTok{(year) }\OperatorTok{%>%}\StringTok{ }
\OperatorTok{+}\StringTok{   }\KeywordTok{arrange}\NormalTok{(year) }\OperatorTok{%>%}\StringTok{ }
\OperatorTok{+}\StringTok{   }\KeywordTok{filter}\NormalTok{(}\KeywordTok{rank}\NormalTok{(lifeExp) }\OperatorTok{==}\StringTok{ }\DecValTok{1} \OperatorTok{|}\StringTok{ }\KeywordTok{rank}\NormalTok{(}\KeywordTok{desc}\NormalTok{(lifeExp)) }\OperatorTok{==}\StringTok{ }\DecValTok{1}\NormalTok{) }\OperatorTok{%>%}\StringTok{ }
\OperatorTok{+}\StringTok{   }\KeywordTok{print}\NormalTok{(}\DataTypeTok{n=}\DecValTok{24}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\hypertarget{creating-new-variables}{%
\subsection{Creating New Variables}\label{creating-new-variables}}

The \texttt{\$} notation provides a simple way to create new variables in a data frame. The \texttt{mutate()} function provides another, sometimes cleaner way to do this. We will use \texttt{mutate()} along with the \texttt{lag()} function to investigate changes in life expectancy over five years for the \texttt{gapminder} data. We'll do this in a few steps. First, we create a variable that measures the change in life expectancy and remove the population and GDP variables that are not of interest. We have to be careful to first group by country, since we want to calculate the change in life expectancy by country.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{>}\StringTok{ }\NormalTok{gm }\OperatorTok{%>%}\StringTok{ }
\OperatorTok{+}\StringTok{   }\KeywordTok{group_by}\NormalTok{(country) }\OperatorTok{%>%}\StringTok{ }
\OperatorTok{+}\StringTok{   }\KeywordTok{mutate}\NormalTok{(}\DataTypeTok{changeLifeExp =}\NormalTok{ lifeExp }\OperatorTok{-}\StringTok{ }\KeywordTok{lag}\NormalTok{(lifeExp, }\DataTypeTok{order_by =}\NormalTok{ year)) }\OperatorTok{%>%}\StringTok{ }
\OperatorTok{+}\StringTok{   }\NormalTok{dplyr}\OperatorTok{::}\KeywordTok{select}\NormalTok{(}\OperatorTok{-}\KeywordTok{c}\NormalTok{(population, gdpPercap))}
\end{Highlighting}
\end{Shaded}

Next, summarize by computing the largest drop in life expectancy.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{>}\StringTok{ }\NormalTok{gm }\OperatorTok{%>%}\StringTok{ }
\OperatorTok{+}\StringTok{   }\KeywordTok{group_by}\NormalTok{(country) }\OperatorTok{%>%}\StringTok{ }
\OperatorTok{+}\StringTok{   }\KeywordTok{mutate}\NormalTok{(}\DataTypeTok{changeLifeExp =}\NormalTok{ lifeExp }\OperatorTok{-}\StringTok{ }\KeywordTok{lag}\NormalTok{(lifeExp, }\DataTypeTok{order_by =}\NormalTok{ year)) }\OperatorTok{%>%}\StringTok{ }
\OperatorTok{+}\StringTok{   }\NormalTok{dplyr}\OperatorTok{::}\KeywordTok{select}\NormalTok{(}\OperatorTok{-}\KeywordTok{c}\NormalTok{(population, gdpPercap)) }\OperatorTok{%>%}\StringTok{ }
\OperatorTok{+}\StringTok{   }\KeywordTok{summarize}\NormalTok{(}\DataTypeTok{largestDropLifeExp =} \KeywordTok{min}\NormalTok{(changeLifeExp))}
\end{Highlighting}
\end{Shaded}

Oops. We forgot that since we don't have data from before 1952, the first drop will be \texttt{NA}. Let's try again.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{>}\StringTok{ }\NormalTok{gm }\OperatorTok{%>%}\StringTok{ }
\OperatorTok{+}\StringTok{   }\KeywordTok{group_by}\NormalTok{(country) }\OperatorTok{%>%}\StringTok{ }
\OperatorTok{+}\StringTok{   }\KeywordTok{mutate}\NormalTok{(}\DataTypeTok{changeLifeExp =}\NormalTok{ lifeExp }\OperatorTok{-}\StringTok{ }\KeywordTok{lag}\NormalTok{(lifeExp, }\DataTypeTok{order_by =}\NormalTok{ year)) }\OperatorTok{%>%}\StringTok{ }
\OperatorTok{+}\StringTok{   }\KeywordTok{select}\NormalTok{(}\OperatorTok{-}\KeywordTok{c}\NormalTok{(population, gdpPercap)) }\OperatorTok{%>%}\StringTok{ }
\OperatorTok{+}\StringTok{   }\KeywordTok{summarize}\NormalTok{(}\DataTypeTok{largestDropLifeExp =} \KeywordTok{min}\NormalTok{(changeLifeExp, }\DataTypeTok{na.rm =} \OtherTok{TRUE}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

That's not quite what we wanted. We could arrange the results by the life expectancy drop, but it would be good to have both the continent and year printed out also. So we'll take a slightly different approach, by arranging the results in increasing order.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{>}\StringTok{ }\NormalTok{gm }\OperatorTok{%>%}\StringTok{ }
\OperatorTok{+}\StringTok{   }\KeywordTok{group_by}\NormalTok{(country) }\OperatorTok{%>%}\StringTok{ }
\OperatorTok{+}\StringTok{   }\KeywordTok{mutate}\NormalTok{(}\DataTypeTok{changeLifeExp =}\NormalTok{ lifeExp }\OperatorTok{-}\StringTok{ }\KeywordTok{lag}\NormalTok{(lifeExp, }\DataTypeTok{order_by =}\NormalTok{ year)) }\OperatorTok{%>%}\StringTok{ }
\OperatorTok{+}\StringTok{   }\NormalTok{dplyr}\OperatorTok{::}\KeywordTok{select}\NormalTok{(}\OperatorTok{-}\KeywordTok{c}\NormalTok{(population, gdpPercap)) }\OperatorTok{%>%}\StringTok{ }
\OperatorTok{+}\StringTok{   }\KeywordTok{arrange}\NormalTok{(changeLifeExp)}
\end{Highlighting}
\end{Shaded}

That's still not quite right. Because the data are grouped by country, R did the ordering within group. If we want to see the largest drops overall, we need to remove the grouping.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{>}\StringTok{ }\NormalTok{gm }\OperatorTok{%>%}\StringTok{ }\KeywordTok{group_by}\NormalTok{(country) }\OperatorTok{%>%}\StringTok{ }\KeywordTok{mutate}\NormalTok{(}\DataTypeTok{changeLifeExp =}\NormalTok{ lifeExp }\OperatorTok{-}\StringTok{ }
\OperatorTok{+}\StringTok{   }\KeywordTok{lag}\NormalTok{(lifeExp, }\DataTypeTok{order_by =}\NormalTok{ year)) }\OperatorTok{%>%}\StringTok{ }\NormalTok{dplyr}\OperatorTok{::}\KeywordTok{select}\NormalTok{(}\OperatorTok{-}\KeywordTok{c}\NormalTok{(population, }
\OperatorTok{+}\StringTok{   }\NormalTok{gdpPercap)) }\OperatorTok{%>%}\StringTok{ }\KeywordTok{ungroup}\NormalTok{() }\OperatorTok{%>%}\StringTok{ }\KeywordTok{arrange}\NormalTok{(changeLifeExp) }\OperatorTok{%>%}\StringTok{ }
\OperatorTok{+}\StringTok{   }\KeywordTok{print}\NormalTok{(}\DataTypeTok{n =} \DecValTok{20}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\hypertarget{practice-exercises-3}{%
\section{Practice Exercises}\label{practice-exercises-3}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  In Section \ref{apply} we computed the standard deviation across all numeric columns using the following line of code:
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{>}\StringTok{ }\KeywordTok{apply}\NormalTok{(WeatherKLAN2014Full[, }\KeywordTok{c}\NormalTok{(}\DecValTok{2}\OperatorTok{:}\DecValTok{19}\NormalTok{, }\DecValTok{21}\NormalTok{, }\DecValTok{23}\NormalTok{)], }\DecValTok{2}\NormalTok{, sd)}
\end{Highlighting}
\end{Shaded}

Notice the output value of \texttt{NA} for the column \texttt{Max.Gust.SpeedMPH}. Why does this happen? Figure out a way to make the \texttt{apply()} function return a numeric value for this column. \emph{Hint}: check out the \texttt{sd()} definition.

\hypertarget{homework-3}{%
\section{Homework}\label{homework-3}}

\textbf{Exercise 7} Learning objectives: introduce \texttt{with()}, \texttt{tapply()}, and \texttt{cut()} functions; summarize data using the \texttt{table()} function with logical subsetting; practice using factor data types.

\textbf{Exercise 8} Learning objectives: work with messy data; import data from an external spreadsheet; practice using functions in \texttt{tidyr} and \texttt{ggplot2}.\}

\textbf{Exercise 9} \{Learning objectives: work with several key \textbf{dplyr} functions; manipulate data frames (actually tibbles); summarize and visualize data from large data files.\}

\hypertarget{functions-and-programming}{%
\chapter{Functions and Programming}\label{functions-and-programming}}

We have been working with a wide variety of R functions, from simple functions such as \texttt{mean()} and \texttt{sd()} to more complex functions such as \texttt{ggplot()} and \texttt{apply()}. Gaining a better understanding of existing functions and the ability to write your own functions dramatically increases what we can do with R. Learning about R's programming capabilities is an important step in gaining facility with functions.

\hypertarget{r-functions}{%
\section{R Functions}\label{r-functions}}

Data on the yield (pounds per acre) of two types of corn seeds (regular and kiln dried) were collected. Each of the 11 plots of land was split into two subplots, and one of the subplots was planted in regular corn while the other was planted in kiln dried corn. These data were analyzed in a famous paper authored by William Gosset. Here are the data.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{>}\StringTok{ }\NormalTok{u.corn <-}\StringTok{ "http://blue.for.msu.edu/FOR875/data/corn.csv"}
\OperatorTok{>}\StringTok{ }\NormalTok{corn <-}\StringTok{ }\KeywordTok{read.csv}\NormalTok{(u.corn, }\DataTypeTok{header =} \OtherTok{TRUE}\NormalTok{)}
\OperatorTok{>}\StringTok{ }\NormalTok{corn}
\end{Highlighting}
\end{Shaded}

A paired t test, or a confidence interval for the mean difference, may be used to assess the difference in yield between the two varieties. Of course R has a function \texttt{t.test} that performs a paired t test and computes a confidence interval, but we will perform the test without using that function. We will focus for now on testing the hypotheses \(H_0\colon \mu_d = 0\) versus \(H_a\colon \mu_d \neq 0\) and on a two-sided confidence interval for \(\mu_d\). Here \(\mu_d\) represents the population mean difference.

The paired \(t\) statistic is defined by
\begin{equation}
t = \frac{\overline d}{S_d/\sqrt{n}}
\end{equation}

where \(\overline d\) is the mean of the differences, \(S_d\) is the standard deviation of the differences, and \(n\) is the sample size. The p-value is twice the area to the right of \(|t_{\text{obs}}|\), where \(t_{\text{obs}}\) is the observed \(t\) statistic, and a confidence interval is given by
\begin{equation}
\overline d \pm t^* (S_d/\sqrt{n}).
\end{equation}

Here \(t^*\) is an appropriate quantile of a \(t\) distribution with \(n-1\) degrees of freedom.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{>}\StringTok{ }\NormalTok{dbar <-}\StringTok{ }\KeywordTok{mean}\NormalTok{(corn}\OperatorTok{$}\NormalTok{kiln_dried }\OperatorTok{-}\StringTok{ }\NormalTok{corn}\OperatorTok{$}\NormalTok{regular)}
\OperatorTok{>}\StringTok{ }\NormalTok{n <-}\StringTok{ }\KeywordTok{length}\NormalTok{(corn}\OperatorTok{$}\NormalTok{regular)}
\OperatorTok{>}\StringTok{ }\NormalTok{S_d <-}\StringTok{ }\KeywordTok{sd}\NormalTok{(corn}\OperatorTok{$}\NormalTok{kiln_dried }\OperatorTok{-}\StringTok{ }\NormalTok{corn}\OperatorTok{$}\NormalTok{regular)}
\OperatorTok{>}\StringTok{ }\NormalTok{t_obs <-}\StringTok{ }\NormalTok{dbar}\OperatorTok{/}\NormalTok{(S_d}\OperatorTok{/}\KeywordTok{sqrt}\NormalTok{(n))}
\OperatorTok{>}\StringTok{ }\NormalTok{t_obs}
\OperatorTok{>}\StringTok{ }
\ErrorTok{>}\StringTok{ }\NormalTok{pval <-}\StringTok{ }\DecValTok{2} \OperatorTok{*}\StringTok{ }\NormalTok{(}\DecValTok{1} \OperatorTok{-}\StringTok{ }\KeywordTok{pt}\NormalTok{(}\KeywordTok{abs}\NormalTok{(t_obs), n }\OperatorTok{-}\StringTok{ }\DecValTok{1}\NormalTok{))}
\OperatorTok{>}\StringTok{ }\NormalTok{pval}
\OperatorTok{>}\StringTok{ }
\ErrorTok{>}\StringTok{ }\NormalTok{margin <-}\StringTok{ }\KeywordTok{qt}\NormalTok{(}\FloatTok{0.975}\NormalTok{, n }\OperatorTok{-}\StringTok{ }\DecValTok{1}\NormalTok{) }\OperatorTok{*}\StringTok{ }\NormalTok{(S_d}\OperatorTok{/}\KeywordTok{sqrt}\NormalTok{(n))}
\OperatorTok{>}\StringTok{ }\NormalTok{lcl <-}\StringTok{ }\NormalTok{dbar }\OperatorTok{-}\StringTok{ }\NormalTok{margin}
\OperatorTok{>}\StringTok{ }\NormalTok{ucl <-}\StringTok{ }\NormalTok{dbar }\OperatorTok{+}\StringTok{ }\NormalTok{margin}
\OperatorTok{>}\StringTok{ }\NormalTok{lcl}
\OperatorTok{>}\StringTok{ }\NormalTok{ucl}
\end{Highlighting}
\end{Shaded}

With a few lines of R code we have calculated the t statistic, the p-value, and the confidence interval. Since paired t tests are pretty common, however, it would be helpful to automate this procedure. One obvious reason is to save time and effort, but another important reason is to avoid mistakes. It would be easy to make a mistake (e.g., using \(n\) instead of \(n-1\) as the degrees of freedom) when repeating the above computations.

Here is a first basic function which automates the computation.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{>}\StringTok{ }\NormalTok{paired_t <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x1, x2) \{}
\OperatorTok{+}\StringTok{   }\NormalTok{n <-}\StringTok{ }\KeywordTok{length}\NormalTok{(x1)}
\OperatorTok{+}\StringTok{   }\NormalTok{dbar <-}\StringTok{ }\KeywordTok{mean}\NormalTok{(x1 }\OperatorTok{-}\StringTok{ }\NormalTok{x2)}
\OperatorTok{+}\StringTok{   }\NormalTok{s_d <-}\StringTok{ }\KeywordTok{sd}\NormalTok{(x1 }\OperatorTok{-}\StringTok{ }\NormalTok{x2)}
\OperatorTok{+}\StringTok{   }\NormalTok{tstat <-}\StringTok{ }\NormalTok{dbar}\OperatorTok{/}\NormalTok{(s_d}\OperatorTok{/}\KeywordTok{sqrt}\NormalTok{(n))}
\OperatorTok{+}\StringTok{   }\NormalTok{pval <-}\StringTok{ }\DecValTok{2} \OperatorTok{*}\StringTok{ }\NormalTok{(}\DecValTok{1} \OperatorTok{-}\StringTok{ }\KeywordTok{pt}\NormalTok{(}\KeywordTok{abs}\NormalTok{(tstat), n }\OperatorTok{-}\StringTok{ }\DecValTok{1}\NormalTok{))}
\OperatorTok{+}\StringTok{   }\NormalTok{margin <-}\StringTok{ }\KeywordTok{qt}\NormalTok{(}\FloatTok{0.975}\NormalTok{, n }\OperatorTok{-}\StringTok{ }\DecValTok{1}\NormalTok{) }\OperatorTok{*}\StringTok{ }\NormalTok{s_d}\OperatorTok{/}\KeywordTok{sqrt}\NormalTok{(n)}
\OperatorTok{+}\StringTok{   }\NormalTok{lcl <-}\StringTok{ }\NormalTok{dbar }\OperatorTok{-}\StringTok{ }\NormalTok{margin}
\OperatorTok{+}\StringTok{   }\NormalTok{ucl <-}\StringTok{ }\NormalTok{dbar }\OperatorTok{+}\StringTok{ }\NormalTok{margin}
\OperatorTok{+}\StringTok{   }\KeywordTok{return}\NormalTok{(}\KeywordTok{list}\NormalTok{(}\DataTypeTok{tstat =}\NormalTok{ tstat, }\DataTypeTok{pval =}\NormalTok{ pval, }\DataTypeTok{lcl =}\NormalTok{ lcl, }\DataTypeTok{ucl =}\NormalTok{ ucl))}
\OperatorTok{+}\StringTok{ }\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

And here is the function in action

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{>}\StringTok{ }\KeywordTok{paired_t}\NormalTok{(}\DataTypeTok{x1 =}\NormalTok{ corn}\OperatorTok{$}\NormalTok{kiln_dried, }\DataTypeTok{x2 =}\NormalTok{ corn}\OperatorTok{$}\NormalTok{regular)}
\end{Highlighting}
\end{Shaded}

An explanation and comments on the function are in order.

\begin{itemize}
\tightlist
\item
  \texttt{paired\_t\ \textless{}-\ function(x1,\ x2)} assigns a function of two variables, \texttt{x1} and \texttt{x2}, to an R object called \texttt{paired\_t}.
\item
  The \emph{compound expression}, i.e., the code that makes up the body of the function, is enclosed in curly braces \texttt{\{\}}.
\item
  \texttt{return(list(tstat\ =\ tstat,\ pval\ =\ pval,\ lcl=lcl,\ ucl=ucl))} indicates the object(s) returned by the function. In this case the function returns a list with four components.
\item
  The body of the function basically mimics the computations required to compute the t statistic, the p-value, and the confidence interval.
\item
  Several objects such as \texttt{n} and \texttt{dbar} are created in the body of the function. These objects are NOT available outside the function. We will discuss this further when we cover environments and scope in R.
\end{itemize}

Our function has automated the basic calculations. But it is still somewhat limited in usefulness. For example, it only computes a 95\% confidence interval, while a user may want a different confidence level. And the function only performs a two-sided test, while a user may want a one-sided procedure. We modify the function slightly to allow the user to specify the confidence level next.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{>}\StringTok{ }\NormalTok{paired_t <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x1, x2, }\DataTypeTok{cl =} \FloatTok{0.95}\NormalTok{) \{}
\OperatorTok{+}\StringTok{   }\NormalTok{n <-}\StringTok{ }\KeywordTok{length}\NormalTok{(x1)}
\OperatorTok{+}\StringTok{   }\NormalTok{dbar <-}\StringTok{ }\KeywordTok{mean}\NormalTok{(x1 }\OperatorTok{-}\StringTok{ }\NormalTok{x2)}
\OperatorTok{+}\StringTok{   }\NormalTok{s_d <-}\StringTok{ }\KeywordTok{sd}\NormalTok{(x1 }\OperatorTok{-}\StringTok{ }\NormalTok{x2)}
\OperatorTok{+}\StringTok{   }\NormalTok{tstat <-}\StringTok{ }\NormalTok{dbar}\OperatorTok{/}\NormalTok{(s_d}\OperatorTok{/}\KeywordTok{sqrt}\NormalTok{(n))}
\OperatorTok{+}\StringTok{   }\NormalTok{pval <-}\StringTok{ }\DecValTok{2} \OperatorTok{*}\StringTok{ }\NormalTok{(}\DecValTok{1} \OperatorTok{-}\StringTok{ }\KeywordTok{pt}\NormalTok{(}\KeywordTok{abs}\NormalTok{(tstat), n }\OperatorTok{-}\StringTok{ }\DecValTok{1}\NormalTok{))}
\OperatorTok{+}\StringTok{   }\NormalTok{pctile <-}\StringTok{ }\DecValTok{1} \OperatorTok{-}\StringTok{ }\NormalTok{(}\DecValTok{1} \OperatorTok{-}\StringTok{ }\NormalTok{cl)}\OperatorTok{/}\DecValTok{2}
\OperatorTok{+}\StringTok{   }\NormalTok{margin <-}\StringTok{ }\KeywordTok{qt}\NormalTok{(pctile, n }\OperatorTok{-}\StringTok{ }\DecValTok{1}\NormalTok{) }\OperatorTok{*}\StringTok{ }\NormalTok{s_d}\OperatorTok{/}\KeywordTok{sqrt}\NormalTok{(n)}
\OperatorTok{+}\StringTok{   }\NormalTok{lcl <-}\StringTok{ }\NormalTok{dbar }\OperatorTok{-}\StringTok{ }\NormalTok{margin}
\OperatorTok{+}\StringTok{   }\NormalTok{ucl <-}\StringTok{ }\NormalTok{dbar }\OperatorTok{+}\StringTok{ }\NormalTok{margin}
\OperatorTok{+}\StringTok{   }\KeywordTok{return}\NormalTok{(}\KeywordTok{list}\NormalTok{(}\DataTypeTok{tstat =}\NormalTok{ tstat, }\DataTypeTok{pval =}\NormalTok{ pval, }\DataTypeTok{lcl =}\NormalTok{ lcl, }\DataTypeTok{ucl =}\NormalTok{ ucl))}
\OperatorTok{+}\StringTok{ }\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{>}\StringTok{ }\KeywordTok{paired_t}\NormalTok{(corn}\OperatorTok{$}\NormalTok{kiln_dried, corn}\OperatorTok{$}\NormalTok{regular)}
\OperatorTok{>}\StringTok{ }\KeywordTok{paired_t}\NormalTok{(corn}\OperatorTok{$}\NormalTok{kiln_dried, corn}\OperatorTok{$}\NormalTok{regular, }\DataTypeTok{cl =} \FloatTok{0.99}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Two things to note. First, arguments do not have to be named. So

\begin{verbatim}
paired_t(corn$kiln_dried, corn$regular)
\end{verbatim}

and

\begin{verbatim}
paired_t(x1 = corn$kiln_dried, x2 = corn$regular)
\end{verbatim}

are equivalent. But we need to be careful if we do not name arguments because then we have to know the ordering of the arguments in the function declaration.

Second, in the declaration of the function, the third argument \texttt{cl} was given a default value of \texttt{0.95}. If a user does not specify a value for \texttt{cl} it will silently be set to \texttt{0.95}. But of course a user can override this, as we did in

\begin{verbatim}
paired_t(corn$kiln_dried, corn$regular, cl = 0.99)
\end{verbatim}

\hypertarget{creating-functions}{%
\subsection{Creating Functions}\label{creating-functions}}

Creating very short functions at the command prompt is a reasonable strategy. For longer functions, one option is to write the function in a script and then submit the whole function. Or a function can be written in any text editor, saved as a plain text file (possibly with a \texttt{.r} extension), and then read into R using the \texttt{source()} function.

\hypertarget{programming-conditional-statements}{%
\section{Programming: Conditional Statements}\label{programming-conditional-statements}}

The \texttt{paired\_t} function is somewhat useful, but could be improved in several ways. For example, consider the following:

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{>}\StringTok{ }\KeywordTok{paired_t}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{5}\NormalTok{, }\DecValTok{1}\OperatorTok{:}\DecValTok{4}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

The user specified data had different numbers of observations in \texttt{x1} and \texttt{x2}, which of course can't be data tested by a paired t test. Rather than stopping and letting the user know that this is a problem, the function continued and produced meaningless output.

Also, the function as written only allows testing against a two-sided alternative hypothesis, and it would be good to allow one-sided alternatives.

First we will address some checks on arguments specified by the user. For this we will use an \texttt{if()} function and a \texttt{stop()} function.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{>}\StringTok{ }\NormalTok{paired_t <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x1, x2, }\DataTypeTok{cl =} \FloatTok{0.95}\NormalTok{) \{}
\OperatorTok{+}\StringTok{   }\ControlFlowTok{if}\NormalTok{ (}\KeywordTok{length}\NormalTok{(x1) }\OperatorTok{!=}\StringTok{ }\KeywordTok{length}\NormalTok{(x2)) \{}
\OperatorTok{+}\StringTok{     }\KeywordTok{stop}\NormalTok{(}\StringTok{"The input vectors  must have the same length"}\NormalTok{)}
\OperatorTok{+}\StringTok{   }\NormalTok{\}}
\OperatorTok{+}\StringTok{   }\NormalTok{n <-}\StringTok{ }\KeywordTok{length}\NormalTok{(x1)}
\OperatorTok{+}\StringTok{   }\NormalTok{dbar <-}\StringTok{ }\KeywordTok{mean}\NormalTok{(x1 }\OperatorTok{-}\StringTok{ }\NormalTok{x2)}
\OperatorTok{+}\StringTok{   }\NormalTok{s_d <-}\StringTok{ }\KeywordTok{sd}\NormalTok{(x1 }\OperatorTok{-}\StringTok{ }\NormalTok{x2)}
\OperatorTok{+}\StringTok{   }\NormalTok{tstat <-}\StringTok{ }\NormalTok{dbar}\OperatorTok{/}\NormalTok{(s_d}\OperatorTok{/}\KeywordTok{sqrt}\NormalTok{(n))}
\OperatorTok{+}\StringTok{   }\NormalTok{pval <-}\StringTok{ }\DecValTok{2} \OperatorTok{*}\StringTok{ }\NormalTok{(}\DecValTok{1} \OperatorTok{-}\StringTok{ }\KeywordTok{pt}\NormalTok{(}\KeywordTok{abs}\NormalTok{(tstat), n }\OperatorTok{-}\StringTok{ }\DecValTok{1}\NormalTok{))}
\OperatorTok{+}\StringTok{   }\NormalTok{pctile <-}\StringTok{ }\DecValTok{1} \OperatorTok{-}\StringTok{ }\NormalTok{(}\DecValTok{1} \OperatorTok{-}\StringTok{ }\NormalTok{cl)}\OperatorTok{/}\DecValTok{2}
\OperatorTok{+}\StringTok{   }\NormalTok{margin <-}\StringTok{ }\KeywordTok{qt}\NormalTok{(pctile, n }\OperatorTok{-}\StringTok{ }\DecValTok{1}\NormalTok{) }\OperatorTok{*}\StringTok{ }\NormalTok{s_d}\OperatorTok{/}\KeywordTok{sqrt}\NormalTok{(n)}
\OperatorTok{+}\StringTok{   }\NormalTok{lcl <-}\StringTok{ }\NormalTok{dbar }\OperatorTok{-}\StringTok{ }\NormalTok{margin}
\OperatorTok{+}\StringTok{   }\NormalTok{ucl <-}\StringTok{ }\NormalTok{dbar }\OperatorTok{+}\StringTok{ }\NormalTok{margin}
\OperatorTok{+}\StringTok{   }\KeywordTok{return}\NormalTok{(}\KeywordTok{list}\NormalTok{(}\DataTypeTok{tstat =}\NormalTok{ tstat, }\DataTypeTok{pval =}\NormalTok{ pval, }\DataTypeTok{lcl =}\NormalTok{ lcl, }\DataTypeTok{ucl =}\NormalTok{ ucl))}
\OperatorTok{+}\StringTok{ }\NormalTok{\}}
\OperatorTok{>}\StringTok{ }\KeywordTok{paired_t}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{5}\NormalTok{, }\DecValTok{1}\OperatorTok{:}\DecValTok{4}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

The argument to the \texttt{if()} function is evaluated. If the argument returns \texttt{TRUE} the ensuing code is executed. Otherwise, the ensuing code is skipped and the rest of the function is evaluated. If a \texttt{stop()} function is executed, the function is exited and the argument of \texttt{stop()} is printed.

To better understand and use \texttt{if()} statements, we need to understand comparison operators and logical operators.

\hypertarget{comparison-and-logical-operators}{%
\subsection{Comparison and Logical Operators}\label{comparison-and-logical-operators}}

We have made use of some of the comparison operators in R. These include

\begin{itemize}
\tightlist
\item
  Equal: \texttt{==}
\item
  Not equal: \texttt{!=}
\item
  Greater than: \texttt{\textgreater{}}
\item
  Less than: \texttt{\textless{}}
\item
  Greater than or equal to: \texttt{\textgreater{}=}
\item
  Less than or equal to: \texttt{\textless{}=}
\end{itemize}

Special care needs to be taken with the \texttt{==} and \texttt{!=} operators because of how numbers are represented on computers, see Section \ref{arith}.

There are also three logical operators, with two variants of the ``and'' operator and the ``or'' operator.

\begin{itemize}
\tightlist
\item
  and: Either \texttt{\&} or \texttt{\&\&}
\item
  or: Either \texttt{\textbar{}} or \texttt{\textbar{}\textbar{}}
\item
  not: \texttt{!}
\end{itemize}

The ``double'' operators \texttt{\&\&} and \texttt{\textbar{}\textbar{}} just examine the first element of the two vectors, whereas the ``single'' operators \texttt{\&} and \texttt{\textbar{}} compare element by element.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{>}\StringTok{ }\KeywordTok{c}\NormalTok{(}\OtherTok{FALSE}\NormalTok{, }\OtherTok{TRUE}\NormalTok{, }\OtherTok{FALSE}\NormalTok{) }\OperatorTok{||}\StringTok{ }\KeywordTok{c}\NormalTok{(}\OtherTok{TRUE}\NormalTok{, }\OtherTok{FALSE}\NormalTok{, }\OtherTok{FALSE}\NormalTok{)}
\OperatorTok{>}\StringTok{ }\KeywordTok{c}\NormalTok{(}\OtherTok{FALSE}\NormalTok{, }\OtherTok{TRUE}\NormalTok{, }\OtherTok{FALSE}\NormalTok{) }\OperatorTok{|}\StringTok{ }\KeywordTok{c}\NormalTok{(}\OtherTok{TRUE}\NormalTok{, }\OtherTok{FALSE}\NormalTok{, }\OtherTok{FALSE}\NormalTok{)}
\OperatorTok{>}\StringTok{ }\KeywordTok{c}\NormalTok{(}\OtherTok{FALSE}\NormalTok{, }\OtherTok{TRUE}\NormalTok{, }\OtherTok{FALSE}\NormalTok{) }\OperatorTok{&&}\StringTok{ }\KeywordTok{c}\NormalTok{(}\OtherTok{TRUE}\NormalTok{, }\OtherTok{TRUE}\NormalTok{, }\OtherTok{FALSE}\NormalTok{)}
\OperatorTok{>}\StringTok{ }\KeywordTok{c}\NormalTok{(}\OtherTok{FALSE}\NormalTok{, }\OtherTok{TRUE}\NormalTok{, }\OtherTok{FALSE}\NormalTok{) }\OperatorTok{&}\StringTok{ }\KeywordTok{c}\NormalTok{(}\OtherTok{TRUE}\NormalTok{, }\OtherTok{TRUE}\NormalTok{, }\OtherTok{FALSE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

We can use the logical operators to check whether a user-specified confidence level is between 0 and 1.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{>}\StringTok{ }\NormalTok{paired_t <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x1, x2, }\DataTypeTok{cl =} \FloatTok{0.95}\NormalTok{) \{}
\OperatorTok{+}\StringTok{   }\ControlFlowTok{if}\NormalTok{ (}\KeywordTok{length}\NormalTok{(x1) }\OperatorTok{!=}\StringTok{ }\KeywordTok{length}\NormalTok{(x2)) \{}
\OperatorTok{+}\StringTok{     }\KeywordTok{stop}\NormalTok{(}\StringTok{"The input vectors  must have the same length"}\NormalTok{)}
\OperatorTok{+}\StringTok{   }\NormalTok{\}}
\OperatorTok{+}\StringTok{   }\ControlFlowTok{if}\NormalTok{ (cl }\OperatorTok{<=}\StringTok{ }\DecValTok{0} \OperatorTok{||}\StringTok{ }\NormalTok{cl }\OperatorTok{>=}\StringTok{ }\DecValTok{1}\NormalTok{) \{}
\OperatorTok{+}\StringTok{     }\KeywordTok{stop}\NormalTok{(}\StringTok{"The confidence level must be between 0 and 1"}\NormalTok{)}
\OperatorTok{+}\StringTok{   }\NormalTok{\}}
\OperatorTok{+}\StringTok{   }\NormalTok{n <-}\StringTok{ }\KeywordTok{length}\NormalTok{(x1)}
\OperatorTok{+}\StringTok{   }\NormalTok{dbar <-}\StringTok{ }\KeywordTok{mean}\NormalTok{(x1 }\OperatorTok{-}\StringTok{ }\NormalTok{x2)}
\OperatorTok{+}\StringTok{   }\NormalTok{s_d <-}\StringTok{ }\KeywordTok{sd}\NormalTok{(x1 }\OperatorTok{-}\StringTok{ }\NormalTok{x2)}
\OperatorTok{+}\StringTok{   }\NormalTok{tstat <-}\StringTok{ }\NormalTok{dbar}\OperatorTok{/}\NormalTok{(s_d}\OperatorTok{/}\KeywordTok{sqrt}\NormalTok{(n))}
\OperatorTok{+}\StringTok{   }\NormalTok{pval <-}\StringTok{ }\DecValTok{2} \OperatorTok{*}\StringTok{ }\NormalTok{(}\DecValTok{1} \OperatorTok{-}\StringTok{ }\KeywordTok{pt}\NormalTok{(}\KeywordTok{abs}\NormalTok{(tstat), n }\OperatorTok{-}\StringTok{ }\DecValTok{1}\NormalTok{))}
\OperatorTok{+}\StringTok{   }\NormalTok{pctile <-}\StringTok{ }\DecValTok{1} \OperatorTok{-}\StringTok{ }\NormalTok{(}\DecValTok{1} \OperatorTok{-}\StringTok{ }\NormalTok{cl)}\OperatorTok{/}\DecValTok{2}
\OperatorTok{+}\StringTok{   }\NormalTok{margin <-}\StringTok{ }\KeywordTok{qt}\NormalTok{(pctile, n }\OperatorTok{-}\StringTok{ }\DecValTok{1}\NormalTok{) }\OperatorTok{*}\StringTok{ }\NormalTok{s_d}\OperatorTok{/}\KeywordTok{sqrt}\NormalTok{(n)}
\OperatorTok{+}\StringTok{   }\NormalTok{lcl <-}\StringTok{ }\NormalTok{dbar }\OperatorTok{-}\StringTok{ }\NormalTok{margin}
\OperatorTok{+}\StringTok{   }\NormalTok{ucl <-}\StringTok{ }\NormalTok{dbar }\OperatorTok{+}\StringTok{ }\NormalTok{margin}
\OperatorTok{+}\StringTok{   }\KeywordTok{return}\NormalTok{(}\KeywordTok{list}\NormalTok{(}\DataTypeTok{tstat =}\NormalTok{ tstat, }\DataTypeTok{pval =}\NormalTok{ pval, }\DataTypeTok{lcl =}\NormalTok{ lcl, }\DataTypeTok{ucl =}\NormalTok{ ucl))}
\OperatorTok{+}\StringTok{ }\NormalTok{\}}
\OperatorTok{>}\StringTok{ }\KeywordTok{paired_t}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{5}\NormalTok{, }\DecValTok{2}\OperatorTok{:}\DecValTok{6}\NormalTok{, }\DataTypeTok{cl =} \DecValTok{15}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\hypertarget{if-else-statements}{%
\subsection{If else statements}\label{if-else-statements}}

The \texttt{if()} statement we have used so far has the form

\begin{verbatim}
if (condition) {
  expression
}
\end{verbatim}

Often we want to evaluate one expression if the condition is true, and evaluate a different expression if the condition is false. That is accomplished by the \texttt{if\ else} statement. Here we determine whether a number is positive, negative, or zero.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{>}\StringTok{ }\NormalTok{Sign <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x) \{}
\OperatorTok{+}\StringTok{   }\ControlFlowTok{if}\NormalTok{ (x }\OperatorTok{<}\StringTok{ }\DecValTok{0}\NormalTok{) \{}
\OperatorTok{+}\StringTok{     }\KeywordTok{print}\NormalTok{(}\StringTok{"the number is negative"}\NormalTok{)}
\OperatorTok{+}\StringTok{   }\NormalTok{\} }\ControlFlowTok{else} \ControlFlowTok{if}\NormalTok{ (x }\OperatorTok{>}\StringTok{ }\DecValTok{0}\NormalTok{) \{}
\OperatorTok{+}\StringTok{     }\KeywordTok{print}\NormalTok{(}\StringTok{"the number is positive"}\NormalTok{)}
\OperatorTok{+}\StringTok{   }\NormalTok{\} }\ControlFlowTok{else}\NormalTok{ \{}
\OperatorTok{+}\StringTok{     }\KeywordTok{print}\NormalTok{(}\StringTok{"the number is zero"}\NormalTok{)}
\OperatorTok{+}\StringTok{   }\NormalTok{\}}
\OperatorTok{+}\StringTok{ }\NormalTok{\}}
\OperatorTok{>}\StringTok{ }\KeywordTok{Sign}\NormalTok{(}\DecValTok{3}\NormalTok{)}
\OperatorTok{>}\StringTok{ }\KeywordTok{Sign}\NormalTok{(}\OperatorTok{-}\DecValTok{3}\NormalTok{)}
\OperatorTok{>}\StringTok{ }\KeywordTok{Sign}\NormalTok{(}\DecValTok{0}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Notice the ``different expression'' for the first \texttt{if} statement was itself an \texttt{if} statement.

Next we modify the \texttt{paired\_t} function to allow two-sided and one-sided alternatives.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{>}\StringTok{ }\NormalTok{paired_t <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x1, x2, }\DataTypeTok{cl =} \FloatTok{0.95}\NormalTok{, }\DataTypeTok{alternative =} \StringTok{"not.equal"}\NormalTok{) \{}
\OperatorTok{+}\StringTok{   }\ControlFlowTok{if}\NormalTok{ (}\KeywordTok{length}\NormalTok{(x1) }\OperatorTok{!=}\StringTok{ }\KeywordTok{length}\NormalTok{(x2)) \{}
\OperatorTok{+}\StringTok{     }\KeywordTok{stop}\NormalTok{(}\StringTok{"The input vectors must be of the same length"}\NormalTok{)}
\OperatorTok{+}\StringTok{   }\NormalTok{\}}
\OperatorTok{+}\StringTok{   }\ControlFlowTok{if}\NormalTok{ (cl }\OperatorTok{<=}\StringTok{ }\DecValTok{0} \OperatorTok{||}\StringTok{ }\NormalTok{cl }\OperatorTok{>=}\StringTok{ }\DecValTok{1}\NormalTok{) \{}
\OperatorTok{+}\StringTok{     }\KeywordTok{stop}\NormalTok{(}\StringTok{"The confidence level must be between 0 and 1"}\NormalTok{)}
\OperatorTok{+}\StringTok{   }\NormalTok{\}}
\OperatorTok{+}\StringTok{   }\NormalTok{n <-}\StringTok{ }\KeywordTok{length}\NormalTok{(x1)}
\OperatorTok{+}\StringTok{   }\NormalTok{dbar <-}\StringTok{ }\KeywordTok{mean}\NormalTok{(x1 }\OperatorTok{-}\StringTok{ }\NormalTok{x2)}
\OperatorTok{+}\StringTok{   }\NormalTok{s_d <-}\StringTok{ }\KeywordTok{sd}\NormalTok{(x1 }\OperatorTok{-}\StringTok{ }\NormalTok{x2)}
\OperatorTok{+}\StringTok{   }\NormalTok{tstat <-}\StringTok{ }\NormalTok{dbar}\OperatorTok{/}\NormalTok{(s_d}\OperatorTok{/}\KeywordTok{sqrt}\NormalTok{(n))}
\OperatorTok{+}\StringTok{   }\ControlFlowTok{if}\NormalTok{ (alternative }\OperatorTok{==}\StringTok{ "not.equal"}\NormalTok{) \{}
\OperatorTok{+}\StringTok{     }\NormalTok{pval <-}\StringTok{ }\DecValTok{2} \OperatorTok{*}\StringTok{ }\NormalTok{(}\DecValTok{1} \OperatorTok{-}\StringTok{ }\KeywordTok{pt}\NormalTok{(}\KeywordTok{abs}\NormalTok{(tstat), n }\OperatorTok{-}\StringTok{ }\DecValTok{1}\NormalTok{))}
\OperatorTok{+}\StringTok{     }\NormalTok{pctile <-}\StringTok{ }\DecValTok{1} \OperatorTok{-}\StringTok{ }\NormalTok{(}\DecValTok{1} \OperatorTok{-}\StringTok{ }\NormalTok{cl)}\OperatorTok{/}\DecValTok{2}
\OperatorTok{+}\StringTok{     }\NormalTok{margin <-}\StringTok{ }\KeywordTok{qt}\NormalTok{(pctile, n }\OperatorTok{-}\StringTok{ }\DecValTok{1}\NormalTok{) }\OperatorTok{*}\StringTok{ }\NormalTok{s_d}\OperatorTok{/}\KeywordTok{sqrt}\NormalTok{(n)}
\OperatorTok{+}\StringTok{     }\NormalTok{lcl <-}\StringTok{ }\NormalTok{dbar }\OperatorTok{-}\StringTok{ }\NormalTok{margin}
\OperatorTok{+}\StringTok{     }\NormalTok{ucl <-}\StringTok{ }\NormalTok{dbar }\OperatorTok{+}\StringTok{ }\NormalTok{margin}
\OperatorTok{+}\StringTok{   }\NormalTok{\} }\ControlFlowTok{else} \ControlFlowTok{if}\NormalTok{ (alternative }\OperatorTok{==}\StringTok{ "greater"}\NormalTok{) \{}
\OperatorTok{+}\StringTok{     }\NormalTok{pval <-}\StringTok{ }\DecValTok{1} \OperatorTok{-}\StringTok{ }\KeywordTok{pt}\NormalTok{(tstat, n }\OperatorTok{-}\StringTok{ }\DecValTok{1}\NormalTok{)}
\OperatorTok{+}\StringTok{     }\NormalTok{margin <-}\StringTok{ }\KeywordTok{qt}\NormalTok{(cl, n }\OperatorTok{-}\StringTok{ }\DecValTok{1}\NormalTok{) }\OperatorTok{*}\StringTok{ }\NormalTok{s_d}\OperatorTok{/}\KeywordTok{sqrt}\NormalTok{(n)}
\OperatorTok{+}\StringTok{     }\NormalTok{lcl <-}\StringTok{ }\NormalTok{dbar }\OperatorTok{-}\StringTok{ }\NormalTok{margin}
\OperatorTok{+}\StringTok{     }\NormalTok{ucl <-}\StringTok{ }\OtherTok{Inf}
\OperatorTok{+}\StringTok{   }\NormalTok{\} }\ControlFlowTok{else} \ControlFlowTok{if}\NormalTok{ (alternative }\OperatorTok{==}\StringTok{ "less"}\NormalTok{) \{}
\OperatorTok{+}\StringTok{     }\NormalTok{pval <-}\StringTok{ }\KeywordTok{pt}\NormalTok{(tstat, n }\OperatorTok{-}\StringTok{ }\DecValTok{1}\NormalTok{)}
\OperatorTok{+}\StringTok{     }\NormalTok{margin <-}\StringTok{ }\KeywordTok{qt}\NormalTok{(cl, n }\OperatorTok{-}\StringTok{ }\DecValTok{1}\NormalTok{) }\OperatorTok{*}\StringTok{ }\NormalTok{s_d}\OperatorTok{/}\KeywordTok{sqrt}\NormalTok{(n)}
\OperatorTok{+}\StringTok{     }\NormalTok{lcl <-}\StringTok{ }\OperatorTok{-}\OtherTok{Inf}
\OperatorTok{+}\StringTok{     }\NormalTok{ucl <-}\StringTok{ }\NormalTok{dbar }\OperatorTok{+}\StringTok{ }\NormalTok{margin}
\OperatorTok{+}\StringTok{   }\NormalTok{\}}
\OperatorTok{+}\StringTok{   }
\OperatorTok{+}\StringTok{   }\KeywordTok{return}\NormalTok{(}\KeywordTok{list}\NormalTok{(}\DataTypeTok{tstat =}\NormalTok{ tstat, }\DataTypeTok{pval =}\NormalTok{ pval, }\DataTypeTok{lcl =}\NormalTok{ lcl, }\DataTypeTok{ucl =}\NormalTok{ ucl))}
\OperatorTok{+}\StringTok{ }\NormalTok{\}}
\OperatorTok{>}\StringTok{ }\KeywordTok{paired_t}\NormalTok{(corn}\OperatorTok{$}\NormalTok{kiln_dried, corn}\OperatorTok{$}\NormalTok{regular)}
\OperatorTok{>}\StringTok{ }\KeywordTok{paired_t}\NormalTok{(corn}\OperatorTok{$}\NormalTok{kiln_dried, corn}\OperatorTok{$}\NormalTok{regular, }\DataTypeTok{alternative =} \StringTok{"less"}\NormalTok{)}
\OperatorTok{>}\StringTok{ }\KeywordTok{paired_t}\NormalTok{(corn}\OperatorTok{$}\NormalTok{kiln_dried, corn}\OperatorTok{$}\NormalTok{regular, }\DataTypeTok{alternative =} \StringTok{"greater"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\hypertarget{arith}{%
\section{Computer Arithmetic}\label{arith}}

Like most software, R does not perform exact arithmetic. Rather, R follows the IEEE 754 floating point standards. This can have profound effects on how computational algorithms are implemented, but is also important when considering things like comparisons.

Note first that computer arithmetic does not follow some of the rules of ordinary arithmetic. For example, it is not associative.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{>}\StringTok{ }\DecValTok{2}\OperatorTok{^-}\DecValTok{30}
\OperatorTok{>}\StringTok{ }\DecValTok{2}\OperatorTok{^-}\DecValTok{30} \OperatorTok{+}\StringTok{ }\NormalTok{(}\DecValTok{2}\OperatorTok{^}\DecValTok{30} \OperatorTok{-}\StringTok{ }\DecValTok{2}\OperatorTok{^}\DecValTok{30}\NormalTok{)}
\OperatorTok{>}\StringTok{ }\NormalTok{(}\DecValTok{2}\OperatorTok{^-}\DecValTok{30} \OperatorTok{+}\StringTok{ }\DecValTok{2}\OperatorTok{^}\DecValTok{30}\NormalTok{) }\OperatorTok{-}\StringTok{ }\DecValTok{2}\OperatorTok{^}\DecValTok{30}
\end{Highlighting}
\end{Shaded}

Computer arithmetic is not exact.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{>}\StringTok{ }\FloatTok{1.5} \OperatorTok{-}\StringTok{ }\FloatTok{1.4}
\OperatorTok{>}\StringTok{ }\FloatTok{1.5} \OperatorTok{-}\StringTok{ }\FloatTok{1.4} \OperatorTok{==}\StringTok{ }\FloatTok{0.1}
\OperatorTok{>}\StringTok{ }\NormalTok{(}\FloatTok{1.5} \OperatorTok{-}\StringTok{ }\FloatTok{1.4}\NormalTok{) }\OperatorTok{-}\StringTok{ }\FloatTok{0.1}
\end{Highlighting}
\end{Shaded}

So for example an \texttt{if} statement that uses an equality test may not give the expected answer. One way to avoid this problem is to test ``near equality'' using \texttt{all.equal()}. The function takes as arguments two objects to be compared, and a tolerance. If the objects are within the tolerance of each other, the function returns \texttt{TRUE}. The tolerance has a default value of about \(1.5\times 10^{-8}\), which works well in many cases.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{>}\StringTok{ }\KeywordTok{all.equal}\NormalTok{((}\FloatTok{1.5} \OperatorTok{-}\StringTok{ }\FloatTok{1.4}\NormalTok{), }\FloatTok{0.1}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\hypertarget{loops}{%
\section{Loops}\label{loops}}

Loops are an important component of any programming language, including R. Vectorized calculations and functions such as \texttt{apply()} make loops a bit less central to R than to many other languages, but an understanding of the three looping structures in R is still quite important.

We will investigate loops in the context of computing what is sometimes called the ``machine epsilon.'' Because of the inexact representation of numbers in R (and other languages) sometimes R cannot distinguish between the numbers \texttt{1} and \texttt{\textbar{}1\ +\ x\textbar{}} for small values of \texttt{x}. The smallest value of \texttt{x} such that \texttt{1} and \texttt{\textbar{}1+x\textbar{}} are not declared equal is the machine epsilon.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{>}\StringTok{ }\DecValTok{1} \OperatorTok{==}\StringTok{ }\DecValTok{1} \OperatorTok{+}\StringTok{ }\DecValTok{10}\OperatorTok{^-}\DecValTok{4}
\OperatorTok{>}\StringTok{ }\DecValTok{1} \OperatorTok{==}\StringTok{ }\DecValTok{1} \OperatorTok{+}\StringTok{ }\DecValTok{10}\OperatorTok{^-}\DecValTok{50}
\end{Highlighting}
\end{Shaded}

Clearly the machine epsilon is somewhere between \(10^{-4}\) and \(10^{-50}\). How can we find its value exactly? Since floating point numbers use a binary representation, we know that the machine epsilon will be equal to \(1/2^k\) for some value of \(k\). So to find the machine epsilon, we can keep testing whether \(1\) and \(1+1/2^k\) are equal, until we find a value \(k\) where the two are equal. Then the machine epsilon will be \(1/2^{k-1}\), since it is the smallest value for which the two are NOT equal.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{>}\StringTok{ }\DecValTok{1} \OperatorTok{==}\StringTok{ }\DecValTok{1} \OperatorTok{+}\StringTok{ }\DecValTok{1}\OperatorTok{/}\DecValTok{2}
\OperatorTok{>}\StringTok{ }\DecValTok{1} \OperatorTok{==}\StringTok{ }\DecValTok{1} \OperatorTok{+}\StringTok{ }\DecValTok{1}\OperatorTok{/}\DecValTok{2}\OperatorTok{^}\DecValTok{2}
\OperatorTok{>}\StringTok{ }\DecValTok{1} \OperatorTok{==}\StringTok{ }\DecValTok{1} \OperatorTok{+}\StringTok{ }\DecValTok{1}\OperatorTok{/}\DecValTok{2}\OperatorTok{^}\DecValTok{3}
\end{Highlighting}
\end{Shaded}

Testing by hand like this gets tedious quickly. A loop can automate the process. We will do this with two R loop types, \texttt{repeat} and \texttt{while}.

\hypertarget{a-repeat-loop}{%
\subsection{A Repeat Loop}\label{a-repeat-loop}}

A \texttt{repeat} loop just repeats a given expression over and over again until a \texttt{break} statement is encountered.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{>}\StringTok{ }\NormalTok{k <-}\StringTok{ }\DecValTok{1}
\OperatorTok{>}\StringTok{ }\ControlFlowTok{repeat}\NormalTok{ \{}
\OperatorTok{+}\StringTok{   }\ControlFlowTok{if}\NormalTok{ (}\DecValTok{1} \OperatorTok{==}\StringTok{ }\DecValTok{1} \OperatorTok{+}\StringTok{ }\DecValTok{1}\OperatorTok{/}\DecValTok{2}\OperatorTok{^}\NormalTok{k) \{}
\OperatorTok{+}\StringTok{     }\ControlFlowTok{break}
\OperatorTok{+}\StringTok{   }\NormalTok{\} }\ControlFlowTok{else}\NormalTok{ \{}
\OperatorTok{+}\StringTok{     }\NormalTok{k <-}\StringTok{ }\NormalTok{k }\OperatorTok{+}\StringTok{ }\DecValTok{1}
\OperatorTok{+}\StringTok{   }\NormalTok{\}}
\OperatorTok{+}\StringTok{ }\NormalTok{\}}
\OperatorTok{>}\StringTok{ }\NormalTok{k}
\OperatorTok{>}\StringTok{ }\DecValTok{1}\OperatorTok{/}\DecValTok{2}\OperatorTok{^}\NormalTok{(k }\OperatorTok{-}\StringTok{ }\DecValTok{1}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

This code initializes \texttt{k} at 1. The body of the loop initially checks whether \(1\) and \(1+1/2^k\) are equal. If they are equal, the \texttt{break} statement is executed and control is transferred outside the loop. If they are not equal, \texttt{k} is increased by 1, and we return to the beginning of the top of the body of the loop.

\hypertarget{a-while-loop}{%
\subsection{A While Loop}\label{a-while-loop}}

A \texttt{while} loop has the form

\begin{verbatim}
while (condition) {
  expression
}
\end{verbatim}

As long as the \texttt{condition} is \texttt{TRUE} the \texttt{expression} is evaluated. Once the \texttt{condition} is \texttt{FALSE} control is transferred outside the loop.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{>}\StringTok{ }\NormalTok{k <-}\StringTok{ }\DecValTok{1}
\OperatorTok{>}\StringTok{ }\ControlFlowTok{while}\NormalTok{ (}\DecValTok{1} \OperatorTok{!=}\StringTok{ }\DecValTok{1} \OperatorTok{+}\StringTok{ }\DecValTok{1}\OperatorTok{/}\DecValTok{2}\OperatorTok{^}\NormalTok{k) \{}
\OperatorTok{+}\StringTok{   }\NormalTok{k <-}\StringTok{ }\NormalTok{k }\OperatorTok{+}\StringTok{ }\DecValTok{1}
\OperatorTok{+}\StringTok{ }\NormalTok{\}}
\OperatorTok{>}\StringTok{ }\NormalTok{k}
\OperatorTok{>}\StringTok{ }\DecValTok{1}\OperatorTok{/}\DecValTok{2}\OperatorTok{^}\NormalTok{(k }\OperatorTok{-}\StringTok{ }\DecValTok{1}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\hypertarget{a-for-loop}{%
\subsection{A For Loop}\label{a-for-loop}}

A \texttt{for} loop has the form

\begin{verbatim}
for (variable in vector) {
  expression
}
\end{verbatim}

The \texttt{for} loop sets the \texttt{variable} equal to each element of the \texttt{vector} in succession, and evaluates the \texttt{expression} each time. Here are two different ways to use a \texttt{for} loop to calculate the sum of the elements in a vector.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{>}\StringTok{ }\NormalTok{x <-}\StringTok{ }\DecValTok{1}\OperatorTok{:}\DecValTok{10}
\OperatorTok{>}\StringTok{ }\NormalTok{S <-}\StringTok{ }\DecValTok{0}
\OperatorTok{>}\StringTok{ }\ControlFlowTok{for}\NormalTok{ (i }\ControlFlowTok{in} \DecValTok{1}\OperatorTok{:}\KeywordTok{length}\NormalTok{(x)) \{}
\OperatorTok{+}\StringTok{   }\NormalTok{S <-}\StringTok{ }\NormalTok{S }\OperatorTok{+}\StringTok{ }\NormalTok{x[i]}
\OperatorTok{+}\StringTok{ }\NormalTok{\}}
\OperatorTok{>}\StringTok{ }\NormalTok{S}
\OperatorTok{>}\StringTok{ }\NormalTok{S <-}\StringTok{ }\DecValTok{0}
\OperatorTok{>}\StringTok{ }\ControlFlowTok{for}\NormalTok{ (value }\ControlFlowTok{in}\NormalTok{ x) \{}
\OperatorTok{+}\StringTok{   }\NormalTok{S <-}\StringTok{ }\NormalTok{S }\OperatorTok{+}\StringTok{ }\NormalTok{value}
\OperatorTok{+}\StringTok{ }\NormalTok{\}}
\OperatorTok{>}\StringTok{ }\NormalTok{S}
\end{Highlighting}
\end{Shaded}

In the first case we loop over the positions of the vector elements, while in the second case we loop over the elements themselves.

\hypertarget{efficiency-considerations}{%
\section{Efficiency Considerations}\label{efficiency-considerations}}

In many contexts R and modern computers are fast enough that the user does not need to worry about writing efficient code. There are a few simple ways to write efficient code that are easy enough, and provide enough speed-up, that they are worth following as often as possible. The R function \texttt{system.time()} reports how long a set of R code takes to execute, and we will use this function to compare different ways to accomplish objectives in R.

\hypertarget{growing-objects}{%
\subsection{Growing Objects}\label{growing-objects}}

Consider two ways to create a sequence of integers from 1 to n, implemented in functions \texttt{f1} and \texttt{f2}.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Start with a zero-length vector, and let it grow:
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{>}\StringTok{ }\NormalTok{f1 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(n) \{}
\OperatorTok{+}\StringTok{   }\NormalTok{x <-}\StringTok{ }\KeywordTok{numeric}\NormalTok{(}\DecValTok{0}\NormalTok{)}
\OperatorTok{+}\StringTok{   }\ControlFlowTok{for}\NormalTok{ (i }\ControlFlowTok{in} \DecValTok{1}\OperatorTok{:}\NormalTok{n) \{}
\OperatorTok{+}\StringTok{     }\NormalTok{x <-}\StringTok{ }\KeywordTok{c}\NormalTok{(x, i)}
\OperatorTok{+}\StringTok{   }\NormalTok{\}}
\OperatorTok{+}\StringTok{   }\NormalTok{x}
\OperatorTok{+}\StringTok{ }\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{1}
\tightlist
\item
  Start with a vector of length \(n\) and fill in the values:
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{>}\StringTok{ }\NormalTok{f2 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(n) \{}
\OperatorTok{+}\StringTok{   }\NormalTok{x <-}\StringTok{ }\KeywordTok{numeric}\NormalTok{(n)}
\OperatorTok{+}\StringTok{   }\ControlFlowTok{for}\NormalTok{ (i }\ControlFlowTok{in} \DecValTok{1}\OperatorTok{:}\NormalTok{n) \{}
\OperatorTok{+}\StringTok{     }\NormalTok{x[i] <-}\StringTok{ }\NormalTok{i}
\OperatorTok{+}\StringTok{   }\NormalTok{\}}
\OperatorTok{+}\StringTok{   }\NormalTok{x}
\OperatorTok{+}\StringTok{ }\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Here are the two functions in action, with \(n = 100000\).

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{>}\StringTok{ }\NormalTok{n <-}\StringTok{ }\FloatTok{1e+05}
\OperatorTok{>}\StringTok{ }\KeywordTok{system.time}\NormalTok{(}\KeywordTok{f1}\NormalTok{(n))}
\OperatorTok{>}\StringTok{ }\KeywordTok{system.time}\NormalTok{(}\KeywordTok{f2}\NormalTok{(n))}
\end{Highlighting}
\end{Shaded}

It is \emph{much} more efficient to start with a full-length vector and then fill in values.\footnote{Roughly speaking, the first option is slower because each time the vector is increased in size, R must resize the vector and re-allocate memory.}

Of course another way to create a vector of integers from 1 to n is to use \texttt{1:n}. Let's see how fast this is.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{>}\StringTok{ }\KeywordTok{system.time}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\NormalTok{n)}
\OperatorTok{>}\StringTok{ }\NormalTok{n <-}\StringTok{ }\FloatTok{1e+06}
\OperatorTok{>}\StringTok{ }\KeywordTok{system.time}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\NormalTok{n)}
\end{Highlighting}
\end{Shaded}

For \(n=100000\) this is so fast the system time is very close to zero. Even when \(n\) is 1000000 the time is very small. So another important lesson is to use built-in R functions whenever possible, since they have had substantial development focused on efficiency, correctness, etc.

\hypertarget{vectorization}{%
\subsection{Vectorization}\label{vectorization}}

Next consider calculating the sum of the squared entries in each column of a matrix. For example with the matrix \(M\),
\[
M = \left(\begin{array}{ccc}
1 & 2 & 3 \\
4 & 5 & 6
\end{array}\right),
\]

the sums would be \(1^2 + 4^2 = 17\), \(2^2 + 5^2 = 29\), and \(3^2 + 6^2 = 45\).
One possibility is to have an outer loop that traverses the columns and an inner loop that traverses the rows within a column, squaring the entries and adding them together.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{>}\StringTok{ }\NormalTok{test_matrix <-}\StringTok{ }\KeywordTok{matrix}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{6}\NormalTok{, }\DataTypeTok{byrow =} \OtherTok{TRUE}\NormalTok{, }\DataTypeTok{nrow =} \DecValTok{2}\NormalTok{)}
\OperatorTok{>}\StringTok{ }\NormalTok{test_matrix}
\OperatorTok{>}\StringTok{ }\NormalTok{ss1 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(M) \{}
\OperatorTok{+}\StringTok{   }\NormalTok{n <-}\StringTok{ }\KeywordTok{dim}\NormalTok{(M)[}\DecValTok{1}\NormalTok{]}
\OperatorTok{+}\StringTok{   }\NormalTok{m <-}\StringTok{ }\KeywordTok{dim}\NormalTok{(M)[}\DecValTok{2}\NormalTok{]}
\OperatorTok{+}\StringTok{   }\NormalTok{out <-}\StringTok{ }\KeywordTok{rep}\NormalTok{(}\DecValTok{0}\NormalTok{, m)}
\OperatorTok{+}\StringTok{   }\ControlFlowTok{for}\NormalTok{ (j }\ControlFlowTok{in} \DecValTok{1}\OperatorTok{:}\NormalTok{m) \{}
\OperatorTok{+}\StringTok{     }\ControlFlowTok{for}\NormalTok{ (i }\ControlFlowTok{in} \DecValTok{1}\OperatorTok{:}\NormalTok{n) \{}
\OperatorTok{+}\StringTok{       }\NormalTok{out[j] <-}\StringTok{ }\NormalTok{out[j] }\OperatorTok{+}\StringTok{ }\NormalTok{M[i, j]}\OperatorTok{^}\DecValTok{2}
\OperatorTok{+}\StringTok{     }\NormalTok{\}}
\OperatorTok{+}\StringTok{   }\NormalTok{\}}
\OperatorTok{+}\StringTok{   }\KeywordTok{return}\NormalTok{(out)}
\OperatorTok{+}\StringTok{ }\NormalTok{\}}
\OperatorTok{>}\StringTok{ }\KeywordTok{ss1}\NormalTok{(test_matrix)}
\end{Highlighting}
\end{Shaded}

Another possibility eliminates the inner loop, using the \texttt{sum()} function to compute the sum of the squared entries in the column directly.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{>}\StringTok{ }\NormalTok{ss2 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(M) \{}
\OperatorTok{+}\StringTok{   }\NormalTok{m <-}\StringTok{ }\KeywordTok{dim}\NormalTok{(M)[}\DecValTok{2}\NormalTok{]}
\OperatorTok{+}\StringTok{   }\NormalTok{out <-}\StringTok{ }\KeywordTok{numeric}\NormalTok{(m)}
\OperatorTok{+}\StringTok{   }\ControlFlowTok{for}\NormalTok{ (j }\ControlFlowTok{in} \DecValTok{1}\OperatorTok{:}\NormalTok{m) \{}
\OperatorTok{+}\StringTok{     }\NormalTok{out[j] <-}\StringTok{ }\KeywordTok{sum}\NormalTok{(M[, j]}\OperatorTok{^}\DecValTok{2}\NormalTok{)}
\OperatorTok{+}\StringTok{   }\NormalTok{\}}
\OperatorTok{+}\StringTok{   }\KeywordTok{return}\NormalTok{(out)}
\OperatorTok{+}\StringTok{ }\NormalTok{\}}
\OperatorTok{>}\StringTok{ }\KeywordTok{ss2}\NormalTok{(test_matrix)}
\end{Highlighting}
\end{Shaded}

A third possibility uses the \texttt{colSums()} function.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{>}\StringTok{ }\NormalTok{ss3 <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(M) \{}
\OperatorTok{+}\StringTok{   }\NormalTok{out <-}\StringTok{ }\KeywordTok{colSums}\NormalTok{(M}\OperatorTok{^}\DecValTok{2}\NormalTok{)}
\OperatorTok{+}\StringTok{   }\KeywordTok{return}\NormalTok{(out)}
\OperatorTok{+}\StringTok{ }\NormalTok{\}}
\OperatorTok{>}\StringTok{ }\KeywordTok{ss3}\NormalTok{(test_matrix)}
\end{Highlighting}
\end{Shaded}

Here is a speed comparison, using a \(1000\times 10000\) matrix.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{>}\StringTok{ }\NormalTok{mm <-}\StringTok{ }\KeywordTok{matrix}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\FloatTok{1e+07}\NormalTok{, }\DataTypeTok{byrow =} \OtherTok{TRUE}\NormalTok{, }\DataTypeTok{nrow =} \DecValTok{1000}\NormalTok{)}
\OperatorTok{>}\StringTok{ }\KeywordTok{system.time}\NormalTok{(}\KeywordTok{ss1}\NormalTok{(mm))}
\OperatorTok{>}\StringTok{ }\KeywordTok{system.time}\NormalTok{(}\KeywordTok{ss2}\NormalTok{(mm))}
\OperatorTok{>}\StringTok{ }\KeywordTok{system.time}\NormalTok{(}\KeywordTok{ss3}\NormalTok{(mm))}
\OperatorTok{>}\StringTok{ }\KeywordTok{rm}\NormalTok{(mm)}
\end{Highlighting}
\end{Shaded}

\hypertarget{more-on-functions}{%
\section{More on Functions}\label{more-on-functions}}

Understanding functions deeply requires a careful study of R's scoping rules, as well as a good understanding of environments in R. That's beyond the scope of this book, but we will briefly discuss some issues that are most salient. For a more in-depth treatment, see ``Advanced R'' by Hadley Wickham, especially the chapters on functions and environments.

\hypertarget{calling-functions}{%
\section{Calling Functions}\label{calling-functions}}

When using a function, the functions arguments can be specified in three ways:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  By the full name of the argument.
\item
  By the position of the argument.
\item
  By a partial name of the argument.
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{>}\StringTok{ }\NormalTok{tmp_function <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(first.arg, second.arg, third.arg, }
\OperatorTok{+}\StringTok{   }\NormalTok{fourth.arg) \{}
\OperatorTok{+}\StringTok{   }\KeywordTok{return}\NormalTok{(}\KeywordTok{c}\NormalTok{(first.arg, second.arg, third.arg, fourth.arg))}
\OperatorTok{+}\StringTok{ }\NormalTok{\}}
\OperatorTok{>}\StringTok{ }\KeywordTok{tmp_function}\NormalTok{(}\DecValTok{34}\NormalTok{, }\DecValTok{15}\NormalTok{, }\DataTypeTok{third.arg =} \DecValTok{11}\NormalTok{, }\DataTypeTok{fou =} \DecValTok{99}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Positional matching of arguments is convenient, but should be used carefully, and probably limited to the first few, and most commonly used, arguments in a function. Partial does have pitfalls. A partially specified argument must unambiguously match exactly one argument---a requirement that's not met below.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{>}\StringTok{ }\NormalTok{tmp_function <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(first.arg, fourth.arg) \{}
\OperatorTok{+}\StringTok{   }\KeywordTok{return}\NormalTok{(}\KeywordTok{c}\NormalTok{(first.arg, fourth.arg))}
\OperatorTok{+}\StringTok{ }\NormalTok{\}}
\OperatorTok{>}\StringTok{ }\KeywordTok{tmp_function}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DataTypeTok{f =} \DecValTok{2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\hypertarget{the-...-argument}{%
\subsection{\texorpdfstring{The \texttt{...} argument}{The ... argument}}\label{the-...-argument}}

In defining a function, a special argument denoted by \texttt{...} can be used. Sometimes this is called the ``ellipsis'' argument, sometimes the ``three dot'' argument, sometimes the ``dot dot dot'' argument, etc. The R language definition \url{https://cran.r-project.org/doc/manuals/r-release/R-lang.html} describes the argument in this way:

\begin{quote}
The special type of argument `\ldots{}' can contain any number of supplied arguments. It is used for a variety of purposes. It allows you to write a function that takes an arbitrary number of arguments. It can be used to absorb some arguments into an intermediate function which can then be extracted by functions called subsequently.
\end{quote}

Consider for example the \texttt{sum()} function.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{>}\StringTok{ }\KeywordTok{sum}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{5}\NormalTok{)}
\OperatorTok{>}\StringTok{ }\KeywordTok{sum}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{5}\NormalTok{, }\KeywordTok{c}\NormalTok{(}\DecValTok{3}\NormalTok{, }\DecValTok{4}\NormalTok{, }\DecValTok{90}\NormalTok{))}
\OperatorTok{>}\StringTok{ }\KeywordTok{sum}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{, }\KeywordTok{c}\NormalTok{(}\DecValTok{3}\NormalTok{, }\DecValTok{4}\NormalTok{, }\DecValTok{90}\NormalTok{), }\DecValTok{1}\OperatorTok{:}\DecValTok{5}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Think about writing such a function. There is no way to predict in advance the number of arguments a user might specify. So the function is defined with \texttt{...} as the first argument:

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{>}\StringTok{ }\NormalTok{sum}
\end{Highlighting}
\end{Shaded}

This is true of many commonly-used functions in R such as \texttt{c()} among others.

Next, consider a function that calls another function in its body. For example, suppose that a collaborator always supplies comma delimited files that have five lines of description, followed by a line containing variable names, followed by the data. You are tired of having to specify \texttt{skip\ =\ 5}, \texttt{header\ =\ TRUE}, and \texttt{sep\ =\ ","} to \texttt{read.table()} and want to create a function \texttt{my.read()} which uses these as defaults.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{>}\StringTok{ }\NormalTok{my.read <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(file, }\DataTypeTok{header =} \OtherTok{TRUE}\NormalTok{, }\DataTypeTok{sep =} \StringTok{","}\NormalTok{, }\DataTypeTok{skip =} \DecValTok{5}\NormalTok{, }
\OperatorTok{+}\StringTok{   }\NormalTok{...) \{}
\OperatorTok{+}\StringTok{   }\KeywordTok{read.table}\NormalTok{(}\DataTypeTok{file =}\NormalTok{ file, }\DataTypeTok{header =}\NormalTok{ header, }\DataTypeTok{sep =}\NormalTok{ sep, }
\OperatorTok{+}\StringTok{     }\DataTypeTok{skip =}\NormalTok{ skip, ...)}
\OperatorTok{+}\StringTok{ }\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

The \texttt{...} in the definition of \texttt{my.read()} allows the user to specify other arguments, for example, \texttt{stringsAsFactors\ =\ FALSE}. These will be passed on to the \texttt{read.table()} function. In fact, that is how \texttt{read.csv()} is defined.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{>}\StringTok{ }\NormalTok{read.csv}
\end{Highlighting}
\end{Shaded}

\hypertarget{lazy-evaluation}{%
\subsection{Lazy Evaluation}\label{lazy-evaluation}}

Arguments to R functions are not evaluated until they are needed, sometimes called \emph{lazy} evaluation.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{>}\StringTok{ }\NormalTok{f <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(a, b) \{}
\OperatorTok{+}\StringTok{   }\KeywordTok{print}\NormalTok{(a}\OperatorTok{^}\DecValTok{2}\NormalTok{)}
\OperatorTok{+}\StringTok{   }\KeywordTok{print}\NormalTok{(a}\OperatorTok{^}\DecValTok{3}\NormalTok{)}
\OperatorTok{+}\StringTok{   }\KeywordTok{print}\NormalTok{(a }\OperatorTok{*}\StringTok{ }\NormalTok{b)}
\OperatorTok{+}\StringTok{ }\NormalTok{\}}
\OperatorTok{>}\StringTok{ }\KeywordTok{f}\NormalTok{(}\DataTypeTok{a =} \DecValTok{3}\NormalTok{, }\DataTypeTok{b =} \DecValTok{2}\NormalTok{)}
\OperatorTok{>}\StringTok{ }\KeywordTok{f}\NormalTok{(}\DataTypeTok{a =} \DecValTok{3}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

The first call specified both of the arguments \texttt{a} and \texttt{b}, and produced the expected output. In the second call the argument \texttt{b} was not specified. Since it was not needed until the third \texttt{print} statement, R happily executed the first two \texttt{print} statements, and only reported an error in the third statement, when \texttt{b} was needed to compute \texttt{a*b}.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{>}\StringTok{ }\NormalTok{f <-}\StringTok{ }\ControlFlowTok{function}\NormalTok{(a, }\DataTypeTok{b =}\NormalTok{ a}\OperatorTok{^}\DecValTok{3}\NormalTok{) \{}
\OperatorTok{+}\StringTok{   }\KeywordTok{return}\NormalTok{(a }\OperatorTok{*}\StringTok{ }\NormalTok{b)}
\OperatorTok{+}\StringTok{ }\NormalTok{\}}
\OperatorTok{>}\StringTok{ }\KeywordTok{f}\NormalTok{(}\DecValTok{2}\NormalTok{)}
\OperatorTok{>}\StringTok{ }\KeywordTok{f}\NormalTok{(}\DecValTok{2}\NormalTok{, }\DecValTok{10}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

In the first call, since \texttt{b} was not specified, it was computed as \texttt{a\^{}3}. In the second call, \texttt{b} was specified, and the specified value was used.

\hypertarget{homework-4}{%
\section{Homework}\label{homework-4}}

\textbf{Exercise 10} Learning objectives: translate statistical notation into coded functions; learn about tools for checking validity of function arguments; practice writing functions that return multiple objects.

\hypertarget{sp}{%
\chapter{Spatial Data Visualization and Analysis}\label{sp}}

\hypertarget{overview}{%
\section{Overview}\label{overview}}

Recall, a data structure is a format for organizing and storing data. The structure is designed so that data can be accessed and worked with in specific ways. Statistical software and programming languages have methods (or functions) designed to operate on different kinds of data structures.

This chapter focuses on spatial data structures and some of the R functions that work with these data. Spatial data comprise values associated with locations, such as temperature data at a given latitude, longitude, and perhaps elevation. Spatial data are typically organized into \textbf{vector} or \textbf{raster} data types. (See Figure \ref{fig:raster}).

\begin{itemize}
\tightlist
\item
  Vector data represent features such as discrete points, lines, and polygons.
\item
  Raster data represent surfaces as a rectangular matrix of square cells or pixels.
\end{itemize}

Whether or not you use vector or raster data depends on the type of problem, the type of maps you need, and the data source. Each data structure has strengths and weaknesses in terms of functionality and representation. As you gain more experience working with spatial data, you will be able to determine which structure to use for a particular application.

There is a large set of R packages available for working with spatial (and space-time) data. These packages are described in the \href{https://CRAN.R-project.org/view=Spatial}{Cran Task View: Analysis of Spatial Data}. The CRAN task view attempts to organize the various packages into categories, such as \emph{Handling spatial data}, \emph{Reading and writing spatial data}, \emph{Visualization}, and \emph{Disease mapping and areal data analysis}, so users can quickly identify package options given their project needs.

Exploring the extent of the excellent spatial data tools available in R is beyond the scope of this book. Rather, we would point you to subject texts like \emph{Applied Spatial Data Analysis with R} by \citet{Bivand13} (available for free via the MSU library system), and numerous online tutorials on pretty much any aspect of spatial data analysis with R. These tools make R a full-blown \href{https://en.wikipedia.org/wiki/Geographic_information_system}{Geographic Information System} (GIS) capable of spatial data manipulation and analysis on par with commercial GIS systems such as \href{http://www.esri.com/arcgis/about-arcgis}{ESRI's ArcGIS}.

\hypertarget{some-spatial-data-packages}{%
\subsection{Some Spatial Data Packages}\label{some-spatial-data-packages}}

This chapter will focus on a few R packages for manipulating and visualizing spatial data. Specifically we will touch on the following packages

\begin{itemize}
\tightlist
\item
  \texttt{sp}: spatial data structures and methods
\item
  \texttt{rgdal}: interface to the C/C\texttt{++} spatial data Geospatial Data Abstraction Library
\item
  \texttt{ggmap}: extends \texttt{ggplot2} language to handle spatial data
\item
  \texttt{leaflet}: generates dynamic online maps
\end{itemize}

\hypertarget{motivating-data}{%
\section{Motivating Data}\label{motivating-data}}

We motivate the topics introduced in this chapter using some forestry data from the \href{https://www.nrs.fs.fed.us/ef/locations/me/penobscot\%7D\%7BPenobscot\%20Experimental\%20Forest}{Penobscot Experimental Forest} (PEF) located in Maine (which you've previously seen throughout the course). The PEF is a long-term experimental forest that is used to understand the effects of silviculture (i.e., science of tending trees) treatments on forest growth and composition. The PEF is divided into non-overlapping management units that receive different harvesting treatments. Within each management unit is a series of observation point locations (called forest inventory plots) where forest variables have been measured. Ultimately, we want to summarize the inventory plots measurements by management unit and map the results.

\hypertarget{reading-spatial-data-into-r}{%
\section{Reading Spatial Data into R}\label{reading-spatial-data-into-r}}

Spatial data come in a variety of file formats. Examples of popular vector file formats for points, lines, and polygons, include ESRI's \href{https://en.wikipedia.org/wiki/Shapefile}{shapefile} and open standard \href{https://en.wikipedia.org/wiki/GeoJSON}{GeoJSON}. Common raster file formats include \href{https://en.wikipedia.org/wiki/GeoTIFF}{GeoTIFF} and \href{https://en.wikipedia.org/wiki/NetCDF}{netCDF}\footnote{A longer list of spatial data file formats is available at \url{https://en.wikipedia.org/wiki/GIS_file_formats}.}.

The \texttt{rgdal} function \texttt{readOGR} will read a large variety of vector data file formats (there is also a \texttt{writeOGR()} for writing vector data files). Raster data file formats can be read using the \texttt{rgdal} function \texttt{readGDAL} (yup, also a \texttt{writeGDAL()}) or read functions in the \texttt{raster} package. All of these functions automatically cast the data into an appropriate R spatial data object (i.e., data structure), which are defined in the \texttt{sp} or \texttt{raster} packages. Table \ref{tab:spatialObjs} provides an abbreviated list of these R spatial objects\footnote{A more complete list of the \texttt{sp} package's spatial data classes and methods is detailed in the package's vignette \url{https://cran.r-project.org/web/packages/sp/vignettes/intro_sp.pdf}.}. The \emph{Without attributes }column gives the \texttt{sp} package's spatial data object classes for points, lines, polygons, and raster pixels that do not have data associated with the spatial objects (i.e., without attributes in GIS speak). \texttt{DataFrame} is appended to the object class name once data, in the form of variables, are added to the spatial object.

You can create your own spatial data objects in R. Below, for example, we create a \texttt{SpatialPoints} object consisting of four points. Then add some data to the points to make it a \texttt{SpatialPointsDataFrame}.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{>}\StringTok{ }\KeywordTok{library}\NormalTok{(sp)}
\OperatorTok{>}\StringTok{ }\KeywordTok{library}\NormalTok{(dplyr)}
\OperatorTok{>}\StringTok{ }
\ErrorTok{>}\StringTok{ }\NormalTok{x <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\DecValTok{3}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{6}\NormalTok{)}
\OperatorTok{>}\StringTok{ }\NormalTok{y <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\DecValTok{2}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{6}\NormalTok{, }\DecValTok{7}\NormalTok{)}
\OperatorTok{>}\StringTok{ }
\ErrorTok{>}\StringTok{ }\NormalTok{coords <-}\StringTok{ }\KeywordTok{cbind}\NormalTok{(x, y)}
\OperatorTok{>}\StringTok{ }
\ErrorTok{>}\StringTok{ }\NormalTok{sp.pts <-}\StringTok{ }\KeywordTok{SpatialPoints}\NormalTok{(coords)}
\OperatorTok{>}\StringTok{ }
\ErrorTok{>}\StringTok{ }\KeywordTok{class}\NormalTok{(sp.pts)}
\OperatorTok{>}\StringTok{ }
\ErrorTok{>}\StringTok{ }\NormalTok{some.data <-}\StringTok{ }\KeywordTok{data.frame}\NormalTok{(}\DataTypeTok{var.1 =} \KeywordTok{c}\NormalTok{(}\StringTok{"a"}\NormalTok{, }\StringTok{"b"}\NormalTok{, }\StringTok{"c"}\NormalTok{, }\StringTok{"d"}\NormalTok{), }\DataTypeTok{var.2 =} \DecValTok{1}\OperatorTok{:}\DecValTok{4}\NormalTok{)}
\OperatorTok{>}\StringTok{ }
\ErrorTok{>}\StringTok{ }\NormalTok{sp.pts.df <-}\StringTok{ }\KeywordTok{SpatialPointsDataFrame}\NormalTok{(sp.pts, some.data)}
\OperatorTok{>}\StringTok{ }
\ErrorTok{>}\StringTok{ }\KeywordTok{class}\NormalTok{(sp.pts.df)}
\end{Highlighting}
\end{Shaded}

If, for example, you already have a data frame that includes the spatial coordinate columns and other variables, then you can promote it to a \texttt{SpatialPointsDataFrame} by indicating which columns contain point coordinates. You can extract or access the data frame associated with the spatial object using \texttt{@data}. You can also access individual variables directly from the spatial object using \texttt{\$} or by name or column number to the right of the comma in \texttt{{[},{]}} (analogues to accessing variables in a data frame).

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{>}\StringTok{ }\NormalTok{df <-}\StringTok{ }\KeywordTok{data.frame}\NormalTok{(}\DataTypeTok{x =} \KeywordTok{c}\NormalTok{(}\DecValTok{3}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{6}\NormalTok{), }\DataTypeTok{y =} \KeywordTok{c}\NormalTok{(}\DecValTok{2}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{6}\NormalTok{, }\DecValTok{7}\NormalTok{), }\DataTypeTok{var.1 =} \KeywordTok{c}\NormalTok{(}\StringTok{"a"}\NormalTok{, }
\OperatorTok{+}\StringTok{   "b"}\NormalTok{, }\StringTok{"c"}\NormalTok{, }\StringTok{"d"}\NormalTok{), }\DataTypeTok{var.2 =} \DecValTok{1}\OperatorTok{:}\DecValTok{4}\NormalTok{)}
\OperatorTok{>}\StringTok{ }\KeywordTok{class}\NormalTok{(df)}
\OperatorTok{>}\StringTok{ }
\ErrorTok{>}\StringTok{ }\CommentTok{# promote to a SpatialPointsDataFrame}
\ErrorTok{>}\StringTok{ }\KeywordTok{coordinates}\NormalTok{(df) <-}\StringTok{ }\ErrorTok{~}\NormalTok{x }\OperatorTok{+}\StringTok{ }\NormalTok{y}
\OperatorTok{>}\StringTok{ }
\ErrorTok{>}\StringTok{ }\KeywordTok{class}\NormalTok{(df)}
\OperatorTok{>}\StringTok{ }
\ErrorTok{>}\StringTok{ }\CommentTok{# access entire data frame}
\ErrorTok{>}\StringTok{ }\NormalTok{df}\OperatorTok{@}\NormalTok{data}
\OperatorTok{>}\StringTok{ }
\ErrorTok{>}\StringTok{ }\KeywordTok{class}\NormalTok{(df}\OperatorTok{@}\NormalTok{data)}
\OperatorTok{>}\StringTok{ }
\ErrorTok{>}\StringTok{ }\CommentTok{# access columns directly}
\ErrorTok{>}\StringTok{ }\NormalTok{df}\OperatorTok{$}\NormalTok{var}\FloatTok{.1}
\OperatorTok{>}\StringTok{ }
\ErrorTok{>}\StringTok{ }\NormalTok{df[, }\KeywordTok{c}\NormalTok{(}\StringTok{"var.1"}\NormalTok{, }\StringTok{"var.2"}\NormalTok{)]}
\OperatorTok{>}\StringTok{ }
\ErrorTok{>}\StringTok{ }\NormalTok{df[, }\DecValTok{2}\NormalTok{]}
\OperatorTok{>}\StringTok{ }
\ErrorTok{>}\StringTok{ }\CommentTok{# get the bounding box}
\ErrorTok{>}\StringTok{ }\KeywordTok{bbox}\NormalTok{(df)}
\end{Highlighting}
\end{Shaded}

Here, the data frame \texttt{df} is promoted to a \texttt{SpatialPointsDataFrame} by indicating the column names that hold the longitude and latitude (i.e., \texttt{x} and \texttt{y} respectively) using the \texttt{coordinates} function. Here too, the \texttt{@data} is used to retrieve the data frame associated with the points. We also illustrate how variables can be accessed directly from the spatial object. The \texttt{bbox} function is used to return the bounding box that is defined by the spatial extent of the point coordinates. The other spatial objects noted in Table \ref{tab:spatialObjs} can be created, and their data accessed, in a similar way\footnote{This cheatsheet(www.maths.lancs.ac.uk/\textasciitilde{}rowlings/Teaching/UseR2012/cheatsheet.html) written by Barry Rowlingson is a useful reference www.maths.lancs.ac.uk/\textasciitilde{}rowlings/Teaching/UseR2012/cheatsheet.html}.

More than often we find ourselves reading existing spatial data files into R. The code below uses the \texttt{downloader} package to download all of the PEF data we'll use in this chapter. The data are compressed in a single zip file, which is then extracted into the working directory using the \texttt{unzip} function. A look into the PEF directory using \texttt{list.files} shows nine files\footnote{The \texttt{list.files} function does not read data into R; it simply prints the contents of a directory.}. Those named \texttt{MU-bounds.*} comprise the shapefile that holds the PEF's management unit boundaries in the form of polygons. Like other spatial data file formats, shapefiles are made up of several different files (with different file extensions) that are linked together to form a spatial data object. The \texttt{plots.csv} file holds the spatial coordinates and other information about the PEF's forest inventory plots. The \texttt{roads.*} shapefile holds roads and trails in and around the PEF.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{>}\StringTok{ }\KeywordTok{library}\NormalTok{(downloader)}
\OperatorTok{>}\StringTok{ }
\ErrorTok{>}\StringTok{ }\KeywordTok{download}\NormalTok{(}\StringTok{"http://blue.for.msu.edu/FOR875/data/PEF.zip"}\NormalTok{, }
\OperatorTok{+}\StringTok{          }\DataTypeTok{destfile=}\StringTok{"./PEF.zip"}\NormalTok{, }\DataTypeTok{mode=}\StringTok{"wb"}\NormalTok{) }
\OperatorTok{>}\StringTok{ }
\ErrorTok{>}\StringTok{ }\KeywordTok{unzip}\NormalTok{(}\StringTok{"PEF.zip"}\NormalTok{, }\DataTypeTok{exdir =} \StringTok{"."}\NormalTok{)}
\OperatorTok{>}\StringTok{ }
\ErrorTok{>}\StringTok{ }\KeywordTok{list.files}\NormalTok{(}\StringTok{"PEF"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Next we read the MU-bounds shapefile into R using \texttt{readOGR()}\footnote{The authors of the \texttt{rgdal} library decided to have some information about the version of GDAL and other software specifics be printed when the library is loaded. Don't let it distract you.} and explore the resulting \texttt{mu} object. Notice that when we read a shapefile into R, we do not include a file extension with the shapefile name because a shapefile is always composed of multiple files.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{>}\StringTok{ }\KeywordTok{library}\NormalTok{(rgdal)}
\OperatorTok{>}\StringTok{ }\NormalTok{mu <-}\StringTok{ }\KeywordTok{readOGR}\NormalTok{(}\StringTok{"PEF"}\NormalTok{, }\StringTok{"MU-bounds"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

When called, the \texttt{readOGR} function provides a bit of information about the object being read in. Here, we see that it read the MU-bounds shapefile from PEF directory and the shapefile had 40 features (i.e., polygons) and 1 field (i.e., field is synonymous with column or variable in the data frame).

You can think of the resulting \texttt{mu} object as a data frame where each row corresponds to a polygon and each column holds information about the polygon\footnote{Much of the actual spatial information is hidden from you in other parts of the data structure, but is available if you ask nicely for it (see subsequent sections).}. More specifically, the \texttt{mu} object is a \texttt{SpatialPolygonsDataFrame}.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{>}\StringTok{ }\KeywordTok{class}\NormalTok{(mu)}
\end{Highlighting}
\end{Shaded}

As illustrated using the made-up point data in the example above, you can access the data frame associated with the polygons using \texttt{@data}.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{>}\StringTok{ }\KeywordTok{class}\NormalTok{(mu}\OperatorTok{@}\NormalTok{data)}
\OperatorTok{>}\StringTok{ }\KeywordTok{dim}\NormalTok{(mu}\OperatorTok{@}\NormalTok{data)}
\OperatorTok{>}\StringTok{ }\KeywordTok{head}\NormalTok{(mu}\OperatorTok{@}\NormalTok{data)}
\end{Highlighting}
\end{Shaded}

Above, a call to \texttt{class()} confirms we have accessed the data frame, \texttt{dim()} shows there are 40 rows (one row for each polygon) and one column, and \texttt{head()} shows the first six values of the column named \texttt{mu\_id}. The \texttt{mu\_id} values are unique identifiers for each management unit polygon across the PEF.

\hypertarget{coordinate-reference-systems}{%
\section{Coordinate Reference Systems}\label{coordinate-reference-systems}}

One of the more challenging aspects of working with spatial data is getting used to the idea of a coordinate reference system. A \emph{coordinate reference system} (CRS) is a system that uses one or more numbers, or coordinates, to uniquely determine the position of a point or other geometric element (e.g., line, polygon, raster). For spatial data, there are two common coordinate systems:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Spherical coordinate system, such as latitude-longitude, often referred to as a \emph{geographic coordinate system}.
\item
  Projected coordinate system based on a map projection, which is a systematic transformation of the latitudes and longitudes that aims to minimize distortion occurring from projecting maps of the earth's spherical surface onto a two-dimensional Cartesian coordinate plane. Projected coordinate systems are sometimes referred to as \emph{map projections}.
\end{enumerate}

There are numerous map projections\footnote{See partial list of map projections at \url{https://en.wikipedia.org/wiki/List/_of/_map/_projections}. See a humorous discussion of map projections at \url{http://brilliantmaps.com/xkcd/}.}. One of the more frustrating parts of working with spatial data is that it seems like each data source you find offers its data in a different map projection and hence you spend a great deal of time \emph{reprojecting} (i.e., transforming from one CRS to another) data into a common CRS such that they overlay correctly. Reprojecting is accomplished using the \texttt{sp} package's \texttt{spTransform} function as demonstrated in Section \ref{ggmap}.

In R, a spatial object's CRS is accessed via the \texttt{sp} package \texttt{proj4string} function. The code below shows the current projection of \texttt{mu}.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{>}\StringTok{ }\KeywordTok{proj4string}\NormalTok{(mu)}
\end{Highlighting}
\end{Shaded}

The cryptic looking string returned by \texttt{proj4string()} is a set of directives understood by the \href{http://proj4.org/}{proj.4} C library, which is part of \texttt{sp}, and used to map geographic longitude and latitude coordinates into the projected Cartesian coordinates. This CRS tells us the \texttt{mu} object is in \href{https://en.wikipedia.org/wiki/Universal_Transverse_Mercator_coordinate_system}{Universal Transverse Mercator (UTM)} zone 19 coordinate system.\footnote{If you start dealing with a lot of spatial data and reprojecting, \url{http://spatialreference.org} is an excellent resources for finding and specifying coordinate reference systems.}

\hypertarget{ggmap}{%
\section{\texorpdfstring{Illustration using \texttt{ggmap}}{Illustration using ggmap}}\label{ggmap}}

Let's begin by making a map of PEF management unit boundaries over top of a satellite image using the \texttt{ggmap} package. Given an address, location, or bounding box, the \texttt{ggmap} package's \texttt{get\_map} function will query Google Maps, OpenStreetMap, Stamen Maps, or Naver Map servers for a user-specified map type. The \texttt{get\_map} function requires the location or bounding box coordinates be in a geographic coordinate system (i.e., latitude-longitude). This means we need to reproject \texttt{mu} from UTM zone 19 to latitude-longitude geographic coordinates, which is defined by the \texttt{\textquotesingle{}"proj=longlat\ +datum=WGS84"\textquotesingle{}} proj.4 string. As seen below, the first argument in \texttt{spTransform} function is the spatial object to reproject and the second argument is a CRS object created by passing a proj.4 string into the \texttt{CRS} function.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{>}\StringTok{ }\NormalTok{mu <-}\StringTok{ }\KeywordTok{spTransform}\NormalTok{(mu, }\KeywordTok{CRS}\NormalTok{(}\StringTok{"+proj=longlat +datum=WGS84"}\NormalTok{))}
\OperatorTok{>}\StringTok{ }\KeywordTok{proj4string}\NormalTok{(mu)}
\end{Highlighting}
\end{Shaded}

Unfortunately, we cannot just feed the \texttt{SpatialPolygonsDataFrame} \texttt{mu} into \texttt{ggplot} (perhaps some day soon this will possible). Rather, we need to first convert the \texttt{SpatialPolygonsDataFrame} into a specially formatted data frame using the \texttt{fortify} function that is part of the \texttt{ggplot2} package\footnote{\texttt{ggmap} depends on \texttt{ggplot2} so \texttt{ggplot2} will be automatically loaded when you call \texttt{library(ggmap)}.}. The \texttt{fortify} function will also need a unique identifier for each polygon specified using the \texttt{region} argument, which for \texttt{mu} is the \texttt{mu\_id}.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{>}\StringTok{ }\KeywordTok{library}\NormalTok{(ggmap)}
\OperatorTok{>}\StringTok{ }\NormalTok{mu.f <-}\StringTok{ }\KeywordTok{fortify}\NormalTok{(mu, }\DataTypeTok{region =} \StringTok{"mu_id"}\NormalTok{)}
\OperatorTok{>}\StringTok{ }\KeywordTok{head}\NormalTok{(mu.f)}
\end{Highlighting}
\end{Shaded}

Notice the \texttt{id} column in the fortified version of \texttt{mu} holds each polygon's \texttt{mu\_id} value (this will be important later when we link data to the polygons).

Next, we query the satellite imagery used to underlay the management units (we'll generally refer to this underlying map as the basemap). As of October 2018, Google now requires you to set up a Google API account in order to run the following maps. This is free, but it does require a credit card to obtain the API Key that is required to make the \texttt{ggmap} package work. Here I provide you with an API key for a project I created for this class that should allow you to run the following function if you desire. If you are interested in obtaining your own API key, see the page \href{https://developers.google.com/maps/documentation/geocoding/get-api-key}{here} for learning about how to use Google maps web services.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{>}\StringTok{ }\KeywordTok{register_google}\NormalTok{(}\DataTypeTok{key =} \StringTok{"AIzaSyBPAwSY5x8vQqlnG-QwiCAWQW12U3CTLZY"}\NormalTok{)}
\OperatorTok{>}\StringTok{ }\NormalTok{mu.bbox <-}\StringTok{ }\KeywordTok{bbox}\NormalTok{(mu)}
\OperatorTok{>}\StringTok{ }
\ErrorTok{>}\StringTok{ }\NormalTok{basemap <-}\StringTok{ }\KeywordTok{get_map}\NormalTok{(}\DataTypeTok{location=}\NormalTok{mu.bbox, }\DataTypeTok{zoom =} \DecValTok{14}\NormalTok{, }\DataTypeTok{maptype=}\StringTok{"satellite"}\NormalTok{)}
\OperatorTok{>}\StringTok{ }
\ErrorTok{>}\StringTok{ }\KeywordTok{ggmap}\NormalTok{(basemap) }\OperatorTok{+}
\OperatorTok{+}\StringTok{     }\KeywordTok{geom_polygon}\NormalTok{(}\DataTypeTok{data=}\NormalTok{mu.f, }\KeywordTok{aes}\NormalTok{(}\DataTypeTok{x =}\NormalTok{ long, }\DataTypeTok{y =}\NormalTok{ lat, }\DataTypeTok{group=}\NormalTok{group), }
\OperatorTok{+}\StringTok{                  }\DataTypeTok{fill=}\OtherTok{NA}\NormalTok{, }\DataTypeTok{size=}\FloatTok{0.2}\NormalTok{, }\DataTypeTok{color=}\StringTok{"orange"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Looks pretty good! Take a look at the \texttt{get\_map} function manual page and try different options for \texttt{maptype} (e.g., \texttt{maptype="terrain"}).

Next we'll add the forest inventory plots to the map. Begin by reading in the PEF forest inventory plot data held in ``plots.csv''. Recall, foresters have measured forest variables at a set of locations (i.e., inventory plots) within each management unit. The following statement reads these data and displays the resulting data frame structure.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{>}\StringTok{ }\NormalTok{plots <-}\StringTok{ }\KeywordTok{read.csv}\NormalTok{(}\StringTok{"PEF/plots.csv"}\NormalTok{, }\DataTypeTok{stringsAsFactors =} \OtherTok{FALSE}\NormalTok{)}
\OperatorTok{>}\StringTok{ }\KeywordTok{str}\NormalTok{(plots)}
\end{Highlighting}
\end{Shaded}

In \texttt{plots} each row is a forest inventory plot and columns are:

\begin{itemize}
\tightlist
\item
  \texttt{mu\_id} identifies the management unit within which the plot is located
\item
  \texttt{plot} unique plot number within the management unit
\item
  \texttt{easting} longitude coordinate in UTM zone 19
\item
  \texttt{northing} latitude coordinate in UTM zone 19
\item
  \texttt{biomass\_mg\_ha} tree biomass in metric ton (per hectare basis)
\item
  \texttt{stocking\_stems\_ha} number of tree (per hectare basis)
\item
  \texttt{diameter\_cm} average tree diameter measured 130 cm up the tree trunk
\item
  \texttt{basal\_area\_m2\_ha} total cross-sectional area at 130 cm up the tree trunk (per hectare basis)
\end{itemize}

There is nothing inherently spatial about this data structure---it is simply a data frame. We make \texttt{plots} into a spatial object by identifying which columns hold the coordinates. This is done below using the \texttt{coordinates} function, which promotes the \texttt{plots} data frame to a \texttt{SpatialPointsDataFrame}.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{>}\StringTok{ }\KeywordTok{coordinates}\NormalTok{(plots) <-}\StringTok{ }\ErrorTok{~}\NormalTok{easting}\OperatorTok{+}\NormalTok{northing}
\OperatorTok{>}\StringTok{ }
\ErrorTok{>}\StringTok{ }\KeywordTok{class}\NormalTok{(plots)}
\end{Highlighting}
\end{Shaded}

Although \texttt{plots} is now a \texttt{SpatialPointsDataFrame}, it does not know to which CRS the coordinates belong; hence, the \texttt{NA} when \texttt{proj4string(plots)} is called below. As noted in the \texttt{plots} file description above, \texttt{easting} and \texttt{northing} are in UTM zone 19. This CRS is set using the second call to \texttt{proj4string} below.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{>}\StringTok{ }\KeywordTok{proj4string}\NormalTok{(plots)}
\OperatorTok{>}\StringTok{ }
\ErrorTok{>}\StringTok{ }\KeywordTok{proj4string}\NormalTok{(plots) <-}\StringTok{ }\KeywordTok{CRS}\NormalTok{(}\StringTok{"+proj=utm +zone=19 +datum=NAD83 +units=m }
\StringTok{+                              +no_defs +ellps=GRS80 +towgs84=0,0,0"}\NormalTok{)                   }
\end{Highlighting}
\end{Shaded}

Now let's reproject \texttt{plots} to share a common CRS with \texttt{mu}

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{>}\StringTok{ }\NormalTok{plots <-}\StringTok{ }\KeywordTok{spTransform}\NormalTok{(plots, }\KeywordTok{CRS}\NormalTok{(}\StringTok{"+proj=longlat +datum=WGS84"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

Note, because \texttt{mu} is already in the projection we want for \texttt{plots}, we could have replaced the second argument in the \texttt{spTransform} call above with \texttt{proj4string(mu)} and saved some typing.

We're now ready to add the forest inventory plots to the existing basemap with management units. Specifically, let's map the \texttt{biomass\_mg\_ha} variable to show changes in biomass across the forest. No need to fortify \texttt{plots}, \texttt{ggplot} is happy to take \texttt{geom\_point}'s \texttt{data} argument as a data frame (although we do need to convert \texttt{plots} from a \texttt{SpatialPointsDataFrame} to a data frame using the \texttt{as.data.frame} function). Check out the \texttt{scale\_color\_gradient} function in your favorite \texttt{ggplot2} reference to understand how the color scale is set.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{>}\StringTok{ }\KeywordTok{ggmap}\NormalTok{(basemap) }\OperatorTok{+}
\OperatorTok{+}\StringTok{     }\KeywordTok{geom_polygon}\NormalTok{(}\DataTypeTok{data=}\NormalTok{mu.f, }\KeywordTok{aes}\NormalTok{(}\DataTypeTok{x =}\NormalTok{ long, }\DataTypeTok{y =}\NormalTok{ lat, }\DataTypeTok{group=}\NormalTok{group), }
\OperatorTok{+}\StringTok{                  }\DataTypeTok{fill=}\OtherTok{NA}\NormalTok{, }\DataTypeTok{size=}\FloatTok{0.2}\NormalTok{, }\DataTypeTok{color=}\StringTok{"orange"}\NormalTok{) }\OperatorTok{+}
\OperatorTok{+}\StringTok{     }\KeywordTok{geom_point}\NormalTok{(}\DataTypeTok{data=}\KeywordTok{as.data.frame}\NormalTok{(plots), }
\OperatorTok{+}\StringTok{                }\KeywordTok{aes}\NormalTok{(}\DataTypeTok{x =}\NormalTok{ easting, }\DataTypeTok{y =}\NormalTok{ northing, }\DataTypeTok{color=}\NormalTok{biomass_mg_ha)) }\OperatorTok{+}\StringTok{ }
\OperatorTok{+}\StringTok{     }\KeywordTok{scale_color_gradient}\NormalTok{(}\DataTypeTok{low=}\StringTok{"white"}\NormalTok{, }\DataTypeTok{high=}\StringTok{"darkblue"}\NormalTok{) }\OperatorTok{+}
\OperatorTok{+}\StringTok{     }\KeywordTok{labs}\NormalTok{(}\DataTypeTok{color =} \StringTok{"Biomass (mg/ha)"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

There is something subtle and easy to miss in the code above. Notice the \texttt{aes} function arguments in \texttt{geom\_points} take geographic longitude and latitude, \texttt{x} and \texttt{y} respectively, from the \texttt{points} data frame (but recall \texttt{easting} and \texttt{northing} were in UTM zone 19). This works because we applied \texttt{spTransform} to reproject the \texttt{points} \texttt{SpatialPointsDataFrame} to geographic coordinates. \texttt{sp} then replaces the values in \texttt{easting} and \texttt{northing} columns with the reprojected coordinate values when converting a \texttt{SpatialPointsDataFrame} to a data frame via \texttt{as.data.frame()}.

Foresters use the inventory plot measurements to estimate forest variables within management units, e.g., the average or total management unit biomass. Next we'll make a plot with management unit polygons colored by average \texttt{biomass\_mg\_ha}.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{>}\StringTok{ }\NormalTok{mu.bio <-}\StringTok{ }\NormalTok{plots}\OperatorTok{@}\NormalTok{data }\OperatorTok{%>%}\StringTok{ }\KeywordTok{group_by}\NormalTok{(mu_id) }\OperatorTok{%>%}\StringTok{ }
\OperatorTok{+}\StringTok{     }\KeywordTok{summarize}\NormalTok{(}\DataTypeTok{biomass_mu =} \KeywordTok{mean}\NormalTok{(biomass_mg_ha))}
\OperatorTok{>}\StringTok{ }\KeywordTok{print}\NormalTok{(mu.bio)}
\end{Highlighting}
\end{Shaded}

Recall from Section \ref{pipes} this one-liner can be read as ``get the data frame from \texttt{plots}'s \texttt{SpatialPointsDataFrame} \emph{then} group by management unit \emph{then} make a new variable called \texttt{biomass\_mu} that is the average of \texttt{biomass\_mg\_ha} and assign it to the \texttt{mu.bio} tibble.''

The management unit specific \texttt{biomass\_mu} can now be joined to the \texttt{mu} polygons using the common \texttt{mu\_id} value. Remember when we created the fortified version of \texttt{mu} called \texttt{mu.f}? The \texttt{fortify} function \texttt{region} argument was \texttt{mu\_id} which is the \texttt{id} variable in the resulting \texttt{mu.f}. This \texttt{id} variable in \texttt{mu.f} can be linked to the \texttt{mu\_id} variable in \texttt{mu.bio} using \texttt{dplyr}'s \texttt{left\_join} function as illustrated below.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{>}\StringTok{ }\KeywordTok{head}\NormalTok{(mu.f, }\DataTypeTok{n =} \DecValTok{2}\NormalTok{)}
\OperatorTok{>}\StringTok{ }
\ErrorTok{>}\StringTok{ }\NormalTok{mu.f <-}\StringTok{ }\KeywordTok{left_join}\NormalTok{(mu.f, mu.bio, }\DataTypeTok{by =} \KeywordTok{c}\NormalTok{(}\DataTypeTok{id =} \StringTok{"mu_id"}\NormalTok{))}
\OperatorTok{>}\StringTok{ }
\ErrorTok{>}\StringTok{ }\KeywordTok{head}\NormalTok{(mu.f, }\DataTypeTok{n =} \DecValTok{2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

The calls to \texttt{head()} show the first few rows of \texttt{mu.f} pre- and post-join. After the join, \texttt{mu.f} includes \texttt{biomass\_mu}, which is used used below for \texttt{geom\_polygon}'s \texttt{fill} argument to color the polygons accordingly.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{>}\StringTok{ }\KeywordTok{ggmap}\NormalTok{(basemap) }\OperatorTok{+}
\OperatorTok{+}\StringTok{     }\KeywordTok{geom_polygon}\NormalTok{(}\DataTypeTok{data=}\NormalTok{mu.f, }\KeywordTok{aes}\NormalTok{(}\DataTypeTok{x =}\NormalTok{ long, }\DataTypeTok{y =}\NormalTok{ lat, }
\OperatorTok{+}\StringTok{                                 }\DataTypeTok{group=}\NormalTok{group, }\DataTypeTok{fill=}\NormalTok{biomass_mu), }
\OperatorTok{+}\StringTok{                  }\DataTypeTok{size=}\FloatTok{0.2}\NormalTok{, }\DataTypeTok{color=}\StringTok{"orange"}\NormalTok{) }\OperatorTok{+}
\OperatorTok{+}\StringTok{     }\KeywordTok{scale_fill_gradient}\NormalTok{(}\DataTypeTok{low=}\StringTok{"white"}\NormalTok{, }\DataTypeTok{high=}\StringTok{"darkblue"}\NormalTok{, }
\OperatorTok{+}\StringTok{                         }\DataTypeTok{na.value=}\StringTok{"transparent"}\NormalTok{) }\OperatorTok{+}
\OperatorTok{+}\StringTok{     }\KeywordTok{labs}\NormalTok{(}\DataTypeTok{fill=}\StringTok{"Biomass (mg/ha)"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Let's add the roads and some more descriptive labels as a finishing touch. The roads data include a variable called \texttt{type} that identifies the road type. To color roads by type in the map, we need to join the \texttt{roads} data frame with the fortified roads \texttt{roads.f} using the common variable \texttt{id} as a road segment specific identifier. Then \texttt{geom\_path}'s \texttt{color} argument gets this \texttt{type} variable as a factor to create road-specific color. The default coloring of the roads blends in too much with the polygon colors, so we manually set the road colors using the \texttt{scale\_color\_brewer} function. The \texttt{palette} argument in this function accepts a set of key words, e.g., \texttt{"Dark2"}, that specify sets of diverging colors chosen to make map object difference optimally distinct (see, the manual page for \texttt{scale\_color\_brewer}, \url{http://colorbrewer2.org}, and blog \href{https://www.r-bloggers.com/r-using-rcolorbrewer-to-colour-your-figures-in-r}{here}.)\footnote{Install the \texttt{RColorBrewer} package and run \texttt{library(RColorBrewer);\ display.brewer.all()} to get a graphical list of available palettes.}

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{>}\StringTok{ }\NormalTok{roads <-}\StringTok{ }\KeywordTok{readOGR}\NormalTok{(}\StringTok{"PEF"}\NormalTok{, }\StringTok{"roads"}\NormalTok{)}
\OperatorTok{>}\StringTok{ }
\ErrorTok{>}\StringTok{ }\NormalTok{roads <-}\StringTok{ }\KeywordTok{spTransform}\NormalTok{(roads, }\KeywordTok{proj4string}\NormalTok{(mu))}
\OperatorTok{>}\StringTok{ }
\ErrorTok{>}\StringTok{ }\NormalTok{roads.f <-}\StringTok{ }\KeywordTok{fortify}\NormalTok{(roads, }\DataTypeTok{region=}\StringTok{"id"}\NormalTok{)}
\OperatorTok{>}\StringTok{ }\NormalTok{roads.f <-}\StringTok{ }\KeywordTok{left_join}\NormalTok{(roads.f, roads}\OperatorTok{@}\NormalTok{data, }\DataTypeTok{by =} \KeywordTok{c}\NormalTok{(}\StringTok{'id'}\NormalTok{ =}\StringTok{ 'id'}\NormalTok{))}
\OperatorTok{>}\StringTok{ }
\ErrorTok{>}\StringTok{ }\KeywordTok{ggmap}\NormalTok{(basemap) }\OperatorTok{+}
\OperatorTok{+}\StringTok{     }\KeywordTok{geom_polygon}\NormalTok{(}\DataTypeTok{data=}\NormalTok{mu.f, }\KeywordTok{aes}\NormalTok{(}\DataTypeTok{x =}\NormalTok{ long, }\DataTypeTok{y =}\NormalTok{ lat, }\DataTypeTok{group=}\NormalTok{group, }
\OperatorTok{+}\StringTok{                                 }\DataTypeTok{fill=}\NormalTok{biomass_mu), }
\OperatorTok{+}\StringTok{                  }\DataTypeTok{size=}\FloatTok{0.2}\NormalTok{, }\DataTypeTok{color=}\StringTok{"orange"}\NormalTok{) }\OperatorTok{+}
\OperatorTok{+}\StringTok{     }\KeywordTok{geom_path}\NormalTok{(}\DataTypeTok{data=}\NormalTok{roads.f, }\KeywordTok{aes}\NormalTok{(}\DataTypeTok{x =}\NormalTok{ long, }\DataTypeTok{y =}\NormalTok{ lat, }
\OperatorTok{+}\StringTok{                                 }\DataTypeTok{group=}\NormalTok{group, }\DataTypeTok{color=}\KeywordTok{factor}\NormalTok{(type))) }\OperatorTok{+}
\OperatorTok{+}\StringTok{     }\KeywordTok{scale_fill_gradient}\NormalTok{(}\DataTypeTok{low=}\StringTok{"white"}\NormalTok{, }\DataTypeTok{high=}\StringTok{"darkblue"}\NormalTok{, }
\OperatorTok{+}\StringTok{                         }\DataTypeTok{na.value=}\StringTok{"transparent"}\NormalTok{) }\OperatorTok{+}
\OperatorTok{+}\StringTok{     }\KeywordTok{scale_color_brewer}\NormalTok{(}\DataTypeTok{palette=}\StringTok{"Dark2"}\NormalTok{) }\OperatorTok{+}
\OperatorTok{+}\StringTok{     }\KeywordTok{labs}\NormalTok{(}\DataTypeTok{fill=}\StringTok{"Biomass (mg/ha)"}\NormalTok{, }\DataTypeTok{color=}\StringTok{"Road type"}\NormalTok{, }\DataTypeTok{xlab=}\StringTok{"Longitude"}\NormalTok{, }
\OperatorTok{+}\StringTok{          }\DataTypeTok{ylab=}\StringTok{"Latitude"}\NormalTok{, }\DataTypeTok{title=}\StringTok{"PEF forest biomass"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

The second, and more cryptic, of the two warnings from this code occurs because some of the roads extend beyond the range of the map axes and are removed (nothing to worry about).

\hypertarget{illustration-using-leaflet}{%
\section{\texorpdfstring{Illustration using \texttt{leaflet}}{Illustration using leaflet}}\label{illustration-using-leaflet}}

Leaflet is one of the most popular open-source JavaScript libraries for interactive maps. As noted on the official \href{https://rstudio.github.io/leaflet}{R leaflet website}, it's used by websites ranging from \emph{The New York Times} and \emph{The Washington Post} to GitHub and Flickr, as well as by GIS specialists like OpenStreetMap, Mapbox, and CartoDB.

The \href{https://rstudio.github.io/leaflet}{R leaflet website} is an excellent resource to learn leaflet basics, and should serve as a reference to gain a better understanding of the topics we briefly explore below.

You create a leaflet map using these basic steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Create a map by calling \texttt{leaflet()}
\item
  Add data layers to the map using layer functions such as, \texttt{addTiles()}, \texttt{addMarkers()}, \texttt{addPolygons()}, \texttt{addCircleMarkers()}, \texttt{addPolylines()}, \texttt{addRasterImage()} and other \texttt{add...} functions
\item
  Repeat step 2 to add more layers to the map
\item
  Print the map to display it
\end{enumerate}

Here's a brief example.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{>}\StringTok{ }\KeywordTok{library}\NormalTok{(leaflet)}
\OperatorTok{>}\StringTok{ }
\ErrorTok{>}\StringTok{ }\NormalTok{m <-}\StringTok{ }\KeywordTok{leaflet}\NormalTok{() }\OperatorTok{%>%}
\OperatorTok{+}\StringTok{       }\KeywordTok{addTiles}\NormalTok{() }\OperatorTok{%>%}\StringTok{  }\CommentTok{# Add default OpenStreetMap map tiles}
\OperatorTok{+}\StringTok{       }\KeywordTok{addMarkers}\NormalTok{(}\DataTypeTok{lng=}\OperatorTok{-}\FloatTok{84.482004}\NormalTok{, }\DataTypeTok{lat=}\FloatTok{42.727516}\NormalTok{, }
\OperatorTok{+}\StringTok{                  }\DataTypeTok{popup=}\StringTok{"<b>Here I am!</b>"}\NormalTok{) }\CommentTok{# Add a clickable marker}
\OperatorTok{>}\StringTok{ }\NormalTok{m  }\CommentTok{# Print the map}
\end{Highlighting}
\end{Shaded}

There are a couple things to note in the code. First, we use the pipe operator \texttt{\%\textgreater{}\%} just like in \texttt{dplyr} functions. Second, the \texttt{popup} argument in \texttt{addMarkers()} takes standard HTML and clicking on the marker makes the text popup. Third, the html version of this text provides the full interactive, dynamic map, so we encourage you to read and interact with the html version of this textbook for this section. The PDF document will simply display a static version of this map and will not do justice to how awesome \texttt{leaflet} truly is!

As seen in the \texttt{leaflet()} call above, the various \texttt{add...} functions can take longitude (i.e., \texttt{lng}) and latitude (i.e., \texttt{lat}). Alternatively, these functions can extract the necessary spatial information from \texttt{sp} objects, e.g., Table \ref{tab:spatialObjs}, when passed to the data argument (which greatly simplifies life compared with map making using \texttt{ggmap}).

\hypertarget{subsetting-spatial-data}{%
\section{Subsetting Spatial Data}\label{subsetting-spatial-data}}

You can imagine that we might want to subset spatial objects to map specific points, lines, or polygons that meet some criteria, or perhaps extract values from polygons or raster surfaces at a set of points or geographic extent. These, and similar types, of operations are easy in R (as long as all spatial objects are in a common CRS). Recall from Chapter \ref{data-structures} how handy it is to subset data structures, e.g., vectors and data frames, using the \texttt{{[}{]}} operator and logical vectors? Well it's just as easy to subset spatial objects, thanks to the authors of \texttt{sp}, \texttt{raster}, and other spatial data packages.

\hypertarget{fetching-and-cropping-data-using-raster}{%
\subsection{\texorpdfstring{Fetching and Cropping Data using \texttt{raster}}{Fetching and Cropping Data using raster}}\label{fetching-and-cropping-data-using-raster}}

In order to motivate our exploration of spatial data subsetting and to illustrate some useful functionality of the \texttt{raster} package, let's download some elevation data for the PEF. The \texttt{raster} package has a rich set of functions for manipulating raster data as well as functions for downloading data from open source repositories. We'll focus on the package's \texttt{getData} function, which, given a location in geographic longitude and latitude or location name, will download data from \href{http://www.gadm.org/\%7D\%7BGlobal\%20Administrative\%20Boundaries}{GADM}, \href{https://www2.jpl.nasa.gov/srtm/\%7D\%7BShuttle\%20Radar\%20Topography\%20Mission}{Shuttle Radar Topography Mission}, \href{http://www.worldclim.org/}{Global Climate Data}, and other sources commonly used in spatial data applications.

Let's download SRTM surface elevation data for the PEF, check the resulting object's class and CRS, and display it using the \texttt{raster} package's \texttt{image} function along with the PEF forest inventory plots.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{>}\StringTok{ }\KeywordTok{library}\NormalTok{(raster)}
\OperatorTok{>}\StringTok{ }
\ErrorTok{>}\StringTok{ }\NormalTok{pef.centroid <-}\StringTok{ }\KeywordTok{as.data.frame}\NormalTok{(plots) }\OperatorTok{%>%}\StringTok{ }
\OperatorTok{+}\StringTok{     }\KeywordTok{summarize}\NormalTok{(}\DataTypeTok{mu.x =} \KeywordTok{mean}\NormalTok{(easting), }\DataTypeTok{mu.y =} \KeywordTok{mean}\NormalTok{(northing))}
\OperatorTok{>}\StringTok{ }
\ErrorTok{>}\StringTok{ }\NormalTok{srtm <-}\StringTok{ }\KeywordTok{getData}\NormalTok{(}\StringTok{"SRTM"}\NormalTok{, }\DataTypeTok{lon =}\NormalTok{ pef.centroid[, }\DecValTok{1}\NormalTok{], }\DataTypeTok{lat =}\NormalTok{ pef.centroid[, }\DecValTok{2}\NormalTok{])}
\OperatorTok{>}\StringTok{ }
\ErrorTok{>}\StringTok{ }\NormalTok{srtm <-}\StringTok{ }\KeywordTok{raster}\NormalTok{(}\StringTok{"srtm_23_04.tif"}\NormalTok{)}
\OperatorTok{>}\StringTok{ }\KeywordTok{proj4string}\NormalTok{(srtm) <-}\StringTok{ "+proj=longlat +datum=WGS84 +ellps=WGS84 +towgs84=0,0,0"}
\OperatorTok{>}\StringTok{ }
\ErrorTok{>}\StringTok{ }\KeywordTok{class}\NormalTok{(srtm)}
\OperatorTok{>}\StringTok{ }
\ErrorTok{>}\StringTok{ }\KeywordTok{proj4string}\NormalTok{(srtm)}
\OperatorTok{>}\StringTok{ }
\ErrorTok{>}\StringTok{ }\KeywordTok{image}\NormalTok{(srtm)}
\OperatorTok{>}\StringTok{ }\KeywordTok{plot}\NormalTok{(plots, }\DataTypeTok{add =} \OtherTok{TRUE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

A few things to notice in the code above. First the \texttt{getData} function needs the longitude \texttt{lon} and latitude \texttt{lat} to identify which SRTM raster tile to return (SRTM data come in large raster tiles that cover the globe). As usual, look at the \texttt{getData} function documentation for a description of the arguments. To estimate the PEF's centroid coordinate, we averaged the forest inventory plots' latitude and longitude then assigned the result to \texttt{pef.centroid}. Second, there is currently a bug with downloading \texttt{SRTM} data using the \texttt{getData()} function. All the data are downloaded into your current directory, but the function does not properly load them into \texttt{R}. If you run this line yourself and get an error, continue going through the code we have. In the next line we load the data in ourselves using the call to \texttt{raster("srtm\_23\_04.tiff")}. I also manually change the coordinate system using the \texttt{proj4string} function. The \texttt{srtm} object result from our code to get around the bug is a \texttt{RasterLayer}, see Table \ref{tab:spatialObjs}. Third, \texttt{srtm} is in a longitude latitude geographic CRS (same as our other PEF data). Finally, the image shows SRTM elevation along the coast of Maine, the PEF plots are those tiny specks of black in the northwest quadrant, and the white region of the image is the Atlantic Ocean.

Okay, this is a start, but it would be good to crop the SRTM image to the PEF's extent. This is done using \texttt{raster}'s \texttt{crop} function. This function can use many different kinds of spatial objects in the second argument to calculate the extent at which to crop the object in the first argument. Here, I set \texttt{mu} as the second argument and save the resulting SRTM subset over the larger tile (the \texttt{srtm} object).

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{>}\StringTok{ }\NormalTok{srtm <-}\StringTok{ }\KeywordTok{crop}\NormalTok{(srtm, mu)}
\OperatorTok{>}\StringTok{ }
\ErrorTok{>}\StringTok{ }\KeywordTok{image}\NormalTok{(srtm)}
\OperatorTok{>}\StringTok{ }\KeywordTok{plot}\NormalTok{(mu, }\DataTypeTok{add =} \OtherTok{TRUE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

The \texttt{crop} is in effect doing a spatial setting of the raster data. We'll return to the \texttt{srtm} data and explore different kinds of subsetting in the subsequent sections.

\hypertarget{logical-index-and-name-subsetting}{%
\subsection{Logical, Index, and Name Subsetting}\label{logical-index-and-name-subsetting}}

As promised, we can subset spatial objects using the \texttt{{[}{]}} operator and a logical, index, or name vector. The key is that \texttt{sp} objects behave like data frames, see Section \ref{data-frames}. A logical or index vector to the left of the comma in \texttt{{[},{]}} accesses points, lines, polygons, or pixels. Similarly, a logical, index, or name vector to the right of the comma accesses variables.

For example, say we want to map forest inventory plots with more than 10,000 stems per hectare, \texttt{stems\_ha} (the \texttt{min()} was added below to double check that the subset worked correctly.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{>}\StringTok{ }\KeywordTok{min}\NormalTok{(plots}\OperatorTok{$}\NormalTok{stems_ha)}
\OperatorTok{>}\StringTok{ }
\ErrorTok{>}\StringTok{ }\NormalTok{plots}\FloatTok{.10}\NormalTok{k <-}\StringTok{ }\NormalTok{plots[plots}\OperatorTok{$}\NormalTok{stems_ha }\OperatorTok{>}\StringTok{ }\DecValTok{10000}\NormalTok{, ]}
\OperatorTok{>}\StringTok{ }
\ErrorTok{>}\StringTok{ }\KeywordTok{min}\NormalTok{(plots}\FloatTok{.10}\NormalTok{k}\OperatorTok{$}\NormalTok{stems_ha)}
\end{Highlighting}
\end{Shaded}

You can also add new variables to the spatial objects.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{>}\StringTok{ }\NormalTok{plots}\OperatorTok{$}\NormalTok{diameter_in <-}\StringTok{ }\NormalTok{plots}\OperatorTok{$}\NormalTok{diameter_cm}\OperatorTok{/}\FloatTok{2.54}
\OperatorTok{>}\StringTok{ }
\ErrorTok{>}\StringTok{ }\KeywordTok{head}\NormalTok{(plots)}
\end{Highlighting}
\end{Shaded}

\hypertarget{spatial-subsetting-and-overlay}{%
\subsection{Spatial Subsetting and Overlay}\label{spatial-subsetting-and-overlay}}

A spatial overlay retrieves the indexes or variables from object \(A\) using the location of object \(B\). With some spatial objects this operation can be done using the \texttt{{[}{]}} operator. For example, say we want to select and map all management units in \texttt{mu}, i.e., \(A\), that contain plots with more than 10,000 stems per ha, i.e., \(B\).

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{>}\StringTok{ }\NormalTok{mu}\FloatTok{.10}\NormalTok{k <-}\StringTok{ }\NormalTok{mu[plots}\FloatTok{.10}\NormalTok{k, ]  }\CommentTok{## A[B,]}
\OperatorTok{>}\StringTok{ }
\ErrorTok{>}\StringTok{ }\NormalTok{mu}\FloatTok{.10}\NormalTok{k.f <-}\StringTok{ }\KeywordTok{fortify}\NormalTok{(mu}\FloatTok{.10}\NormalTok{k, }\DataTypeTok{region =} \StringTok{"mu_id"}\NormalTok{)}
\OperatorTok{>}\StringTok{ }
\ErrorTok{>}\StringTok{ }\KeywordTok{ggmap}\NormalTok{(basemap) }\OperatorTok{+}\StringTok{ }\KeywordTok{geom_polygon}\NormalTok{(}\DataTypeTok{data =}\NormalTok{ mu}\FloatTok{.10}\NormalTok{k.f, }\KeywordTok{aes}\NormalTok{(}\DataTypeTok{x =}\NormalTok{ long, }
\OperatorTok{+}\StringTok{   }\DataTypeTok{y =}\NormalTok{ lat, }\DataTypeTok{group =}\NormalTok{ group), }\DataTypeTok{fill =} \StringTok{"transparent"}\NormalTok{, }\DataTypeTok{size =} \FloatTok{0.2}\NormalTok{, }
\OperatorTok{+}\StringTok{   }\DataTypeTok{color =} \StringTok{"orange"}\NormalTok{) }\OperatorTok{+}\StringTok{ }\KeywordTok{geom_point}\NormalTok{(}\DataTypeTok{data =} \KeywordTok{as.data.frame}\NormalTok{(plots}\FloatTok{.10}\NormalTok{k), }
\OperatorTok{+}\StringTok{   }\KeywordTok{aes}\NormalTok{(}\DataTypeTok{x =}\NormalTok{ easting, }\DataTypeTok{y =}\NormalTok{ northing), }\DataTypeTok{color =} \StringTok{"white"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

More generally, however, the \texttt{over} function offers consistent overlay operations for \texttt{sp} objects and can return either indexes or variables from object \(A\) given locations from object \(B\), i.e., \texttt{over(B,\ A)} or, equivalently, \texttt{B\%over\%A}. The code below duplicates the result from the preceding example using \texttt{over}.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{>}\StringTok{ }\NormalTok{mu}\FloatTok{.10}\NormalTok{k <-}\StringTok{ }\NormalTok{mu[mu}\OperatorTok{$}\NormalTok{mu_id }\OperatorTok{%in%}\StringTok{ }\KeywordTok{unique}\NormalTok{(}\KeywordTok{over}\NormalTok{(plots}\FloatTok{.10}\NormalTok{k, mu)}\OperatorTok{$}\NormalTok{mu_id), }
\OperatorTok{+}\StringTok{   }\NormalTok{]}
\end{Highlighting}
\end{Shaded}

Yes, this requires more code but \texttt{over} provides a more flexible and general purpose function for overlays on the variety of \texttt{sp} objects. Let's unpack this one-liner into its five steps.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{>}\StringTok{ }\NormalTok{i <-}\StringTok{ }\KeywordTok{over}\NormalTok{(plots}\FloatTok{.10}\NormalTok{k, mu)}
\OperatorTok{>}\StringTok{ }\NormalTok{ii <-}\StringTok{ }\NormalTok{i}\OperatorTok{$}\NormalTok{mu_id}
\OperatorTok{>}\StringTok{ }\NormalTok{iii <-}\StringTok{ }\KeywordTok{unique}\NormalTok{(ii)}
\OperatorTok{>}\StringTok{ }\NormalTok{iv <-}\StringTok{ }\NormalTok{mu}\OperatorTok{$}\NormalTok{mu_id }\OperatorTok{%in%}\StringTok{ }\NormalTok{iii}
\OperatorTok{>}\StringTok{ }\NormalTok{v <-}\StringTok{ }\NormalTok{mu[iv, ]}
\end{Highlighting}
\end{Shaded}

\begin{enumerate}
\def\labelenumi{\roman{enumi}.}
\tightlist
\item
  The \texttt{over} function returns variables for \texttt{mu}'s polygons that coincide with the \texttt{nrow(plots.10k@data)} points in \texttt{plots.10k}. No points fall outside the polygons and the polygons do not overlap, so \(i\) should be a data frame with \texttt{nrow(plots.10k@data)} rows. If polygons did overlap and a point fell within the overlap region, then variables for the coinciding polygons are returned.
\item
  Select the unique \texttt{mu} identifier \texttt{mu\_id} (this step is actually not necessary here because \texttt{mu} only has one variable).
\item
  Because some management units contain multiple plots there will be repeat values of \texttt{mu\_id} in \emph{ii}, so apply the \texttt{unique} function to get rid of duplicates.
\item
  Use the \texttt{\%in\%} operator to create a logical vector that identifies which polygons should be in the final map.
\item
  Subset \texttt{mu} using the logical vector created in \(iv\).
\end{enumerate}

Now let's do something similar using the \texttt{srtm} elevation raster. Say we want to map elevation along trails, winter roads, and gravel roads across the PEF. We could subset \texttt{srtm} using the \texttt{roads} \texttt{SpatialLinesDataFrame}; however, mapping the resulting pixel values along the road segments using \texttt{ggmap} requires a bit more massaging. So, to simplify things for this example, \texttt{roads} is first coerced into a \texttt{SpatialPointsDataFrame} called \texttt{roads.pts} that is used to extract spatially coinciding \texttt{srtm} pixel values which themselves are coerced from \texttt{raster}'s \texttt{RasterLayer} to \texttt{sp}'s \texttt{SpatialPixelsDataFrame} called \texttt{srtm.sp} so that we can use the \texttt{over} function. We also choose a different basemap just for fun.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{>}\StringTok{ }\NormalTok{hikes <-}\StringTok{ }\NormalTok{roads[roads}\OperatorTok{$}\NormalTok{type }\OperatorTok{%in%}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"Trail"}\NormalTok{, }\StringTok{"Winter"}\NormalTok{, }\StringTok{"Gravel"}\NormalTok{),]}
\OperatorTok{>}\StringTok{  }
\ErrorTok{>}\StringTok{ }\NormalTok{hikes.pts <-}\StringTok{ }\KeywordTok{as}\NormalTok{(hikes, }\StringTok{"SpatialPointsDataFrame"}\NormalTok{)}
\OperatorTok{>}\StringTok{ }\NormalTok{srtm.sp <-}\StringTok{ }\KeywordTok{as}\NormalTok{(srtm, }\StringTok{"SpatialPixelsDataFrame"}\NormalTok{)}
\OperatorTok{>}\StringTok{ }
\ErrorTok{>}\StringTok{ }\NormalTok{hikes.pts}\OperatorTok{$}\NormalTok{srtm <-}\StringTok{ }\KeywordTok{over}\NormalTok{(hikes.pts, srtm.sp)}
\OperatorTok{>}\StringTok{ }
\ErrorTok{>}\StringTok{ }\NormalTok{basemap <-}\StringTok{ }\KeywordTok{get_map}\NormalTok{(}\DataTypeTok{location=}\NormalTok{mu.bbox,  }\DataTypeTok{zoom =} \DecValTok{14}\NormalTok{, }\DataTypeTok{maptype=}\StringTok{"terrain"}\NormalTok{)}
\OperatorTok{>}\StringTok{ }
\ErrorTok{>}\StringTok{ }\NormalTok{color.vals <-}\StringTok{ }\NormalTok{srtm}\OperatorTok{@}\NormalTok{data}\OperatorTok{@}\NormalTok{values[}\DecValTok{1}\OperatorTok{:}\KeywordTok{length}\NormalTok{(hikes.pts)]}
\OperatorTok{>}\StringTok{ }
\ErrorTok{>}\StringTok{ }\KeywordTok{ggmap}\NormalTok{(basemap) }\OperatorTok{+}
\OperatorTok{+}\StringTok{     }\KeywordTok{geom_point}\NormalTok{(}\DataTypeTok{data=}\KeywordTok{as.data.frame}\NormalTok{(hikes.pts),}
\OperatorTok{+}\StringTok{                }\KeywordTok{aes}\NormalTok{(}\DataTypeTok{x =}\NormalTok{ coords.x1, }\DataTypeTok{y =}\NormalTok{ coords.x2, }\DataTypeTok{color =}\NormalTok{ color.vals)) }\OperatorTok{+}
\OperatorTok{+}\StringTok{     }\KeywordTok{scale_color_gradient}\NormalTok{(}\DataTypeTok{low=}\StringTok{"green"}\NormalTok{, }\DataTypeTok{high=}\StringTok{"red"}\NormalTok{) }\OperatorTok{+}
\OperatorTok{+}\StringTok{     }\KeywordTok{labs}\NormalTok{(}\DataTypeTok{color =} \StringTok{"Hiking trail elevation}\CharTok{\textbackslash{}n}\StringTok{(m above sea level)"}\NormalTok{,}
\OperatorTok{+}\StringTok{          }\DataTypeTok{xlab=}\StringTok{"Longitude"}\NormalTok{, }\DataTypeTok{ylab=}\StringTok{"Latitude"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

In the call to \texttt{geom\_point} above, \texttt{coords.x1} \texttt{coords.x2} are the default names given to longitude and latitude, respectively, when \texttt{sp} coerces \texttt{hikes} to \texttt{hikes.pts}. These points represent the vertices along line segments. I create the vector \texttt{color.vals} that contains the values from \texttt{srtm} that I use in the map argument \texttt{color}. Normally, I would be able to simply use the argument \texttt{color\ =\ srtm} in the graph, but since there is a bug in the \texttt{getData} function I mentioned earlier, we need to do another workaround here.

Overlay operations involving lines and polygons over polygons require the \texttt{rgeos} package which provides an interface to the \href{https://trac.osgeo.org/geos/}{Geometry Engine - Open Source} (GEOS) \texttt{C++} library for topology operations on geometries. We'll leave it to you to explore these capabilities.

\hypertarget{spatial-aggregation}{%
\subsection{Spatial Aggregation}\label{spatial-aggregation}}

We have seen aggregation operations before when using \texttt{dplyr}'s \texttt{summarize} function. The \texttt{summarize} function is particularly powerful when combined with \texttt{group\_by()}, which can apply a function specified in \texttt{summarize()} to a variable partitioned using a grouping variable. The \texttt{aggregate} function in \texttt{sp} works in a similar manner, except groups are delineated by the spatial extent of a thematic variable. In fact, the work we did to create \texttt{mu.bio} using \texttt{dplyr} functions can be accomplished with \texttt{aggregate()}. Using \texttt{aggregate()} will, however, require a slightly different approach for joining the derived average \texttt{biomass\_mg\_ha} to the fortified \texttt{mu}. This is because the \texttt{aggregate} function will apply the user specified function to all variables in the input object, which, in our case, results in an \texttt{NA} for the linking variable \texttt{mu\_id} as demonstrated below.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{>}\StringTok{ }\NormalTok{mu.ag <-}\StringTok{ }\KeywordTok{aggregate}\NormalTok{(plots[, }\KeywordTok{c}\NormalTok{(}\StringTok{"mu_id"}\NormalTok{, }\StringTok{"biomass_mg_ha"}\NormalTok{)], }
\OperatorTok{+}\StringTok{   }\DataTypeTok{by =}\NormalTok{ mu, }\DataTypeTok{FUN =}\NormalTok{ mean)}
\OperatorTok{>}\StringTok{ }
\ErrorTok{>}\StringTok{ }\KeywordTok{head}\NormalTok{(mu.ag}\OperatorTok{@}\NormalTok{data, }\DataTypeTok{n =} \DecValTok{2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

With \texttt{mu\_id} rendered useless, we do not have a variable that uniquely identifies each polygon for use in \texttt{fortify}'s \texttt{region} argument; hence no way to subsequently join the unfortified and fortified versions of \texttt{mu.bio.ag}. Here's the work around. If the \texttt{region} is not specified, \texttt{fortify()} uses an internal unique polygon ID that is part of the \texttt{sp} data object and accessed via \texttt{row.names()}\footnote{With other data, there is a chance the row names differ from the unique polygon IDs. Therefore a more reliable approach to getting a unique ID is to use \texttt{sapply(slot(mu.ag,\ \textquotesingle{}polygons\textquotesingle{}),\ function(x)\ slot(x,\ \textquotesingle{}ID\textquotesingle{}))}, but replace \texttt{mu.ag} with your \texttt{SpatialPolygonsDataFrame}. Also, this approach will work with other \texttt{sp} objects in the right column of Table \ref{tab:spatialObjs}.} So, the trick is to add this unique polygon ID to the \texttt{aggregate()} output prior to calling \texttt{fortify()} as demonstrated below.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{>}\StringTok{ }\NormalTok{mu.ag}\OperatorTok{$}\NormalTok{id <-}\StringTok{ }\KeywordTok{row.names}\NormalTok{(mu.ag)}
\OperatorTok{>}\StringTok{ }
\ErrorTok{>}\StringTok{ }\NormalTok{mu.ag.f <-}\StringTok{ }\KeywordTok{fortify}\NormalTok{(mu.ag)}
\OperatorTok{>}\StringTok{ }
\ErrorTok{>}\StringTok{ }\NormalTok{mu.ag.f <-}\StringTok{ }\KeywordTok{left_join}\NormalTok{(mu.ag.f, mu.ag}\OperatorTok{@}\NormalTok{data)}
\OperatorTok{>}\StringTok{ }
\ErrorTok{>}\StringTok{ }\KeywordTok{ggmap}\NormalTok{(basemap) }\OperatorTok{+}\StringTok{ }\KeywordTok{geom_polygon}\NormalTok{(}\DataTypeTok{data =}\NormalTok{ mu.ag.f, }\KeywordTok{aes}\NormalTok{(}\DataTypeTok{x =}\NormalTok{ long, }
\OperatorTok{+}\StringTok{   }\DataTypeTok{y =}\NormalTok{ lat, }\DataTypeTok{group =}\NormalTok{ group, }\DataTypeTok{fill =}\NormalTok{ biomass_mg_ha), }\DataTypeTok{size =} \FloatTok{0.2}\NormalTok{, }
\OperatorTok{+}\StringTok{   }\DataTypeTok{color =} \StringTok{"orange"}\NormalTok{) }\OperatorTok{+}\StringTok{ }\KeywordTok{scale_fill_gradient}\NormalTok{(}\DataTypeTok{low =} \StringTok{"white"}\NormalTok{, }
\OperatorTok{+}\StringTok{   }\DataTypeTok{high =} \StringTok{"darkblue"}\NormalTok{, }\DataTypeTok{na.value =} \StringTok{"transparent"}\NormalTok{) }\OperatorTok{+}\StringTok{ }\KeywordTok{labs}\NormalTok{(}\DataTypeTok{fill =} \StringTok{"Biomass (mg/ha)"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

The \texttt{aggregate()} function will work with all \texttt{sp} objects. For example let's map the variance of pixel values in \texttt{srtm.sp} by management unit. Notice that \texttt{aggregate()} is happy to take a user-specified function for \texttt{FUN}.

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{>}\StringTok{ }\NormalTok{mu.srtm <-}\StringTok{ }\KeywordTok{aggregate}\NormalTok{(srtm.sp, }\DataTypeTok{by=}\NormalTok{mu,}
\OperatorTok{+}\StringTok{                      }\DataTypeTok{FUN=}\ControlFlowTok{function}\NormalTok{(x)\{}\KeywordTok{sqrt}\NormalTok{(}\KeywordTok{var}\NormalTok{(x))\})}
\OperatorTok{>}\StringTok{ }
\ErrorTok{>}\StringTok{ }\NormalTok{mu.srtm}\OperatorTok{$}\NormalTok{id <-}\StringTok{ }\KeywordTok{row.names}\NormalTok{(mu.srtm)}
\OperatorTok{>}\StringTok{ }
\ErrorTok{>}\StringTok{ }\NormalTok{mu.srtm.f <-}\StringTok{ }\KeywordTok{fortify}\NormalTok{(mu.srtm)}
\OperatorTok{>}\StringTok{ }
\ErrorTok{>}\StringTok{ }\NormalTok{mu.srtm.f <-}\StringTok{ }\KeywordTok{left_join}\NormalTok{(mu.srtm.f, mu.srtm}\OperatorTok{@}\NormalTok{data)}
\OperatorTok{>}\StringTok{ }
\ErrorTok{>}\StringTok{ }\KeywordTok{ggmap}\NormalTok{(basemap) }\OperatorTok{+}
\OperatorTok{+}\StringTok{     }\KeywordTok{geom_polygon}\NormalTok{(}\DataTypeTok{data=}\NormalTok{mu.srtm.f, }\KeywordTok{aes}\NormalTok{(}\DataTypeTok{x =}\NormalTok{ long, }\DataTypeTok{y =}\NormalTok{ lat, }\DataTypeTok{group=}\NormalTok{group, }
\OperatorTok{+}\StringTok{                                      }\DataTypeTok{fill=}\NormalTok{srtm_}\DecValTok{23}\NormalTok{_}\DecValTok{04}\NormalTok{), }
\OperatorTok{+}\StringTok{                  }\DataTypeTok{size=}\FloatTok{0.2}\NormalTok{, }\DataTypeTok{color=}\StringTok{"orange"}\NormalTok{) }\OperatorTok{+}
\OperatorTok{+}\StringTok{     }\KeywordTok{scale_fill_gradient}\NormalTok{(}\DataTypeTok{low=}\StringTok{"green"}\NormalTok{, }\DataTypeTok{high=}\StringTok{"red"}\NormalTok{) }\OperatorTok{+}
\OperatorTok{+}\StringTok{         }\KeywordTok{labs}\NormalTok{(}\DataTypeTok{fill =} \StringTok{"Elevation standard deviation}\CharTok{\textbackslash{}n}\StringTok{(m above sea level)"}\NormalTok{, }
\OperatorTok{+}\StringTok{          }\DataTypeTok{xlab=}\StringTok{"Longitude"}\NormalTok{, }\DataTypeTok{ylab=}\StringTok{"Latitude"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\hypertarget{where-to-go-from-here}{%
\section{Where to go from here}\label{where-to-go-from-here}}

This chapter just scratches the surface of R's spatial data manipulation and visualization capabilities. The basic ideas we presented here should allow you to take a deeper look into \texttt{sp}, \texttt{rgdal}, \texttt{rgeos}, \texttt{ggmap}, \texttt{leaflet}, and a myriad of other excellent user-contributed R spatial data packages. A good place to start is with Edzer Pebesma's excellent vignette on the use of the map overlay and spatial aggregation, available \href{https://cran.r-project.org/web/packages/sp/vignettes/over.pdf}{here}, as well as \emph{Applied Spatial Data Analysis with R} by \cite{Bivand13}.

\bibliography{book.bib,packages.bib}

\backmatter
\printindex

\end{document}
