[
["xml.html", "Chapter 12 Text Data 12.1 Reading Text Data into R 12.2 The paste Function 12.3 More String Processing Functions 12.4 Homework", " Chapter 12 Text Data Many applications require the ability to manipulate and process text data. For example, an email spam filter takes as its input various features of email such as the sender, words in the subject, words in the body, the number and types of attachments, and so on. The filter then tries to build a classifier which can correctly classify a message as spam or not spam (aka ham). As another example, some works of literature, such as some of Shakespeare’s plays or some of the Federalist papers, have disputed authorship. By analyzing word use across many documents, researchers try to determine the author of the disputed work. Working with text data requires functions that will, for example, concatenate and split text strings, modify strings (e.g., converting to lower-case or removing vowels), count the number of characters in a string, and so on. In addition to being useful in such contexts, string manipulation is helpful more generally in R—for example, to effectively construct titles for graphics. As with most tasks, there are a variety of ways to accomplish these text processing tasks in R. The base R package has functions which work with and modify text strings. Another useful package which approaches these tasks in a slightly different way is stringr. As with graphics, we will focus mainly on one package to avoid confusion. In this case we will focus on the base R string processing functions, but will emphasize that stringr is also worth knowing. The application to analyzing Moby Dick below comes from the book {Text Analysis with R for Students of Literature by Matthew L. Jockers. 12.1 Reading Text Data into R Often text data will not be in a rectangular format that is suitable for reading into a data frame. For example, an email used to help train a spam filter, or literary texts used to help determine authorship of a novel are certainly not of this form. Often when working with text data we want to read the whole text object into a single R vector. In this case either the scan function or the readLines function are useful. The readLines function is typically more efficient, but scan is much more flexible. As an example, consider the following email message and a plain text version of the novel Moby Dick by Herman Melville, the beginning of which is displayed subsequently. From safety33o@l11.newnamedns.com Fri Aug 23 11:03:37 2002 Return-Path: &lt;safety33o@l11.newnamedns.com&gt; Delivered-To: zzzz@localhost.example.com Received: from localhost (localhost [127.0.0.1]) by phobos.labs.example.com (Postfix) with ESMTP id 5AC994415F for &lt;zzzz@localhost&gt;; Fri, 23 Aug 2002 06:02:59 -0400 (EDT) Received: from mail.webnote.net [193.120.211.219] by localhost with POP3 (fetchmail-5.9.0) for zzzz@localhost (single-drop); Fri, 23 Aug 2002 11:02:59 +0100 (IST) Received: from l11.newnamedns.com ([64.25.38.81]) by webnote.net (8.9.3/8.9.3) with ESMTP id KAA09379 for &lt;zzzz@example.com&gt;; Fri, 23 Aug 2002 10:18:03 +0100 From: safety33o@l11.newnamedns.com Date: Fri, 23 Aug 2002 02:16:25 -0400 Message-Id: &lt;200208230616.g7N6GOR28438@l11.newnamedns.com&gt; To: kxzzzzgxlrah@l11.newnamedns.com Reply-To: safety33o@l11.newnamedns.com Subject: ADV: Lowest life insurance rates available! moode Lowest rates available for term life insurance! Take a moment and fill out our online form to see the low rate you qualify for. Save up to 70% from regular rates! Smokers accepted! http://www.newnamedns.com/termlife/ Representing quality nationwide carriers. Act now! The Project Gutenberg EBook of Moby Dick; or The Whale, by Herman Melville This eBook is for the use of anyone anywhere at no cost and with almost no restrictions whatsoever. You may copy it, give it away or re-use it under the terms of the Project Gutenberg License included with this eBook or online at www.gutenberg.org Title: Moby Dick; or The Whale Author: Herman Melville Last Updated: January 3, 2009 Posting Date: December 25, 2008 [EBook #2701] Release Date: June, 2001 Language: English *** START OF THIS PROJECT GUTENBERG EBOOK MOBY DICK; OR THE WHALE *** Produced by Daniel Lazarus and Jonesey MOBY DICK; OR THE WHALE By Herman Melville The email message is available at http://blue.for.msu.edu/FOR875/data/email1.txt while the novel is available at http://blue.for.msu.edu/FOR875/data/mobydick.txt. We will read these into R using scan. First, we read in the email message. The scan function has several possible arguments. For now the important arguments are the file to be read (the argument is named file), the type of data in the file (the argument is named what), and how the fields in the file are separated (the argument is named sep). To illustrate the sep argument, the file will be read into R once with sep = &quot;&quot; indicating that the separator is whitespace, and once with sep = &quot;\\n&quot; indicating that the separator is the newline character, i.e., each field in the file is a line. u.email &lt;- &quot;http://blue.for.msu.edu/FOR875/data/email1.txt&quot; email1 &lt;- scan(u.email, what = &quot;character&quot;, sep = &quot;&quot;) length(email1) ## [1] 133 email1[1:10] ## [1] &quot;From&quot; &quot;safety33o@l11.newnamedns.com&quot; ## [3] &quot;Fri&quot; &quot;Aug&quot; ## [5] &quot;23&quot; &quot;11:03:37&quot; ## [7] &quot;2002&quot; &quot;Return-Path:&quot; ## [9] &quot;&lt;safety33o@l11.newnamedns.com&gt;&quot; &quot;Delivered-To:&quot; email1 &lt;- scan(u.email, what = &quot;character&quot;, sep = &quot;\\n&quot;) length(email1) ## [1] 26 email1[1:10] ## [1] &quot;From safety33o@l11.newnamedns.com Fri Aug 23 11:03:37 2002&quot; ## [2] &quot;Return-Path: &lt;safety33o@l11.newnamedns.com&gt;&quot; ## [3] &quot;Delivered-To: zzzz@localhost.example.com&quot; ## [4] &quot;Received: from localhost (localhost [127.0.0.1])&quot; ## [5] &quot;\\tby phobos.labs.example.com (Postfix) with ESMTP id 5AC994415F&quot; ## [6] &quot;\\tfor &lt;zzzz@localhost&gt;; Fri, 23 Aug 2002 06:02:59 -0400 (EDT)&quot; ## [7] &quot;Received: from mail.webnote.net [193.120.211.219]&quot; ## [8] &quot;\\tby localhost with POP3 (fetchmail-5.9.0)&quot; ## [9] &quot;\\tfor zzzz@localhost (single-drop); Fri, 23 Aug 2002 11:02:59 +0100 (IST)&quot; ## [10] &quot;Received: from l11.newnamedns.com ([64.25.38.81])&quot; Note that when sep = &quot;&quot; was specified, every time whitespace was encountered R moved to a new element of the vector email1, and this vector ultimately contained 133 elements. When sep = &quot;\\n&quot; was specified, all the text before a newline was put into one element of the vector, which ended up with 26 elements. The scan function is quite flexible. In fact, read.table uses scan to actually read in the data. Read the help file for scan if more information is desired. Next Moby Dick is read in line by line. u.moby &lt;- &quot;http://blue.for.msu.edu/FOR875/data/mobydick.txt&quot; moby_dick &lt;- scan(u.moby, what = &quot;character&quot;, sep = &quot;\\n&quot;) moby_dick[1:25] ## [1] &quot;The Project Gutenberg EBook of Moby Dick; or The Whale, by Herman Melville&quot; ## [2] &quot;This eBook is for the use of anyone anywhere at no cost and with&quot; ## [3] &quot;almost no restrictions whatsoever. You may copy it, give it away or&quot; ## [4] &quot;re-use it under the terms of the Project Gutenberg License included&quot; ## [5] &quot;with this eBook or online at www.gutenberg.org&quot; ## [6] &quot;Title: Moby Dick; or The Whale&quot; ## [7] &quot;Author: Herman Melville&quot; ## [8] &quot;Last Updated: January 3, 2009&quot; ## [9] &quot;Posting Date: December 25, 2008 [EBook #2701]&quot; ## [10] &quot;Release Date: June, 2001&quot; ## [11] &quot;Language: English&quot; ## [12] &quot;*** START OF THIS PROJECT GUTENBERG EBOOK MOBY DICK; OR THE WHALE ***&quot; ## [13] &quot;Produced by Daniel Lazarus and Jonesey&quot; ## [14] &quot;MOBY DICK; OR THE WHALE&quot; ## [15] &quot;By Herman Melville&quot; ## [16] &quot;Original Transcriber&#39;s Notes:&quot; ## [17] &quot;This text is a combination of etexts, one from the now-defunct ERIS&quot; ## [18] &quot;project at Virginia Tech and one from Project Gutenberg&#39;s archives. The&quot; ## [19] &quot;proofreaders of this version are indebted to The University of Adelaide&quot; ## [20] &quot;Library for preserving the Virginia Tech version. The resulting etext&quot; ## [21] &quot;was compared with a public domain hard copy version of the text.&quot; ## [22] &quot;In chapters 24, 89, and 90, we substituted a capital L for the symbol&quot; ## [23] &quot;for the British pound, a unit of currency.&quot; ## [24] &quot;ETYMOLOGY.&quot; ## [25] &quot;(Supplied by a Late Consumptive Usher to a Grammar School)&quot; You will notice that the scan function ignored blank lines in the file. If it is important to preserve blank lines, the argument blank.lines.skip = FALSE can be supplied to scan. The file containing the novel contains some introductory and closing text that is not part of the original novel. If we are interested in Melville’s writing, we should remove this text. By inspection we can discover that the novel’s text begins at position 408 and ends at position 18576. moby_dick &lt;- moby_dick[408:18576] length(moby_dick) ## [1] 18169 moby_dick[1:4] ## [1] &quot;CHAPTER 1. Loomings.&quot; ## [2] &quot;Call me Ishmael. Some years ago--never mind how long precisely--having&quot; ## [3] &quot;little or no money in my purse, and nothing particular to interest me on&quot; ## [4] &quot;shore, I thought I would sail about a little and see the watery part of&quot; moby_dick[18165:18169] ## [1] &quot;they glided by as if with padlocks on their mouths; the savage sea-hawks&quot; ## [2] &quot;sailed with sheathed beaks. On the second day, a sail drew near, nearer,&quot; ## [3] &quot;and picked me up at last. It was the devious-cruising Rachel, that in&quot; ## [4] &quot;her retracing search after her missing children, only found another&quot; ## [5] &quot;orphan.&quot; 12.2 The paste Function The paste function concatenates vectors after (if necessary) converting the vectors to character. paste(&quot;Homer Simpson&quot;, &quot;is&quot;, &quot;Bart Simpson&#39;s&quot;, &quot;father&quot;) ## [1] &quot;Homer Simpson is Bart Simpson&#39;s father&quot; n &lt;- 10 paste(&quot;The value of n is&quot;, n) ## [1] &quot;The value of n is 10&quot; paste(c(&quot;pig&quot;, &quot;dog&quot;), 3) ## [1] &quot;pig 3&quot; &quot;dog 3&quot; By default the paste function separates the input vectors with a space. But other separators can be specified. paste(&quot;mail&quot;, &quot;google&quot;, &quot;com&quot;, sep=&quot;.&quot;) ## [1] &quot;mail.google.com&quot; paste(&quot;and&quot;, &quot;or&quot;, sep = &quot;/&quot;) ## [1] &quot;and/or&quot; paste(c(&quot;dog&quot;, &quot;cat&quot;, &quot;horse&quot;, &quot;human&quot;, &quot;elephant&quot;), &quot;food&quot;) ## [1] &quot;dog food&quot; &quot;cat food&quot; &quot;horse food&quot; &quot;human food&quot; ## [5] &quot;elephant food&quot; Sometimes we want to take a character vector with \\(n\\) elements and create a character vector with only one element, which contains all \\(n\\) character strings. Setting the collapse argument to something other than the default NULL tells R we want to do this, and allows specification of the separator in the collapsed vector. paste(c(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;, &quot;five&quot;), c(&quot;six&quot;, &quot;seven&quot;, &quot;eight&quot;, &quot;nine&quot;, &quot;ten&quot;)) ## [1] &quot;one six&quot; &quot;two seven&quot; &quot;three eight&quot; &quot;four nine&quot; &quot;five ten&quot; paste(c(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;, &quot;five&quot;), c(&quot;six&quot;, &quot;seven&quot;, &quot;eight&quot;, &quot;nine&quot;, &quot;ten&quot;), collapse = &quot;.&quot;) ## [1] &quot;one six.two seven.three eight.four nine.five ten&quot; paste(c(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;, &quot;five&quot;), c(&quot;six&quot;, &quot;seven&quot;, &quot;eight&quot;, &quot;nine&quot;, &quot;ten&quot;), collapse = &quot;&amp;&amp;&quot;) ## [1] &quot;one six&amp;&amp;two seven&amp;&amp;three eight&amp;&amp;four nine&amp;&amp;five ten&quot; paste(c(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;, &quot;five&quot;), c(&quot;six&quot;, &quot;seven&quot;, &quot;eight&quot;, &quot;nine&quot;, &quot;ten&quot;), collapse = &quot; &quot;) ## [1] &quot;one six two seven three eight four nine five ten&quot; In the example above by default paste created a vector with five elements, each containing one input string from the first input vector and one from the second vector, pasted together. When a non NULL argument was specified for collapse, the vector created had one element, with the pasted strings separated by that argument.1 Also don’t forget that R “recycles” values from vectors if two or more different length vectors are provided as input. paste(c(&quot;a&quot;, &quot;b&quot;), 1:10, sep = &quot;&quot;) ## [1] &quot;a1&quot; &quot;b2&quot; &quot;a3&quot; &quot;b4&quot; &quot;a5&quot; &quot;b6&quot; &quot;a7&quot; &quot;b8&quot; &quot;a9&quot; &quot;b10&quot; paste(c(&quot;a&quot;, &quot;b&quot;), 1:9, sep = &quot;&quot;) ## [1] &quot;a1&quot; &quot;b2&quot; &quot;a3&quot; &quot;b4&quot; &quot;a5&quot; &quot;b6&quot; &quot;a7&quot; &quot;b8&quot; &quot;a9&quot; Next, consider writing a function which simulates repeatedly tossing a coin \\(n\\) times, counting the number of HEADS out of the \\(n\\) tosses. For the first five repetitions of \\(n\\) tosses, the function will print out the number of HEADS (for example if there are 7 HEADS in the \\(n=10\\) tosses the function prints “The number of HEADS out of 10 tosses is 7.” The function returns a histogram of the number of HEADS, with a title stating “Number of HEADS in ?? tosses” where ?? is replaced by the number of tosses. The paste function will help greatly. coin_toss &lt;- function(n=10, iter = 500){ require(ggplot2) df &lt;- data.frame(numheads = numeric(iter)) for(i in 1:iter) { df$numheads[i] &lt;- rbinom(1, n, 0.5) if(i &lt;= 5) { print(paste(&quot;The number of HEADS out of&quot;, n, &quot;tosses is&quot;, df$numheads[i]))} } ggplot(data = df, aes(x = numheads)) + geom_histogram(binwidth = 1) + ggtitle(paste(&quot;Number of HEADS in&quot;, n, &quot;tosses&quot;)) } coin_toss() ## [1] &quot;The number of HEADS out of 10 tosses is 3&quot; ## [1] &quot;The number of HEADS out of 10 tosses is 6&quot; ## [1] &quot;The number of HEADS out of 10 tosses is 6&quot; ## [1] &quot;The number of HEADS out of 10 tosses is 4&quot; ## [1] &quot;The number of HEADS out of 10 tosses is 6&quot; coin_toss(n = 25, iter=1000) ## [1] &quot;The number of HEADS out of 25 tosses is 12&quot; ## [1] &quot;The number of HEADS out of 25 tosses is 10&quot; ## [1] &quot;The number of HEADS out of 25 tosses is 14&quot; ## [1] &quot;The number of HEADS out of 25 tosses is 14&quot; ## [1] &quot;The number of HEADS out of 25 tosses is 16&quot; Let’s now return to the object moby_dick that contains the text of the novel. If we want to analyze word choice, word frequency, etc., it would be helpful to form a vector in which each element is a word from the novel. One way to do this is to first paste the current version of the moby_dick variable into a new version which is one long vector with the lines pasted together. To illustrate, we will first do this with a much smaller object that shares the structure of moby_dick. small_novel &lt;- c(&quot;First line&quot;, &quot;Second somewhat longer line&quot;, &quot;third line.&quot;) small_novel ## [1] &quot;First line&quot; &quot;Second somewhat longer line&quot; ## [3] &quot;third line.&quot; small_novel &lt;- paste(small_novel, collapse=&quot; &quot;) length(small_novel) ## [1] 1 small_novel ## [1] &quot;First line Second somewhat longer line third line.&quot; Now we do the same with the actual novel. moby_dick &lt;- paste(moby_dick, collapse = &quot; &quot;) length(moby_dick) ## [1] 1 At this point moby_dick contains a single very long character string. Next we will separate this string into separate words and clean up the resulting vector a bit. 12.3 More String Processing Functions Common string processing tasks include changing case between upper and lower, extracting and/or replacing substrings of a string, trimming a string to a specified width, counting the number of characters in a string, etc. 12.3.1 tolower and toupper R contains functions tolower and toupper which very simply change the case of all characters in a string. x &lt;- &quot;aBCdefG12#&quot; y &lt;- x tolower(x) ## [1] &quot;abcdefg12#&quot; toupper(y) ## [1] &quot;ABCDEFG12#&quot; If we are interested in frequencies of words in Moby Dick, converting all the text to the same case makes sense, so for example the word “the” at the beginning of a sentence is not counted differently than the same word in the middle of a sentence. moby_dick &lt;- tolower(moby_dick) 12.3.2 nchar and strsplit The function nchar counts the number of characters in a string or strings. nchar(&quot;dog&quot;) ## [1] 3 nchar(c(&quot;dog&quot;, &quot;cat&quot;, &quot;horse&quot;, &quot;elephant&quot;)) ## [1] 3 3 5 8 nchar(c(&quot;dog&quot;, &quot;cat&quot;, &quot;horse&quot;, &quot;elephant&quot;, NA, &quot;goat&quot;)) ## [1] 3 3 5 8 NA 4 nchar(c(&quot;dog&quot;, &quot;cat&quot;, &quot;horse&quot;, &quot;elephant&quot;, NA, &quot;goat&quot;), keepNA = FALSE) ## [1] 3 3 5 8 2 4 nchar(moby_dick) ## [1] 1190309 By default nchar returns NA for a missing value. If you want nchar to return 2 for a NA value, you can set keepNA = TRUE.2 The function strsplit splits the elements of a character vector. The function returns a list, and often the unlist function is useful to convert the list into an atomic vector. strsplit(c(&quot;mail.msu.edu&quot;, &quot;mail.google.com&quot;, &quot;www.amazon.com&quot;), split = &quot;.&quot;, fixed = TRUE) ## [[1]] ## [1] &quot;mail&quot; &quot;msu&quot; &quot;edu&quot; ## ## [[2]] ## [1] &quot;mail&quot; &quot;google&quot; &quot;com&quot; ## ## [[3]] ## [1] &quot;www&quot; &quot;amazon&quot; &quot;com&quot; unlist(strsplit(c(&quot;mail.msu.edu&quot;, &quot;mail.google.com&quot;, &quot;www.amazon.com&quot;), split = &quot;.&quot;, fixed = TRUE)) ## [1] &quot;mail&quot; &quot;msu&quot; &quot;edu&quot; &quot;mail&quot; &quot;google&quot; &quot;com&quot; &quot;www&quot; &quot;amazon&quot; ## [9] &quot;com&quot; unlist(strsplit(c(&quot;dog&quot;, &quot;cat&quot;, &quot;pig&quot;, &quot;horse&quot;), split = &quot;o&quot;, fixed = TRUE)) ## [1] &quot;d&quot; &quot;g&quot; &quot;cat&quot; &quot;pig&quot; &quot;h&quot; &quot;rse&quot; Setting the argument fixed to TRUE tells R to match the value of split exactly when performing the split. The function can be much more powerful if the value of split is a regular expression, which can for example ask for splits at any vowels, etc. We will not go in depth on Regular Expressions here, but we will make some use of regular expressions on a case-by-case basis prior to that. Regular expressions are very powerful, so if this chapter interests you, we suggest researching regular expressions on your own (as always there are plenty of free resources online). unlist(strsplit(c(&quot;dog&quot;, &quot;cat&quot;, &quot;pig&quot;, &quot;horse&quot;, &quot;rabbit&quot;), split = &quot;[aeiou]&quot;)) ## [1] &quot;d&quot; &quot;g&quot; &quot;c&quot; &quot;t&quot; &quot;p&quot; &quot;g&quot; &quot;h&quot; &quot;rs&quot; &quot;r&quot; &quot;bb&quot; &quot;t&quot; The regular expression [aeiou] represents any of the letters a, e, i, o, u. In general a string of characters enclosed in square brackets indicates any one character in the string. unlist(strsplit(c(&quot;dog&quot;, &quot;cat&quot;, &quot;pig&quot;, &quot;horse&quot;, &quot;rabbit&quot;), split = &quot;[aorb]&quot;)) ## [1] &quot;d&quot; &quot;g&quot; &quot;c&quot; &quot;t&quot; &quot;pig&quot; &quot;h&quot; &quot;&quot; &quot;se&quot; &quot;&quot; &quot;&quot; &quot;&quot; ## [12] &quot;&quot; &quot;it&quot; The regular expression [aorb] represents any of the letters a, o, r, b. unlist(strsplit(c(&quot;a1c2b&quot;, &quot;bbb2bc3f&quot;), split = &quot;[1-9]&quot;)) ## [1] &quot;a&quot; &quot;c&quot; &quot;b&quot; &quot;bbb&quot; &quot;bc&quot; &quot;f&quot; The regular expression [1-9] represents any of the numbers 1, 2, 3, 4, 5, 6, 7, 8, 9. unlist(strsplit(c(&quot;aBc1fGh&quot;, &quot;1TyzaaG&quot;), split = &quot;[^a-z]&quot;)) ## [1] &quot;a&quot; &quot;c&quot; &quot;f&quot; &quot;h&quot; &quot;&quot; &quot;&quot; &quot;yzaa&quot; The regular expression [a-z] represents any lower case letter. The caret ^ in front of a-z indicates “match any character except those in the following string” which in this case indicates “match any character that is NOT a lower case letter”. Recall that the moby_dick vector now contains one long character string which includes the entire text of the novel, and that we would like to split it into separate words. We now know how to do this using strsplit and a regular expression. First a smaller example. unlist(strsplit(c(&quot;the rain&quot;, &quot;in Spain stays mainly&quot;, &quot;in&quot;, &quot;the plain&quot;), split = &quot;[^0-9A-Za-z]&quot;)) ## [1] &quot;the&quot; &quot;rain&quot; &quot;in&quot; &quot;Spain&quot; &quot;stays&quot; &quot;mainly&quot; &quot;in&quot; &quot;the&quot; ## [9] &quot;plain&quot; unlist(strsplit(c(&quot;the rain&quot;, &quot;in Spain stays mainly&quot;, &quot;in&quot;, &quot;the plain&quot;), split =&quot; &quot;, fixed = TRUE)) ## [1] &quot;the&quot; &quot;rain&quot; &quot;in&quot; &quot;Spain&quot; &quot;stays&quot; &quot;mainly&quot; &quot;in&quot; &quot;the&quot; ## [9] &quot;plain&quot; Look at the regular expression. The caret says “match anything but” and then 0=9A-Za-z says “any digit, any lower-case letter, and any upper-case letter.” So the whole expression (including the fact that it is the value of the argument split) says “match anything but any digit, any lower-case letter, or any upper-case letter”. Now we apply this to moby_dick. moby_dick &lt;- unlist(strsplit(moby_dick, split = &quot;[^0-9A-Za-z]&quot;)) Let’s see a bit of what we have. moby_dick[1:50] ## [1] &quot;chapter&quot; &quot;1&quot; &quot;&quot; &quot;loomings&quot; &quot;&quot; ## [6] &quot;call&quot; &quot;me&quot; &quot;ishmael&quot; &quot;&quot; &quot;some&quot; ## [11] &quot;years&quot; &quot;ago&quot; &quot;&quot; &quot;never&quot; &quot;mind&quot; ## [16] &quot;how&quot; &quot;long&quot; &quot;precisely&quot; &quot;&quot; &quot;having&quot; ## [21] &quot;little&quot; &quot;or&quot; &quot;no&quot; &quot;money&quot; &quot;in&quot; ## [26] &quot;my&quot; &quot;purse&quot; &quot;&quot; &quot;and&quot; &quot;nothing&quot; ## [31] &quot;particular&quot; &quot;to&quot; &quot;interest&quot; &quot;me&quot; &quot;on&quot; ## [36] &quot;shore&quot; &quot;&quot; &quot;i&quot; &quot;thought&quot; &quot;i&quot; ## [41] &quot;would&quot; &quot;sail&quot; &quot;about&quot; &quot;a&quot; &quot;little&quot; ## [46] &quot;and&quot; &quot;see&quot; &quot;the&quot; &quot;watery&quot; &quot;part&quot; There is a small problem: Some of the “words” are blank. The following small example indicates why this happened. unlist(strsplit(c(&quot;the rain&quot;, &quot;in Spain stays mainly&quot;, &quot;in&quot;, &quot;the plain&quot;), split = &quot;[^0-9A-Za-z]&quot;)) ## [1] &quot;the&quot; &quot;rain&quot; &quot;in&quot; &quot;Spain&quot; &quot;&quot; &quot;&quot; &quot;&quot; ## [8] &quot;stays&quot; &quot;mainly&quot; &quot;in&quot; &quot;the&quot; &quot;plain&quot; It is not too hard to remove the blank words. length(moby_dick) ## [1] 253993 not.blanks &lt;- which(moby_dick != &quot;&quot;) moby_dick &lt;- moby_dick[not.blanks] length(moby_dick) ## [1] 214889 moby_dick[1:50] ## [1] &quot;chapter&quot; &quot;1&quot; &quot;loomings&quot; &quot;call&quot; &quot;me&quot; ## [6] &quot;ishmael&quot; &quot;some&quot; &quot;years&quot; &quot;ago&quot; &quot;never&quot; ## [11] &quot;mind&quot; &quot;how&quot; &quot;long&quot; &quot;precisely&quot; &quot;having&quot; ## [16] &quot;little&quot; &quot;or&quot; &quot;no&quot; &quot;money&quot; &quot;in&quot; ## [21] &quot;my&quot; &quot;purse&quot; &quot;and&quot; &quot;nothing&quot; &quot;particular&quot; ## [26] &quot;to&quot; &quot;interest&quot; &quot;me&quot; &quot;on&quot; &quot;shore&quot; ## [31] &quot;i&quot; &quot;thought&quot; &quot;i&quot; &quot;would&quot; &quot;sail&quot; ## [36] &quot;about&quot; &quot;a&quot; &quot;little&quot; &quot;and&quot; &quot;see&quot; ## [41] &quot;the&quot; &quot;watery&quot; &quot;part&quot; &quot;of&quot; &quot;the&quot; ## [46] &quot;world&quot; &quot;it&quot; &quot;is&quot; &quot;a&quot; &quot;way&quot; (In this example it would have been more efficient to replace moby_dick &lt;- unlist(strsplit(moby_dick, split = &quot;[^0-9A-Za-z]&quot;)) moby_dick2 &lt;- unlist(strsplit(moby_dick, split = &quot; &quot;, fixed = TRUE)) Then the second step of selecting the non-blank words would not have been necessary. But regular expressions will be essential going forward, so it was worthwhile using regular expressions even if they do not provide the most efficient method.) 12.3.3 Practice Exercise Use strsplit() and regular expressions to split the following strings into their respective words (i.e. write a regular expression that will match the - and . character). Your output should be a vector (not a list). strings &lt;- c(&quot;Once-upon&quot;, &quot;a.time&quot;, &quot;there&quot;, &quot;was-a&quot;, &quot;man.named&quot;, &quot;Bob&quot;) ## [1] &quot;Once&quot; &quot;upon&quot; &quot;a&quot; &quot;time&quot; &quot;there&quot; &quot;was&quot; &quot;a&quot; &quot;man&quot; ## [9] &quot;named&quot; &quot;Bob&quot; 12.3.4 nchar Again Now that the vector moby_dick contains each word in the novel as a separate element, it is relatively easy to do some basic analyses. For example the nchar function can give us a count of the number of characters in each element of the vector, i.e., can give us the number of letters in each word in the novel. moby_dick_nchar &lt;- nchar(moby_dick) moby_dick_nchar[1:50] ## [1] 7 1 8 4 2 7 4 5 3 5 4 3 4 9 6 6 2 2 5 2 2 5 3 ## [24] 7 10 2 8 2 2 5 1 7 1 5 4 5 1 6 3 3 3 6 4 2 3 5 ## [47] 2 2 1 3 max(moby_dick_nchar) ## [1] 20 ggplot(data = data.frame(nwords = moby_dick_nchar), aes(x = nwords)) + geom_histogram(binwidth = 1, color = &quot;black&quot;, fill = &quot;white&quot;) + ggtitle(&quot;Number of letters in words in Moby Dick&quot;) + theme_bw() moby_dick_word_table &lt;- table(moby_dick) moby_dick_word_table &lt;- sort(moby_dick_word_table, decreasing = TRUE) moby_dick_word_table[1:50] ## moby_dick ## the of and a to in that it his i he but ## 14175 6469 6325 4636 4539 4077 3045 2497 2495 2114 1876 1805 ## s as with is was for all this at by whale not ## 1737 1720 1692 1690 1627 1593 1515 1382 1304 1175 1150 1142 ## from him so on be one you there now had have or ## 1072 1058 1053 1040 1032 907 884 854 779 767 754 689 ## were they like me then which what some their when an are ## 677 649 639 630 628 625 611 608 604 601 590 587 ## my no ## 587 581 12.3.5 Practice Exercise The goal of this exercise is to generate a wordcloud image of the 50 most frqeuent words in Moby Dick that we identifid above. To do this, we need the wordcloud package (you may also need to install the package tm). Look at the R documentation for the wordcloud function included in the wordcloud package and create a wordcloud image of the most popular 500 words in the novel. Here is what mine looks like 12.3.6 substr and strtrim The substr function can be used to extract or replace substrings. The first argument is the string to be manipulated, and the second and third arguments specify the first and last elements of the string to be extracted or to be replaced. x &lt;- &quot;Michigan&quot; substr(x, 3, 4) ## [1] &quot;ch&quot; substr(x, 3, 4) &lt;- &quot;CH&quot; x ## [1] &quot;MiCHigan&quot; x &lt;- c(&quot;Ohio&quot;, &quot;Michigan&quot;, &quot;Illinois&quot;, &quot;Wisconsin&quot;) substr(x, 2,4) ## [1] &quot;hio&quot; &quot;ich&quot; &quot;lli&quot; &quot;isc&quot; substr(x, 2, 4) &lt;- &quot;$#&amp;&quot; x ## [1] &quot;O$#&amp;&quot; &quot;M$#&amp;igan&quot; &quot;I$#&amp;nois&quot; &quot;W$#&amp;onsin&quot; The strtrim function trims a character string to a specified length. strtrim(&quot;Michigan&quot;, 1) ## [1] &quot;M&quot; strtrim(&quot;Michigan&quot;, 4) ## [1] &quot;Mich&quot; strtrim(&quot;Michigan&quot;, 100) ## [1] &quot;Michigan&quot; strtrim(c(&quot;Ohio&quot;, &quot;Michigan&quot;, &quot;Illinois&quot;, &quot;Wisconsin&quot;), 3) ## [1] &quot;Ohi&quot; &quot;Mic&quot; &quot;Ill&quot; &quot;Wis&quot; strtrim(c(&quot;Ohio&quot;, &quot;Michigan&quot;, &quot;Illinois&quot;, &quot;Wisconsin&quot;), c(3, 4, 5, 6)) ## [1] &quot;Ohi&quot; &quot;Mich&quot; &quot;Illin&quot; &quot;Wiscon&quot; 12.3.7 grep and Related Functions The grep function searches for a specified pattern and returns either the locations where this pattern is found or the selected elements. The grepl function returns a logical vector rather than locations of elements. Here are some examples. All use fixed = TRUE since at this point we are using fixed character strings rather than regular expressions. grep(&quot;a&quot;, c(&quot;the rain&quot;, &quot;in Spain stays mainly&quot;, &quot;in&quot;, &quot;the plain&quot;), fixed = TRUE) ## [1] 1 2 4 grep(&quot;a&quot;, c(&quot;the rain&quot;, &quot;in Spain stays mainly&quot;, &quot;in&quot;, &quot;the plain&quot;), fixed = TRUE, value = TRUE) ## [1] &quot;the rain&quot; &quot;in Spain stays mainly&quot; ## [3] &quot;the plain&quot; grepl(&quot;a&quot;, c(&quot;the rain&quot;, &quot;in Spain stays mainly&quot;, &quot;in&quot;, &quot;the plain&quot;), fixed = TRUE) ## [1] TRUE TRUE FALSE TRUE The sub and gsub functions replace a specified character string. The sub function only replaces the first occurrence, while gsub replaces all occurrences. gsub(&quot;a&quot;, &quot;?&quot;, c(&quot;the rain&quot;, &quot;in Spain stays mainly&quot;, &quot;in&quot;, &quot;the plain&quot;), fixed = TRUE) ## [1] &quot;the r?in&quot; &quot;in Sp?in st?ys m?inly&quot; ## [3] &quot;in&quot; &quot;the pl?in&quot; sub(&quot;a&quot;, &quot;?&quot;, c(&quot;the rain&quot;, &quot;in Spain stays mainly&quot;, &quot;in&quot;, &quot;the plain&quot;), fixed = TRUE) ## [1] &quot;the r?in&quot; &quot;in Sp?in stays mainly&quot; ## [3] &quot;in&quot; &quot;the pl?in&quot; gsub(&quot;a&quot;, &quot;???&quot;, c(&quot;the rain&quot;, &quot;in Spain stays mainly&quot;, &quot;in&quot;, &quot;the plain&quot;), fixed = TRUE) ## [1] &quot;the r???in&quot; &quot;in Sp???in st???ys m???inly&quot; ## [3] &quot;in&quot; &quot;the pl???in&quot; sub(&quot;a&quot;, &quot;???&quot;, c(&quot;the rain&quot;, &quot;in Spain stays mainly&quot;, &quot;in&quot;, &quot;the plain&quot;), fixed = TRUE) ## [1] &quot;the r???in&quot; &quot;in Sp???in stays mainly&quot; ## [3] &quot;in&quot; &quot;the pl???in&quot; 12.4 Homework Exercise Text Data Learning objectives: read and write text data; concatenate text with the paste function, analyze text with nchar; practice with functions; manipulate strings with substr and strtrim. There is a somewhat subtle difference among the examples. If all the arguments are length one vectors, then paste by default returns a length one vector. But if one or more of the arguments have length greater than one, the default behavior of paste is to return a vector of length greater than one. The collapse argument changes this behavior.↩ It may be reasonable if the purpose of counting characters is to find out how much space to allocate for printing a vector of strings where the NA string will be printed.↩ "]
]
